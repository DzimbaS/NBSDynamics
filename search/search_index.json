{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NBSDynamics documentation \u00b6 On this pages diverse information can be found related to this project. Project layout \u00b6 The project is currently being structured as follows: docs/ # Contains the documentation related to this project. guides/ # Contains the documentation related to installation, usage and contribution to this project. reference/ # Contains references to the modules. Docstrings will be used to generate automatically documentation. src/ core/ # Module containing all the classes and methods of NBSDynamics. bio_process/ # The classes describing biophysical processes. hydrodynamics/ # The different hydrodynamic models ('Transect', 'Delft3D', 'Reef0D', 'Reef1D') output/ # The output models. tools/ # Module containing tools used by the coral_model module. test/ # Module based on pytest to mirror and test all the classes from src/ Version control \u00b6 Currently versioning is done with the help of commitizen using a tag system of v.Major.Minor.Patch . A the changelog.md is generated automatically. Project architecture \u00b6 At the moment of this edition (version v.0.5.1), the project has undergone several refactorings and is divided in different modules and components as explained in the 'Project layout' section. A summary of the architecture can be seen in the following 'reduced' class diagram: SimulationProtocol \u00b6 HydrodynamicProtocol \u00b6 CoralProtocol \u00b6 OutputProtocol \u00b6 CoralModel \u00b6 A biophysical model framework written in Python to make simulations on coral development based on four environmental factors: (1) light; (2) flow; (3) temperature; and (4) acidity. For the hydrodynamics, the model can be coupled to Delft3D Flexible Mesh; a hydrodynamic model developed at Deltares ( more information ). To enable this online coupling, certain configurations of Python are required ( more details ). Note: This model is still in its beta and further development is still being done. coral_model_v0 is used for the study and is rewritten ( coral_model ) to enhance collaboration. (The original version has not been written efficiently and is hard to follow for outsiders.) More information on this version control here . Biophysics \u00b6 This biophysical model framework is part of the result of a master thesis of which the key findings are published in Environmental Modelling and Software (the paper can be found here ). The biophysical relations used in the biophysical model framework are mainly process-based, where for the acidity the proxy of the aragonite saturation state is used. Furthermore, both photo- and thermal-acclimatisation are included, which result in a dynamic behaviour of the corals to their environment. Hence, the corals are modelled such that they can adapt to changing environmental conditions over time. For more details on the biophysics, reference is made to the master thesis and the paper that substitute this repository. Python code \u00b6 The Python code is written in Python 3 and makes use of various packages. Not all of these packages are automatically included in the standard library of Python, such as NetCDF4 ( download ). In case the biophysical model framework is to be coupled to Delft3d Flexible Mesh, the bmi.wrapper package is also required ( download ). The settings of Python and other packages for the online coupling to work properly are the following: Python version 3.6.5 NumPy version 1.14.3 SciPy version 1.1.0 NetCDF4 version 1.4.2 Matplotlib version 2.2.2 BMI-Python Note: These requirements are only required in case the biophysical model framework is to be coupled with Delft3D Flexible Mesh. Version control \u00b6 There are two versions of the CoralModel: coral_model_v0 and coral_model . The first ( coral_model_v0 ) is the original code as used in the study (i.e. master thesis and paper ). The latter ( coral_model ) is an updated version, which is rewritten such that it enhances collaboration. This collaboration was one of the goals to further develop this model, and the biophysical modelling of coral development. coral_model_v0 will be depreciated in the future, when coral_model is fully operational and possibly even incorporates more aspects of coral (reef) development.","title":"NBSDynamics documentation"},{"location":"#nbsdynamics-documentation","text":"On this pages diverse information can be found related to this project.","title":"NBSDynamics documentation"},{"location":"#project-layout","text":"The project is currently being structured as follows: docs/ # Contains the documentation related to this project. guides/ # Contains the documentation related to installation, usage and contribution to this project. reference/ # Contains references to the modules. Docstrings will be used to generate automatically documentation. src/ core/ # Module containing all the classes and methods of NBSDynamics. bio_process/ # The classes describing biophysical processes. hydrodynamics/ # The different hydrodynamic models ('Transect', 'Delft3D', 'Reef0D', 'Reef1D') output/ # The output models. tools/ # Module containing tools used by the coral_model module. test/ # Module based on pytest to mirror and test all the classes from src/","title":"Project layout"},{"location":"#version-control","text":"Currently versioning is done with the help of commitizen using a tag system of v.Major.Minor.Patch . A the changelog.md is generated automatically.","title":"Version control"},{"location":"#project-architecture","text":"At the moment of this edition (version v.0.5.1), the project has undergone several refactorings and is divided in different modules and components as explained in the 'Project layout' section. A summary of the architecture can be seen in the following 'reduced' class diagram:","title":"Project architecture"},{"location":"#simulationprotocol","text":"","title":"SimulationProtocol"},{"location":"#hydrodynamicprotocol","text":"","title":"HydrodynamicProtocol"},{"location":"#coralprotocol","text":"","title":"CoralProtocol"},{"location":"#outputprotocol","text":"","title":"OutputProtocol"},{"location":"#coralmodel","text":"A biophysical model framework written in Python to make simulations on coral development based on four environmental factors: (1) light; (2) flow; (3) temperature; and (4) acidity. For the hydrodynamics, the model can be coupled to Delft3D Flexible Mesh; a hydrodynamic model developed at Deltares ( more information ). To enable this online coupling, certain configurations of Python are required ( more details ). Note: This model is still in its beta and further development is still being done. coral_model_v0 is used for the study and is rewritten ( coral_model ) to enhance collaboration. (The original version has not been written efficiently and is hard to follow for outsiders.) More information on this version control here .","title":"CoralModel"},{"location":"#biophysics","text":"This biophysical model framework is part of the result of a master thesis of which the key findings are published in Environmental Modelling and Software (the paper can be found here ). The biophysical relations used in the biophysical model framework are mainly process-based, where for the acidity the proxy of the aragonite saturation state is used. Furthermore, both photo- and thermal-acclimatisation are included, which result in a dynamic behaviour of the corals to their environment. Hence, the corals are modelled such that they can adapt to changing environmental conditions over time. For more details on the biophysics, reference is made to the master thesis and the paper that substitute this repository.","title":"Biophysics "},{"location":"#python-code","text":"The Python code is written in Python 3 and makes use of various packages. Not all of these packages are automatically included in the standard library of Python, such as NetCDF4 ( download ). In case the biophysical model framework is to be coupled to Delft3d Flexible Mesh, the bmi.wrapper package is also required ( download ). The settings of Python and other packages for the online coupling to work properly are the following: Python version 3.6.5 NumPy version 1.14.3 SciPy version 1.1.0 NetCDF4 version 1.4.2 Matplotlib version 2.2.2 BMI-Python Note: These requirements are only required in case the biophysical model framework is to be coupled with Delft3D Flexible Mesh.","title":"Python code "},{"location":"#version-control_1","text":"There are two versions of the CoralModel: coral_model_v0 and coral_model . The first ( coral_model_v0 ) is the original code as used in the study (i.e. master thesis and paper ). The latter ( coral_model ) is an updated version, which is rewritten such that it enhances collaboration. This collaboration was one of the goals to further develop this model, and the biophysical modelling of coral development. coral_model_v0 will be depreciated in the future, when coral_model is fully operational and possibly even incorporates more aspects of coral (reef) development.","title":"Version control "},{"location":"changelog/","text":"v0.8.0 (2021-11-18) \u00b6 Feat \u00b6 RESHAPE as singleton (#73) v0.7.0 (2021-11-18) \u00b6 Feat \u00b6 fix bmi calls (#67) v0.6.0 (2021-11-17) \u00b6 Feat \u00b6 src/core/simulation/base_simulation.py : Added vanilla simulation, adapted reef models to be pydantic src/core/hydrodynamics/transect.py : Transect initializes now as a pydantic model. Smaller related refactorings src/core/hydrodynamics/delft3d.py : dll_path can be now manually set by the user src/core/hydrodynamics/delft3d.py : Now the user can input their own path to the dll to be run Fix \u00b6 src/core/simulation/coral_delft3d_simulation.py : Minor corrections to the outpoint definition src/core/hydrodynamics/delft3d.py : Minor fix to xy_coordinates inital values src/core/output/output_wrapper.py : Adapted output_wrapper to ensure an output_dir is given for all the output_model instances src/core/hydrodynamics/delft3d.py : Renamed method, added explanation of what needs to be done Refactor \u00b6 test/core/simulation : Removed unnecessary class method, adapted tests, fixed failing tests src/core/simulation/base_simulation.py : Adapted simulation logic to initate hydrodynamics in a pydantic way v0.5.1 (2021-11-16) \u00b6 Fix \u00b6 bio_process/test_morphology.py : removed bug from test fixture v0.5.0 (2021-11-15) \u00b6 Feat \u00b6 coral model as protocol (#66) simulation as protocol (#65) v0.4.0 (2021-11-15) \u00b6 Fix \u00b6 test/test_acceptance.py : corrected numpy usage src/core/output/output_wrapper.py : Output wrapper now creates the output dir if it was not there already Feat \u00b6 src/core/simulation.py;test/test_acceptance.py : Now simulations can delegate the initial setup of a hydrodynamic model, adapted test for d3d case src/core/output/output_model.py;src/core/output/output_wrapper.py;src/core/hydrodynamics/factory.py;src/core/simulation.py : Refactor output wrapper and simulation classes so they can be instantiated with less attributes v0.3.0 (2021-11-12) \u00b6 Feat \u00b6 Create test bmi coral (#63) v0.2.0 (2021-11-11) \u00b6 Fix \u00b6 src/core/environment.py;src/core/simulation.py;test/core/test_environment.py : Extended validation for dates so they can be added as string from the initialization src/core/output/output_wrapper.py : Now we add the dict attributes from the wrapper to the output models src/core/output/output_model.py;src/core/output/output_wrapper.py;src/core/simulation.py;test/core/output/test_wrapper.py : Now we correctly initialize the map_output model. Adapted test output wrapper src;test : Output model generates again the netcdf files correctly. src/tools/plot_output.py : Corrected call to plot tool Feat \u00b6 src/core/environment.py;src/core/simulation.py : Adapted environment and related classes to pydantic approach src/core/coral_model.py;src/core/simulation.py;test/test_acceptance.py : Coral integrated in simulation Refactor \u00b6 src/core/environment.py;src/core/simulation.py;test/core/test_simulation : Improved environment as class src/core/environment.py;src/core/output_model.py;src/core/simulation.py;test/core/test_output : Applying pydantic to Output model. src/core/simulation : Added validator to simulation constants property src/core/simulation.py;test/test_acceptance : Adapted code for better pydantic usage src/core/output_model : Fixed failing tests for TestOutput src/core/output_model : Minor corrections to the model src/core/output_model : Small fix, however model still not running. src/core/output_model : fixed ini/update his/map src/core/environment : Added extra logic to accept str as path. src/core/output/output_model : Extracted two submodels from Output, moved into its own module. src/core/output/output_protocol.py;src/core/output/output_wrapper : Separating concepts to avoid code duplication src/core/output/output_model.py;src/core/output/output_protocol.py;src/core/output/output_wrapper : Refactor output module for better maintainability and reducing its complexity. test/core/output/test_wrapper : Moved test to mirror src structure src/core/output/ : Extended docstrings for output_protocol; Generated coverage tests for output_model. Fixed simulation calls to output initialization. test_output_wrapper : Renamed filename to match src tested file v0.1.4 (2021-11-11) \u00b6 Fix \u00b6 quality gate fix (#62) Feat \u00b6 Create model input v0.1.3 (2021-11-08) \u00b6 Refactor \u00b6 src/core/coral_only.py : Extracted coral only for better maintainability. src/core/output_model.py;src/core/utils.py : further type hinting. src/core/output_model.py : Fixed setting of xy_stations. core/utils.py : Added more type hinting. core/utils.py : Adding type hints. core/loop.py;core/output_model.py;core/utils.py : Extracted output model logic into its own class. Introduced new libraries. v0.1.2 (2021-11-05) \u00b6 v0.1.1 (2021-11-05) \u00b6 Fix \u00b6 .github/workflows/ci.yml : improve code coverage (#44) v0.1.0 (2021-11-04) \u00b6 Fix \u00b6 Fix merged conflict Feat \u00b6 Pull-request 31 normalize versioning (#42) v0.0.4 (2021-11-04) \u00b6 Fix \u00b6 pyproject.toml : Corrected version file for core directory. pyproject.toml : Changed bump pattern and map to include refactor and docs. v0.0.3 (2021-11-04) \u00b6 Refactor \u00b6 hydrodynamics.py : Refactor the update method to use update_ (#30) v0.0.2 (2021-10-29) \u00b6 Fix \u00b6 environment.py-utils.py : Fixed bugs described in sonarcloud (#26) Removed-unused-reference. : removed unused reference","title":"Changelog"},{"location":"changelog/#v080-2021-11-18","text":"","title":"v0.8.0 (2021-11-18)"},{"location":"changelog/#feat","text":"RESHAPE as singleton (#73)","title":"Feat"},{"location":"changelog/#v070-2021-11-18","text":"","title":"v0.7.0 (2021-11-18)"},{"location":"changelog/#feat_1","text":"fix bmi calls (#67)","title":"Feat"},{"location":"changelog/#v060-2021-11-17","text":"","title":"v0.6.0 (2021-11-17)"},{"location":"changelog/#feat_2","text":"src/core/simulation/base_simulation.py : Added vanilla simulation, adapted reef models to be pydantic src/core/hydrodynamics/transect.py : Transect initializes now as a pydantic model. Smaller related refactorings src/core/hydrodynamics/delft3d.py : dll_path can be now manually set by the user src/core/hydrodynamics/delft3d.py : Now the user can input their own path to the dll to be run","title":"Feat"},{"location":"changelog/#fix","text":"src/core/simulation/coral_delft3d_simulation.py : Minor corrections to the outpoint definition src/core/hydrodynamics/delft3d.py : Minor fix to xy_coordinates inital values src/core/output/output_wrapper.py : Adapted output_wrapper to ensure an output_dir is given for all the output_model instances src/core/hydrodynamics/delft3d.py : Renamed method, added explanation of what needs to be done","title":"Fix"},{"location":"changelog/#refactor","text":"test/core/simulation : Removed unnecessary class method, adapted tests, fixed failing tests src/core/simulation/base_simulation.py : Adapted simulation logic to initate hydrodynamics in a pydantic way","title":"Refactor"},{"location":"changelog/#v051-2021-11-16","text":"","title":"v0.5.1 (2021-11-16)"},{"location":"changelog/#fix_1","text":"bio_process/test_morphology.py : removed bug from test fixture","title":"Fix"},{"location":"changelog/#v050-2021-11-15","text":"","title":"v0.5.0 (2021-11-15)"},{"location":"changelog/#feat_3","text":"coral model as protocol (#66) simulation as protocol (#65)","title":"Feat"},{"location":"changelog/#v040-2021-11-15","text":"","title":"v0.4.0 (2021-11-15)"},{"location":"changelog/#fix_2","text":"test/test_acceptance.py : corrected numpy usage src/core/output/output_wrapper.py : Output wrapper now creates the output dir if it was not there already","title":"Fix"},{"location":"changelog/#feat_4","text":"src/core/simulation.py;test/test_acceptance.py : Now simulations can delegate the initial setup of a hydrodynamic model, adapted test for d3d case src/core/output/output_model.py;src/core/output/output_wrapper.py;src/core/hydrodynamics/factory.py;src/core/simulation.py : Refactor output wrapper and simulation classes so they can be instantiated with less attributes","title":"Feat"},{"location":"changelog/#v030-2021-11-12","text":"","title":"v0.3.0 (2021-11-12)"},{"location":"changelog/#feat_5","text":"Create test bmi coral (#63)","title":"Feat"},{"location":"changelog/#v020-2021-11-11","text":"","title":"v0.2.0 (2021-11-11)"},{"location":"changelog/#fix_3","text":"src/core/environment.py;src/core/simulation.py;test/core/test_environment.py : Extended validation for dates so they can be added as string from the initialization src/core/output/output_wrapper.py : Now we add the dict attributes from the wrapper to the output models src/core/output/output_model.py;src/core/output/output_wrapper.py;src/core/simulation.py;test/core/output/test_wrapper.py : Now we correctly initialize the map_output model. Adapted test output wrapper src;test : Output model generates again the netcdf files correctly. src/tools/plot_output.py : Corrected call to plot tool","title":"Fix"},{"location":"changelog/#feat_6","text":"src/core/environment.py;src/core/simulation.py : Adapted environment and related classes to pydantic approach src/core/coral_model.py;src/core/simulation.py;test/test_acceptance.py : Coral integrated in simulation","title":"Feat"},{"location":"changelog/#refactor_1","text":"src/core/environment.py;src/core/simulation.py;test/core/test_simulation : Improved environment as class src/core/environment.py;src/core/output_model.py;src/core/simulation.py;test/core/test_output : Applying pydantic to Output model. src/core/simulation : Added validator to simulation constants property src/core/simulation.py;test/test_acceptance : Adapted code for better pydantic usage src/core/output_model : Fixed failing tests for TestOutput src/core/output_model : Minor corrections to the model src/core/output_model : Small fix, however model still not running. src/core/output_model : fixed ini/update his/map src/core/environment : Added extra logic to accept str as path. src/core/output/output_model : Extracted two submodels from Output, moved into its own module. src/core/output/output_protocol.py;src/core/output/output_wrapper : Separating concepts to avoid code duplication src/core/output/output_model.py;src/core/output/output_protocol.py;src/core/output/output_wrapper : Refactor output module for better maintainability and reducing its complexity. test/core/output/test_wrapper : Moved test to mirror src structure src/core/output/ : Extended docstrings for output_protocol; Generated coverage tests for output_model. Fixed simulation calls to output initialization. test_output_wrapper : Renamed filename to match src tested file","title":"Refactor"},{"location":"changelog/#v014-2021-11-11","text":"","title":"v0.1.4 (2021-11-11)"},{"location":"changelog/#fix_4","text":"quality gate fix (#62)","title":"Fix"},{"location":"changelog/#feat_7","text":"Create model input","title":"Feat"},{"location":"changelog/#v013-2021-11-08","text":"","title":"v0.1.3 (2021-11-08)"},{"location":"changelog/#refactor_2","text":"src/core/coral_only.py : Extracted coral only for better maintainability. src/core/output_model.py;src/core/utils.py : further type hinting. src/core/output_model.py : Fixed setting of xy_stations. core/utils.py : Added more type hinting. core/utils.py : Adding type hints. core/loop.py;core/output_model.py;core/utils.py : Extracted output model logic into its own class. Introduced new libraries.","title":"Refactor"},{"location":"changelog/#v012-2021-11-05","text":"","title":"v0.1.2 (2021-11-05)"},{"location":"changelog/#v011-2021-11-05","text":"","title":"v0.1.1 (2021-11-05)"},{"location":"changelog/#fix_5","text":".github/workflows/ci.yml : improve code coverage (#44)","title":"Fix"},{"location":"changelog/#v010-2021-11-04","text":"","title":"v0.1.0 (2021-11-04)"},{"location":"changelog/#fix_6","text":"Fix merged conflict","title":"Fix"},{"location":"changelog/#feat_8","text":"Pull-request 31 normalize versioning (#42)","title":"Feat"},{"location":"changelog/#v004-2021-11-04","text":"","title":"v0.0.4 (2021-11-04)"},{"location":"changelog/#fix_7","text":"pyproject.toml : Corrected version file for core directory. pyproject.toml : Changed bump pattern and map to include refactor and docs.","title":"Fix"},{"location":"changelog/#v003-2021-11-04","text":"","title":"v0.0.3 (2021-11-04)"},{"location":"changelog/#refactor_3","text":"hydrodynamics.py : Refactor the update method to use update_ (#30)","title":"Refactor"},{"location":"changelog/#v002-2021-10-29","text":"","title":"v0.0.2 (2021-10-29)"},{"location":"changelog/#fix_8","text":"environment.py-utils.py : Fixed bugs described in sonarcloud (#26) Removed-unused-reference. : removed unused reference","title":"Fix"},{"location":"guides/contribute/","text":"How to contribute to NBSDynamics \u00b6 1. Tooling \u00b6 In this section we describe which tools this repository relays on to guarantee a standardized development. 1.1. Development environment. \u00b6 In order to develop on this project it is recommended the usage of a virtual environment. This can be easily achieved by using poetry (see below). Poetry \u00b6 We use poetry to manage our package and its dependencies, which you can download here . After installation, make sure it's available on your PATH and run it in the HYDROLIB-core directory in your shell of choice. To install the package (by default in editable mode) run poetry install . We advise using virtualenv s, Poetry will create one for you. If you need to use an already existing Python installation, you can activate it and run poetry env use system before poetry install . 1.2. Code convention / Linters \u00b6 This project uses both black and isort as an autoformatter. It is recommended following the rules defined in pyproject.toml to avoid conflicts before a merge. 1.2.1. Black \u00b6 We use black as an autoformatter. Black will curate the code follows the PEP8 convention. It is also run during CI and will fail if it's not formatted beforehand. 1.2.2. Isort \u00b6 We use isort as an autoformatter. Isort will curate the imports of each module are ordered. It is also run during CI and will fail if it's not formatted beforehand. 1.3. Continuous Integration \u00b6 Each commit made on a branch of the repository gets analyzed with Sonar Cloud . Before merging, the following rules should be fulfilled regarding new code: - Code coverage remains does not drop. - No new bugs introduced. - No new code smells introduced. - No new vulnerabilities introduced. - No new security hotspots introduced. - No new duplications of code. 1.4. Testing \u00b6 New code should be tested. As a rule of thumb public methods should be tested with unit tests and new workflows with integration tests. Acceptance tests are recommended when introducing new models. We use pytest to test our package. Run it with poetry run pytest to test your code changes locally. 1.5. Version Control \u00b6 We use commitizen to automatically bump the version number. If you use conventional commit messages , the the changelog.md is generated automatically. 1.6. Documentation \u00b6 We use mkdocs to automatically generate documentation. We define documentation in separate sections: /guides: where we include information on how to use the repository, either as maintainer or as user. /reference: where the technical documentation is linked. When creating a new module a new markdown file should be created. To refer to a module, it can be done as follows: ### core ::: src.core.core This will generate documentation based on the docstrings of each class and method in src.core.core.py changelog.md: file automatically generated and updated with the commits to master (see Version Control ) 2. Development. \u00b6 In this section we describe how development is expected to be done in this repository. 2.1. Branches \u00b6 For each issue or feature, a separate branch should be created from the main. To keep the branches organized a feature branch should be created with the feature/ prefix. When starting development on a branch, a pull request should be created for reviews and continous integration. During continuous integration, the checks will be run with python 3.8 on Windows, Ubuntu and MacOS. The checks consist of running the tests, checking the code formatting and running SonarCloud. We advise to use a draft pull request, to prevent the branch to be merged back before developement is finished. When the branch is ready for review, you can update the status of the pull request to \"ready for review\". 2.2. Reviews \u00b6 Reviews should be dona by a member of the development team on a pull-request prior to its merging. 2.3. Merging \u00b6 Merging a branch can only happen when a pull request is accepted through review. When a pull request is accepted the changes should be merged back with the \"squash and merge\" option. 2.4. Coding guidelines \u00b6 Classes and methods should make use of docstrings. If there are any additions or changes to the public API, the documentation should be updated. Files should be added to the appropriate folder to keep modules and objects within the correct scope. If there is code that needs to be tested, there should be tests written for it. Tests should be added \"mirroring\" the structure of src for a cohesive project layout.","title":"How to contribute to NBSDynamics"},{"location":"guides/contribute/#how-to-contribute-to-nbsdynamics","text":"","title":"How to contribute to NBSDynamics"},{"location":"guides/contribute/#1-tooling","text":"In this section we describe which tools this repository relays on to guarantee a standardized development.","title":"1. Tooling"},{"location":"guides/contribute/#11-development-environment","text":"In order to develop on this project it is recommended the usage of a virtual environment. This can be easily achieved by using poetry (see below).","title":"1.1. Development environment."},{"location":"guides/contribute/#poetry","text":"We use poetry to manage our package and its dependencies, which you can download here . After installation, make sure it's available on your PATH and run it in the HYDROLIB-core directory in your shell of choice. To install the package (by default in editable mode) run poetry install . We advise using virtualenv s, Poetry will create one for you. If you need to use an already existing Python installation, you can activate it and run poetry env use system before poetry install .","title":"Poetry"},{"location":"guides/contribute/#12-code-convention-linters","text":"This project uses both black and isort as an autoformatter. It is recommended following the rules defined in pyproject.toml to avoid conflicts before a merge.","title":"1.2. Code convention / Linters"},{"location":"guides/contribute/#121-black","text":"We use black as an autoformatter. Black will curate the code follows the PEP8 convention. It is also run during CI and will fail if it's not formatted beforehand.","title":"1.2.1. Black"},{"location":"guides/contribute/#122-isort","text":"We use isort as an autoformatter. Isort will curate the imports of each module are ordered. It is also run during CI and will fail if it's not formatted beforehand.","title":"1.2.2. Isort"},{"location":"guides/contribute/#13-continuous-integration","text":"Each commit made on a branch of the repository gets analyzed with Sonar Cloud . Before merging, the following rules should be fulfilled regarding new code: - Code coverage remains does not drop. - No new bugs introduced. - No new code smells introduced. - No new vulnerabilities introduced. - No new security hotspots introduced. - No new duplications of code.","title":"1.3. Continuous Integration"},{"location":"guides/contribute/#14-testing","text":"New code should be tested. As a rule of thumb public methods should be tested with unit tests and new workflows with integration tests. Acceptance tests are recommended when introducing new models. We use pytest to test our package. Run it with poetry run pytest to test your code changes locally.","title":"1.4. Testing"},{"location":"guides/contribute/#15-version-control","text":"We use commitizen to automatically bump the version number. If you use conventional commit messages , the the changelog.md is generated automatically.","title":"1.5. Version Control"},{"location":"guides/contribute/#16-documentation","text":"We use mkdocs to automatically generate documentation. We define documentation in separate sections: /guides: where we include information on how to use the repository, either as maintainer or as user. /reference: where the technical documentation is linked. When creating a new module a new markdown file should be created. To refer to a module, it can be done as follows: ### core ::: src.core.core This will generate documentation based on the docstrings of each class and method in src.core.core.py changelog.md: file automatically generated and updated with the commits to master (see Version Control )","title":"1.6. Documentation"},{"location":"guides/contribute/#2-development","text":"In this section we describe how development is expected to be done in this repository.","title":"2. Development."},{"location":"guides/contribute/#21-branches","text":"For each issue or feature, a separate branch should be created from the main. To keep the branches organized a feature branch should be created with the feature/ prefix. When starting development on a branch, a pull request should be created for reviews and continous integration. During continuous integration, the checks will be run with python 3.8 on Windows, Ubuntu and MacOS. The checks consist of running the tests, checking the code formatting and running SonarCloud. We advise to use a draft pull request, to prevent the branch to be merged back before developement is finished. When the branch is ready for review, you can update the status of the pull request to \"ready for review\".","title":"2.1. Branches"},{"location":"guides/contribute/#22-reviews","text":"Reviews should be dona by a member of the development team on a pull-request prior to its merging.","title":"2.2. Reviews"},{"location":"guides/contribute/#23-merging","text":"Merging a branch can only happen when a pull request is accepted through review. When a pull request is accepted the changes should be merged back with the \"squash and merge\" option.","title":"2.3. Merging"},{"location":"guides/contribute/#24-coding-guidelines","text":"Classes and methods should make use of docstrings. If there are any additions or changes to the public API, the documentation should be updated. Files should be added to the appropriate folder to keep modules and objects within the correct scope. If there is code that needs to be tested, there should be tests written for it. Tests should be added \"mirroring\" the structure of src for a cohesive project layout.","title":"2.4. Coding guidelines"},{"location":"guides/run_simulation/","text":"How to run a simulation in NBSDynamics \u00b6 The current package offers the user the possibility to run a simulation with the built-in simulation types, or to create their own simulation with their custom attributes. 1. Simulation structure. \u00b6 A simulation is based on the SimulationProtocol . Thus its required attributes are as follows: Constants . Definition of constants to be used during the simulation. Coral . Required to represent a morphological model of a coral. Environment . Hydrodynamics . Defines the type of simulation that will be run. As per version v0.8.0 the following types are available: Reef0D Reef1D Transect Delft3D . Simulation through usage of a BMI runner: Delft3D - FlowFMModel . Currently under work. Delft3D - DimrModel . Currently under work. Output . Required to define what output should be stored, how, where and when. 2. 'Vanilla' Simulation. \u00b6 The user has the possibility to create its custom simulation by calling to the most simple simulation class Simulation . This class allows the user to combine their own set of Constants , Coral , Environment , Hydrodynamics and Output and then call the predefined initiate , run or finalise methods. Keep in mind this way of running a simulation implies the user will have to manually configure the Simulation attributes. 3. Built-in Simulations. \u00b6 A built-in simulation allows the user to only worry about given the required input parameters and then letting the object pre-configure all the data as required for a regular run. Available \u00b6 As per version NBSDynamics v.0.8.0 the following simulations are fully validated: Coral Transect Simulation \u00b6 A simulation using the CoralTransectSimulation object. Which will build the simulation around a Transect hydrodynamic model. We provide here an example (currently used for testing) of its usage with a Pydantic approach: # 1. Define attributes. test_dir = Path ( \"transect_run\" ) input_dir = test_dir / \"input\" output_dir = test_dir / \"output\" # 2. Prepare model. # Define the basic Simulation object, indicating already here the type of hydrodynamics run_trans = CoralTransectSimulation ( working_dir = test_dir , constants = input_dir / \"coral_input.txt\" , environment = dict ( light = input_dir / \"TS_PAR.txt\" , temperature = input_dir / \"TS_SST.txt\" , storm = input_dir / \"TS_stormcat2.txt\" , dates = ( \"2000-01-01\" , \"2100-01-01\" ), ), hydrodynamics = dict ( definition_file = input_dir / \"TS_waves.txt\" , config_file = input_dir / \"config.csv\" , ), output = dict ( output_dir = test_dir / \"output\" , map_output = dict ( output_params = dict ( fme = False )), his_output = dict ( output_params = dict ( fme = False )), ), coral = dict ( dc = 0.125 , hc = 0.125 , bc = 0.1 , tc = 0.1 , ac = 0.2 , Csp = 0.6 , ), ) # 3. Run simulation run_trans . initiate () run_trans . run () run_trans . finalise () Work in progress \u00b6 The following simulations are defined, however their status is not yet final and can therefore not be guaranteed to work. Coral FlowFm Simulation \u00b6 Open issue: #68 Fix Delft3D - FlowFMModel run. A simulation using the CoralFlowFmSimulation object. Which will build the simulation around a FlowFMModel hydrodynamic model. Coral Dimr Simulation \u00b6 Open issue: #69 Fix / Implement Delft3D - DIMR run. A simulation using the CoralDimrSimulation object. Which will build the simulation around a DimrModel hydrodynamic model.","title":"How to run a simulation in NBSDynamics"},{"location":"guides/run_simulation/#how-to-run-a-simulation-in-nbsdynamics","text":"The current package offers the user the possibility to run a simulation with the built-in simulation types, or to create their own simulation with their custom attributes.","title":"How to run a simulation in NBSDynamics"},{"location":"guides/run_simulation/#1-simulation-structure","text":"A simulation is based on the SimulationProtocol . Thus its required attributes are as follows: Constants . Definition of constants to be used during the simulation. Coral . Required to represent a morphological model of a coral. Environment . Hydrodynamics . Defines the type of simulation that will be run. As per version v0.8.0 the following types are available: Reef0D Reef1D Transect Delft3D . Simulation through usage of a BMI runner: Delft3D - FlowFMModel . Currently under work. Delft3D - DimrModel . Currently under work. Output . Required to define what output should be stored, how, where and when.","title":"1. Simulation structure."},{"location":"guides/run_simulation/#2-vanilla-simulation","text":"The user has the possibility to create its custom simulation by calling to the most simple simulation class Simulation . This class allows the user to combine their own set of Constants , Coral , Environment , Hydrodynamics and Output and then call the predefined initiate , run or finalise methods. Keep in mind this way of running a simulation implies the user will have to manually configure the Simulation attributes.","title":"2. 'Vanilla' Simulation."},{"location":"guides/run_simulation/#3-built-in-simulations","text":"A built-in simulation allows the user to only worry about given the required input parameters and then letting the object pre-configure all the data as required for a regular run.","title":"3. Built-in Simulations."},{"location":"guides/run_simulation/#available","text":"As per version NBSDynamics v.0.8.0 the following simulations are fully validated:","title":"Available"},{"location":"guides/run_simulation/#coral-transect-simulation","text":"A simulation using the CoralTransectSimulation object. Which will build the simulation around a Transect hydrodynamic model. We provide here an example (currently used for testing) of its usage with a Pydantic approach: # 1. Define attributes. test_dir = Path ( \"transect_run\" ) input_dir = test_dir / \"input\" output_dir = test_dir / \"output\" # 2. Prepare model. # Define the basic Simulation object, indicating already here the type of hydrodynamics run_trans = CoralTransectSimulation ( working_dir = test_dir , constants = input_dir / \"coral_input.txt\" , environment = dict ( light = input_dir / \"TS_PAR.txt\" , temperature = input_dir / \"TS_SST.txt\" , storm = input_dir / \"TS_stormcat2.txt\" , dates = ( \"2000-01-01\" , \"2100-01-01\" ), ), hydrodynamics = dict ( definition_file = input_dir / \"TS_waves.txt\" , config_file = input_dir / \"config.csv\" , ), output = dict ( output_dir = test_dir / \"output\" , map_output = dict ( output_params = dict ( fme = False )), his_output = dict ( output_params = dict ( fme = False )), ), coral = dict ( dc = 0.125 , hc = 0.125 , bc = 0.1 , tc = 0.1 , ac = 0.2 , Csp = 0.6 , ), ) # 3. Run simulation run_trans . initiate () run_trans . run () run_trans . finalise ()","title":"Coral Transect Simulation"},{"location":"guides/run_simulation/#work-in-progress","text":"The following simulations are defined, however their status is not yet final and can therefore not be guaranteed to work.","title":"Work in progress"},{"location":"guides/run_simulation/#coral-flowfm-simulation","text":"Open issue: #68 Fix Delft3D - FlowFMModel run. A simulation using the CoralFlowFmSimulation object. Which will build the simulation around a FlowFMModel hydrodynamic model.","title":"Coral FlowFm Simulation"},{"location":"guides/run_simulation/#coral-dimr-simulation","text":"Open issue: #69 Fix / Implement Delft3D - DIMR run. A simulation using the CoralDimrSimulation object. Which will build the simulation around a DimrModel hydrodynamic model.","title":"Coral Dimr Simulation"},{"location":"reference/core/","text":"Core classes for the NBSDynamics package. \u00b6 Base Model (pydantic) \u00b6 BaseModel pydantic-model \u00b6 Custom definition of pydantic base model. This class helps 'NBSDynamics' model create and validation. ExtraModel pydantic-model \u00b6 Custom definition of pydantic base model. This class helps 'NBSDynamics' model create and validation. Config \u00b6 Allows this model to have extra fields defined during runtime.","title":"Core"},{"location":"reference/core/#core-classes-for-the-nbsdynamics-package","text":"","title":"Core classes for the NBSDynamics package."},{"location":"reference/core/#base-model-pydantic","text":"","title":"Base Model (pydantic)"},{"location":"reference/core/#src.core.base_model.BaseModel","text":"Custom definition of pydantic base model. This class helps 'NBSDynamics' model create and validation.","title":"BaseModel"},{"location":"reference/core/#src.core.base_model.ExtraModel","text":"Custom definition of pydantic base model. This class helps 'NBSDynamics' model create and validation.","title":"ExtraModel"},{"location":"reference/core/#src.core.base_model.ExtraModel.Config","text":"Allows this model to have extra fields defined during runtime.","title":"Config"},{"location":"reference/bio_process/processes/","text":"Biophysical processes \u00b6 Calcification \u00b6 Calcification \u00b6 Calcification rate. __init__ ( self , constants : Constants = Constants ( input_file = None , fme = False , tme = False , pfd = False , warn_proc = True , Kd0 = 0.1 , theta_max = 1.5707963267948966 , Cs = 0.17 , Cm = 1.7 , Cf = 0.01 , nu = 1e-06 , alpha = 1e-07 , psi = 2 , wcAngle = 0.0 , rd = 500 , numericTheta = 0.5 , err = 0.001 , maxiter_k = 100000 , maxiter_aw = 100000 , K0 = 80.0 , ap = 0.4 , k = 0.6089 , iota = 0.6 , ik_max = 372.32 , pm_max = 1.0 , betaI = 0.34 , betaP = 0.09 , Icomp = 0.01 , Ea = 60000.0 , R = 8.31446261815324 , k_var = 2.45 , nn = 60 , pfd_min = 0.68886964 , ucr = 0.5173 , r_growth = 0.002 , r_recovery = 0.2 , r_mortality = 0.04 , r_bleaching = 8.0 , gC = 0.5 , omegaA0 = 5.0 , omega0 = 0.14587415 , kappaA = 0.66236107 , rf = 1.0 , rp = 1.0 , prop_form = 0.1 , prop_plate = 0.5 , prop_plate_flow = 0.1 , prop_space = 0.35355339059327373 , prop_space_light = 0.1 , prop_space_flow = 0.1 , u0 = 0.2 , rho_c = 1600.0 , sigma_t = 200000.0 , Cd = 1.0 , rho_w = 1025.0 , no_larvae = 1000000.0 , prob_settle = 0.0001 , d_larvae = 0.001 )) special \u00b6 Calcification rate. Source code in src/core/bio_process/calcification.py def __init__ ( self , constants : Constants = Constants ()): \"\"\"Calcification rate.\"\"\" self . ad = 1 self . constants = constants calcification_rate ( self , coral , omega ) \u00b6 Calcification rate. :param coral: coral animal :param omega: aragonite saturation state :type coral: Coral :type omega: float, list, tuple, numpy.ndarray Source code in src/core/bio_process/calcification.py def calcification_rate ( self , coral , omega ): \"\"\"Calcification rate. :param coral: coral animal :param omega: aragonite saturation state :type coral: Coral :type omega: float, list, tuple, numpy.ndarray \"\"\" def aragonite_dependency ( calcification_object ): \"\"\"Aragonite dependency.\"\"\" calcification_object . ad = ( omega - self . constants . omega0 ) / ( self . constants . kappaA + omega - self . constants . omega0 ) calcification_object . ad = RESHAPE () . variable2matrix ( calcification_object . ad , \"time\" ) aragonite_dependency ( self ) coral . calc = ( self . constants . gC * coral . Csp * coral . pop_states [:, :, 0 ] * self . ad * coral . photo_rate ) Dislodgement \u00b6 Dislodgement pydantic-model \u00b6 Dislodgement due to storm conditions. colony_shape_factor ( self , coral : Coral ) \u00b6 Colony Shape Factor. Parameters: Name Type Description Default coral Coral Coral animal. required Source code in src/core/bio_process/dislodgment.py def colony_shape_factor ( self , coral : Coral ): \"\"\" Colony Shape Factor. Args: coral (Coral): Coral animal. \"\"\" self . csf = CoralOnly () . in_space ( coral = coral , function = self . csf_formula , args = ( coral . dc , coral . hc , coral . bc , coral . tc ), ) csf_formula ( dc , hc , bc , tc ) staticmethod \u00b6 Determine the Colony Shape Factor. :param dc: diameter coral plate [m] :param hc: coral height [m] :param bc: diameter coral base [m] :param tc: thickness coral plate [m] :type dc: float, numpy.ndarray :type hc: float, numpy.ndarray :type bc: float, numpy.ndarray :type tc: float, numpy.ndarray :return: colony shape factor :rtype: float, numpy.ndarray Source code in src/core/bio_process/dislodgment.py @staticmethod def csf_formula ( dc , hc , bc , tc ): \"\"\"Determine the Colony Shape Factor. :param dc: diameter coral plate [m] :param hc: coral height [m] :param bc: diameter coral base [m] :param tc: thickness coral plate [m] :type dc: float, numpy.ndarray :type hc: float, numpy.ndarray :type bc: float, numpy.ndarray :type tc: float, numpy.ndarray :return: colony shape factor :rtype: float, numpy.ndarray \"\"\" # arms of moment arm_top = hc - 0.5 * tc arm_bottom = 0.5 * ( hc - tc ) # area of moment area_top = dc * tc area_bottom = bc * ( hc - tc ) # integral integral = arm_top * area_top + arm_bottom * area_bottom # colony shape factor return 16.0 / ( np . pi * bc ** 3 ) * integral dislodgement_criterion ( self , coral : Coral ) \u00b6 Dislodgement criterion. Returns boolean (array). :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/dislodgment.py def dislodgement_criterion ( self , coral : Coral ): \"\"\"Dislodgement criterion. Returns boolean (array). :param coral: coral animal :type coral: Coral \"\"\" self . dislodgement_mechanical_threshold ( coral ) self . colony_shape_factor ( coral ) return self . dmt <= self . csf dislodgement_mechanical_threshold ( self , coral : Coral ) \u00b6 Dislodgement Mechanical Threshold. Parameters: Name Type Description Default coral Coral Coral animal. required Source code in src/core/bio_process/dislodgment.py def dislodgement_mechanical_threshold ( self , coral : Coral ): \"\"\" Dislodgement Mechanical Threshold. Args: coral (Coral): Coral animal. \"\"\" # # check input if not hasattr ( coral . um , \"__iter__\" ): coral . um = np . array ([ coral . um ]) if isinstance ( coral . um , ( list , tuple )): coral . um = np . array ( coral . um ) # # calculations self . dmt = 1e20 * np . ones ( coral . um . shape ) self . dmt [ coral . um > 0 ] = self . dmt_formula ( self . constants , coral . um [ coral . um > 0 ] ) dmt_formula ( constants , flow_velocity ) staticmethod \u00b6 Determine the Dislodgement Mechanical Threshold. :param flow_velocity: depth-averaged flow velocity :type flow_velocity: float, numpy.ndarray Source code in src/core/bio_process/dislodgment.py @staticmethod def dmt_formula ( constants , flow_velocity ): \"\"\"Determine the Dislodgement Mechanical Threshold. :param flow_velocity: depth-averaged flow velocity :type flow_velocity: float, numpy.ndarray \"\"\" return constants . sigma_t / ( constants . rho_w * constants . Cd * flow_velocity ** 2 ) partial_dislodgement ( self , coral , survival_coefficient = 1.0 ) \u00b6 Percentage surviving storm event. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional Source code in src/core/bio_process/dislodgment.py def partial_dislodgement ( self , coral , survival_coefficient = 1.0 ): \"\"\"Percentage surviving storm event. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional \"\"\" # TODO: Rewrite such that the distinction between an array or a float is well build in. try : self . survival = np . ones ( coral . dc . shape ) except TypeError : if Dislodgement . dislodgement_criterion ( self , coral ): self . survival = survival_coefficient * self . dmt / self . csf else : self . survival = 1.0 else : dislodged = Dislodgement . dislodgement_criterion ( self , coral ) self . survival [ dislodged ] = survival_coefficient * ( self . dmt [ dislodged ] / self . csf [ dislodged ] ) update ( self , coral : Coral , survival_coefficient = 1 ) \u00b6 Update morphology due to storm damage. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional Source code in src/core/bio_process/dislodgment.py def update ( self , coral : Coral , survival_coefficient = 1 ): \"\"\"Update morphology due to storm damage. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional \"\"\" # # partial dislodgement Dislodgement . partial_dislodgement ( self , coral , survival_coefficient ) # # update # ulation states for s in range ( 4 ): coral . p0 [:, s ] *= self . survival # morphology coral . update_coral_volume ( coral . volume * self . survival ) Flow \u00b6 Flow \u00b6 Flow micro-environment. __init__ ( self , u_current , u_wave , h , peak_period , constants : Constants = Constants ( input_file = None , fme = False , tme = False , pfd = False , warn_proc = True , Kd0 = 0.1 , theta_max = 1.5707963267948966 , Cs = 0.17 , Cm = 1.7 , Cf = 0.01 , nu = 1e-06 , alpha = 1e-07 , psi = 2 , wcAngle = 0.0 , rd = 500 , numericTheta = 0.5 , err = 0.001 , maxiter_k = 100000 , maxiter_aw = 100000 , K0 = 80.0 , ap = 0.4 , k = 0.6089 , iota = 0.6 , ik_max = 372.32 , pm_max = 1.0 , betaI = 0.34 , betaP = 0.09 , Icomp = 0.01 , Ea = 60000.0 , R = 8.31446261815324 , k_var = 2.45 , nn = 60 , pfd_min = 0.68886964 , ucr = 0.5173 , r_growth = 0.002 , r_recovery = 0.2 , r_mortality = 0.04 , r_bleaching = 8.0 , gC = 0.5 , omegaA0 = 5.0 , omega0 = 0.14587415 , kappaA = 0.66236107 , rf = 1.0 , rp = 1.0 , prop_form = 0.1 , prop_plate = 0.5 , prop_plate_flow = 0.1 , prop_space = 0.35355339059327373 , prop_space_light = 0.1 , prop_space_flow = 0.1 , u0 = 0.2 , rho_c = 1600.0 , sigma_t = 200000.0 , Cd = 1.0 , rho_w = 1025.0 , no_larvae = 1000000.0 , prob_settle = 0.0001 , d_larvae = 0.001 )) special \u00b6 :param u_current: current flow velocity [m s-1] :param u_wave: wave flow velocity [m s-1] :param h: water depth [m] :param peak_period: peak wave period [s] :type u_current: float, list, tuple, numpy.ndarray :type u_wave: float, list, tuple, numpy.ndarray :type h: float, list, tuple, numpy.ndarray :type peak_period: float, list, tuple, numpy.ndarray Source code in src/core/bio_process/flow.py def __init__ ( self , u_current , u_wave , h , peak_period , constants : Constants = Constants (), ): \"\"\" :param u_current: current flow velocity [m s-1] :param u_wave: wave flow velocity [m s-1] :param h: water depth [m] :param peak_period: peak wave period [s] :type u_current: float, list, tuple, numpy.ndarray :type u_wave: float, list, tuple, numpy.ndarray :type h: float, list, tuple, numpy.ndarray :type peak_period: float, list, tuple, numpy.ndarray \"\"\" _reshape = RESHAPE () self . uc = _reshape . variable2array ( u_current ) self . uw = _reshape . variable2array ( u_wave ) self . h = _reshape . variable2matrix ( h , \"space\" ) self . Tp = _reshape . variable2array ( peak_period ) self . active = False if u_current is None and u_wave is None else True self . constants = constants thermal_boundary_layer ( self , coral ) \u00b6 Thermal boundary layer. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/flow.py def thermal_boundary_layer ( self , coral ): \"\"\"Thermal boundary layer. :param coral: coral animal :type coral: Coral \"\"\" if self . active and self . constants . tme : delta = self . velocity_boundary_layer ( self . constants , coral ) coral . delta_t = delta * ( ( self . constants . alpha / self . constants . nu ) ** ( 1 / 3 ) ) uc_matrix property readonly \u00b6 Reshaped current flow velocity. uw_matrix property readonly \u00b6 Reshaped wave flow velocity. velocities ( self , coral , in_canopy = True ) \u00b6 In-canopy flow velocities, and depth-averaged flow velocities. :param coral: coral animal :param in_canopy: determine in-canopy flow (or depth-averaged), defaults to True :type coral: Coral :type in_canopy: bool, optional Source code in src/core/bio_process/flow.py def velocities ( self , coral , in_canopy = True ): \"\"\"In-canopy flow velocities, and depth-averaged flow velocities. :param coral: coral animal :param in_canopy: determine in-canopy flow (or depth-averaged), defaults to True :type coral: Coral :type in_canopy: bool, optional \"\"\" if self . active : alpha_w = np . ones ( self . uw . shape ) alpha_c = np . ones ( self . uc . shape ) if in_canopy : idx = coral . volume > 0 for i in idx : alpha_w [ i ] = self . wave_attenuation ( self . constants , coral . dc_rep [ i ], coral . hc [ i ], coral . ac [ i ], self . uw [ i ], self . Tp [ i ], self . h [ i ], wac_type = \"wave\" , ) alpha_c [ i ] = self . wave_attenuation ( self . constants , coral . dc_rep [ i ], coral . hc [ i ], coral . ac [ i ], self . uc [ i ], 1e3 , self . h [ i ], wac_type = \"current\" , ) coral . ucm = self . wave_current ( alpha_w , alpha_c ) coral . um = self . wave_current () else : coral . ucm = 9999 * np . ones ( RESHAPE () . space ) velocity_boundary_layer ( constants , coral ) staticmethod \u00b6 Velocity boundary layer. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/flow.py @staticmethod def velocity_boundary_layer ( constants , coral ): \"\"\"Velocity boundary layer. :param coral: coral animal :type coral: Coral \"\"\" def boundary_layer ( rd , nu , cf , ucm ): \"\"\"Thickness velocity boundary layer.\"\"\" return ( rd * nu ) / ( np . sqrt ( cf ) * ucm ) return CoralOnly () . in_space ( coral = coral , function = boundary_layer , args = ( constants . rd , constants . nu , constants . Cf , coral . ucm ), ) wave_attenuation ( constants , diameter , height , distance , velocity , period , depth , wac_type ) staticmethod \u00b6 Wave-attenuation coefficient. :param diameter: representative coral diameter [m] :param height: coral height [m] :param distance: axial distance [m] :param velocity: flow velocity [m s-1] :param period: wave period [s] :param depth: water depth [m] :param wac_type: type of wave-attenuation coefficient [-] :type diameter: float :type height: float :type distance: float :type velocity: float :type depth: float :type depth: float :type wac_type: str Source code in src/core/bio_process/flow.py @staticmethod def wave_attenuation ( constants , diameter , height , distance , velocity , period , depth , wac_type ): \"\"\"Wave-attenuation coefficient. :param diameter: representative coral diameter [m] :param height: coral height [m] :param distance: axial distance [m] :param velocity: flow velocity [m s-1] :param period: wave period [s] :param depth: water depth [m] :param wac_type: type of wave-attenuation coefficient [-] :type diameter: float :type height: float :type distance: float :type velocity: float :type depth: float :type depth: float :type wac_type: str \"\"\" # TODO: Split this method in one solely focusing on the wave attenuation coefficient; # and one implementing this method to dynamically determine the drag coefficient. # Thus, reformat this method as in coral_model_v0. # # function and derivative definitions def function ( beta ): \"\"\"Complex-valued function to be solved, where beta is the complex representation of the wave-attenuation coefficient. \"\"\" # components shear = ( ( 8.0 * above_motion ) / ( 3.0 * np . pi * shear_length ) * ( abs ( 1.0 - beta ) * ( 1.0 - beta )) ) drag = ( ( 8.0 * above_motion ) / ( 3.0 * np . pi * drag_length ) * ( abs ( beta ) * beta ) ) inertia = ( 1 j * beta * (( constants . Cm * lambda_planar ) / ( 1.0 - lambda_planar )) ) # combined f = 1 j * ( beta - 1.0 ) - shear + drag + inertia # output return f def derivative ( beta ): \"\"\"Complex-valued derivative to be used to solve the complex-valued function, where beta is the complex representation of the wave-attenuation coefficient. \"\"\" # components shear = ( ( 1.0 - beta ) ** 2 / abs ( 1.0 - beta ) - abs ( 1.0 - beta ) ) / shear_length drag = ( beta ** 2 / abs ( beta ) + beta ) / drag_length inertia = 1 j * ( constants . Cm * lambda_planar ) / ( 1.0 - lambda_planar ) # combined df = 1 j + ( 8.0 * above_motion ) / ( 3.0 * np . pi ) * ( - shear + drag ) + inertia # output return df # # Input check def wave_wac (): return abs ( newton ( function , x0 = complex ( 0.1 , 0.1 ), fprime = derivative , maxiter = constants . maxiter_aw , ) ) def current_wac (): x = drag_length / shear_length * ( height / ( depth - height ) + 1 ) return ( x - np . sqrt ( x )) / ( x - 1 ) wac_type_funcs = dict ( current = current_wac , wave = wave_wac ) wac_function = wac_type_funcs . get ( wac_type , None ) if wac_function is None : raise ValueError ( f \"WAC-type ( { wac_type } ) not in { wac_type_funcs . keys () } .\" ) # # parameter definitions # geometric parameters planar_area = 0.25 * np . pi * diameter ** 2 frontal_area = diameter * height total_area = 0.5 * distance ** 2 lambda_planar = planar_area / total_area lambda_frontal = frontal_area / total_area shear_length = height / ( constants . Cs ** 2 ) # # calculations wac = 1.0 if depth <= height : return wac # If depth > height # initial iteration values above_flow = velocity drag_coefficient = 1.0 # iteration for k in range ( int ( constants . maxiter_k )): drag_length = ( 2 * height * ( 1 - lambda_planar )) / ( drag_coefficient * lambda_frontal ) above_motion = ( above_flow * period ) / ( 2 * np . pi ) wac = wac_function () porous_flow = wac * above_flow constricted_flow = ( ( 1 - lambda_planar ) / ( 1 - np . sqrt (( 4 * lambda_planar ) / ( constants . psi * np . pi ))) * porous_flow ) reynolds = ( constricted_flow * diameter ) / constants . nu new_drag = 1 + 10 * reynolds ** ( - 2.0 / 3 ) if abs (( new_drag - drag_coefficient ) / new_drag ) <= constants . err : break else : drag_coefficient = float ( new_drag ) above_flow = abs ( ( 1 - constants . numericTheta ) * above_flow + constants . numericTheta * ( depth * velocity - height * porous_flow ) / ( depth - height ) ) if k == constants . maxiter_k : print ( f \"WARNING: maximum number of iterations reached \" f \"( { constants . maxiter_k } )\" ) return wac wave_current ( self , alpha_w = 1 , alpha_c = 1 ) \u00b6 Wave-current interaction. :param alpha_w: wave-attenuation coefficient, defaults to 1 :param alpha_c: current-attenuation coefficient, defaults to 1 :type alpha_w: float, list, tuple, numpy.ndarray, optional :type alpha_c: float, list, tuple, numpy.ndarray, optional :return: wave-current interaction :rtype: float, numpy.ndarray Source code in src/core/bio_process/flow.py def wave_current ( self , alpha_w = 1 , alpha_c = 1 ): \"\"\"Wave-current interaction. :param alpha_w: wave-attenuation coefficient, defaults to 1 :param alpha_c: current-attenuation coefficient, defaults to 1 :type alpha_w: float, list, tuple, numpy.ndarray, optional :type alpha_c: float, list, tuple, numpy.ndarray, optional :return: wave-current interaction :rtype: float, numpy.ndarray \"\"\" return np . sqrt ( ( alpha_w * self . uw ) ** 2 + ( alpha_c * self . uc ) ** 2 + 2 * alpha_w * self . uw * alpha_c * self . uc * np . cos ( self . constants . wcAngle ) ) Light \u00b6 Light \u00b6 Light micro-environment. __init__ ( self , light_in : Union [ float , list , tuple , numpy . ndarray ], lac : Union [ float , list , tuple , numpy . ndarray ], depth : Union [ float , list , tuple , numpy . ndarray ], constants : Constants = Constants ( input_file = None , fme = False , tme = False , pfd = False , warn_proc = True , Kd0 = 0.1 , theta_max = 1.5707963267948966 , Cs = 0.17 , Cm = 1.7 , Cf = 0.01 , nu = 1e-06 , alpha = 1e-07 , psi = 2 , wcAngle = 0.0 , rd = 500 , numericTheta = 0.5 , err = 0.001 , maxiter_k = 100000 , maxiter_aw = 100000 , K0 = 80.0 , ap = 0.4 , k = 0.6089 , iota = 0.6 , ik_max = 372.32 , pm_max = 1.0 , betaI = 0.34 , betaP = 0.09 , Icomp = 0.01 , Ea = 60000.0 , R = 8.31446261815324 , k_var = 2.45 , nn = 60 , pfd_min = 0.68886964 , ucr = 0.5173 , r_growth = 0.002 , r_recovery = 0.2 , r_mortality = 0.04 , r_bleaching = 8.0 , gC = 0.5 , omegaA0 = 5.0 , omega0 = 0.14587415 , kappaA = 0.66236107 , rf = 1.0 , rp = 1.0 , prop_form = 0.1 , prop_plate = 0.5 , prop_plate_flow = 0.1 , prop_space = 0.35355339059327373 , prop_space_light = 0.1 , prop_space_flow = 0.1 , u0 = 0.2 , rho_c = 1600.0 , sigma_t = 200000.0 , Cd = 1.0 , rho_w = 1025.0 , no_larvae = 1000000.0 , prob_settle = 0.0001 , d_larvae = 0.001 )) special \u00b6 Light micro-environment. Parameters: Name Type Description Default light_in Union[float, list, tuple, numpy.ndarray] Incoming light-intensity at the water-air interface [u mol photons m-2 s-1] required lac Union[float, list, tuple, numpy.ndarray] light-attenuation coefficient [m-1] required depth Union[float, list, tuple, numpy.ndarray] water depth [m] required constants Constants List of constants to be used for this object. Constants(input_file=None, fme=False, tme=False, pfd=False, warn_proc=True, Kd0=0.1, theta_max=1.5707963267948966, Cs=0.17, Cm=1.7, Cf=0.01, nu=1e-06, alpha=1e-07, psi=2, wcAngle=0.0, rd=500, numericTheta=0.5, err=0.001, maxiter_k=100000, maxiter_aw=100000, K0=80.0, ap=0.4, k=0.6089, iota=0.6, ik_max=372.32, pm_max=1.0, betaI=0.34, betaP=0.09, Icomp=0.01, Ea=60000.0, R=8.31446261815324, k_var=2.45, nn=60, pfd_min=0.68886964, ucr=0.5173, r_growth=0.002, r_recovery=0.2, r_mortality=0.04, r_bleaching=8.0, gC=0.5, omegaA0=5.0, omega0=0.14587415, kappaA=0.66236107, rf=1.0, rp=1.0, prop_form=0.1, prop_plate=0.5, prop_plate_flow=0.1, prop_space=0.35355339059327373, prop_space_light=0.1, prop_space_flow=0.1, u0=0.2, rho_c=1600.0, sigma_t=200000.0, Cd=1.0, rho_w=1025.0, no_larvae=1000000.0, prob_settle=0.0001, d_larvae=0.001) Source code in src/core/bio_process/light.py def __init__ ( self , light_in : LightVariable , lac : LightVariable , depth : LightVariable , constants : Constants = Constants (), ): \"\"\" Light micro-environment. Args: light_in (LightVariable): Incoming light-intensity at the water-air interface [u mol photons m-2 s-1] lac (LightVariable): light-attenuation coefficient [m-1] depth (LightVariable): water depth [m] constants (Constants): List of constants to be used for this object. \"\"\" _reshape = RESHAPE () self . I0 = _reshape . variable2matrix ( light_in , \"time\" ) self . Kd = _reshape . variable2matrix ( lac , \"time\" ) self . h = _reshape . variable2matrix ( depth , \"space\" ) self . constants = constants base_light ( self , coral ) \u00b6 Section of coral base receiving light. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/light.py def base_light ( self , coral ): \"\"\"Section of coral base receiving light. :param coral: coral animal :type coral: Coral \"\"\" # # spreading of light theta = self . light_spreading ( coral ) # # coral base section base_section = ( coral . hc_matrix - coral . tc_matrix - (( coral . dc_matrix - coral . bc_matrix ) / ( 2.0 * np . tan ( 0.5 * theta ))) ) # no negative lengths base_section [ base_section < 0 ] = 0 return base_section biomass ( self , coral ) \u00b6 Coral biomass; as surface. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/light.py def biomass ( self , coral ): \"\"\"Coral biomass; as surface. :param coral: coral animal :type coral: Coral \"\"\" base_section = self . base_light ( coral ) coral . light_bc = np . pi * ( 0.25 * coral . dc_matrix ** 2 + coral . dc_matrix * coral . tc_matrix + coral . bc_matrix * base_section ) light_spreading ( self , coral ) \u00b6 Spreading of light as function of depth. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/light.py def light_spreading ( self , coral ): \"\"\"Spreading of light as function of depth. :param coral: coral animal :type coral: Coral \"\"\" return self . constants . theta_max * np . exp ( - self . Kd * ( self . h - coral . hc_matrix + coral . tc_matrix ) ) rep_light ( self , coral ) \u00b6 Representative light-intensity. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/light.py def rep_light ( self , coral ): \"\"\"Representative light-intensity. :param coral: coral animal :type coral: Coral \"\"\" base_section = self . base_light ( coral ) # # light catchment per coral section # top of plate top = ( 0.25 * np . pi * coral . dc_matrix ** 2 * self . I0 * np . exp ( - self . Kd * ( self . h - coral . hc_matrix )) ) # side of plate side = ( ( np . pi * coral . dc_matrix * self . I0 ) / self . Kd * ( np . exp ( - self . Kd * ( self . h - coral . hc_matrix )) - np . exp ( - self . Kd * ( self . h - coral . hc_matrix + coral . tc_matrix )) ) * self . side_correction ( coral ) ) # side of base base = ( ( np . pi * coral . bc_matrix * self . I0 ) / self . Kd * ( np . exp ( - self . Kd * ( self . h - base_section )) - np . exp ( - self . Kd * self . h )) * self . side_correction ( coral ) ) # total total = top + side + base # # biomass-averaged self . biomass ( coral ) def averaged_light ( total_light , biomass ): \"\"\"Averaged light-intensity.\"\"\" return total_light / biomass coral . light = CoralOnly () . in_spacetime ( coral = coral , function = averaged_light , args = ( total , coral . light_bc ), no_cover_value = self . I0 * np . exp ( - self . Kd * self . h ), ) side_correction ( self , coral ) \u00b6 Correction of the light-intensity on the sides of the coral object. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/light.py def side_correction ( self , coral ): \"\"\"Correction of the light-intensity on the sides of the coral object. :param coral: coral animal :type coral: Coral \"\"\" # # spreading of light theta = self . light_spreading ( coral ) # # correction factor return np . sin ( 0.5 * theta ) Morphology \u00b6 Morphology \u00b6 Morphological development. __init__ ( self , calc_sum , light_in , dt_year = 1 , constants : Constants = Constants ( input_file = None , fme = False , tme = False , pfd = False , warn_proc = True , Kd0 = 0.1 , theta_max = 1.5707963267948966 , Cs = 0.17 , Cm = 1.7 , Cf = 0.01 , nu = 1e-06 , alpha = 1e-07 , psi = 2 , wcAngle = 0.0 , rd = 500 , numericTheta = 0.5 , err = 0.001 , maxiter_k = 100000 , maxiter_aw = 100000 , K0 = 80.0 , ap = 0.4 , k = 0.6089 , iota = 0.6 , ik_max = 372.32 , pm_max = 1.0 , betaI = 0.34 , betaP = 0.09 , Icomp = 0.01 , Ea = 60000.0 , R = 8.31446261815324 , k_var = 2.45 , nn = 60 , pfd_min = 0.68886964 , ucr = 0.5173 , r_growth = 0.002 , r_recovery = 0.2 , r_mortality = 0.04 , r_bleaching = 8.0 , gC = 0.5 , omegaA0 = 5.0 , omega0 = 0.14587415 , kappaA = 0.66236107 , rf = 1.0 , rp = 1.0 , prop_form = 0.1 , prop_plate = 0.5 , prop_plate_flow = 0.1 , prop_space = 0.35355339059327373 , prop_space_light = 0.1 , prop_space_flow = 0.1 , u0 = 0.2 , rho_c = 1600.0 , sigma_t = 200000.0 , Cd = 1.0 , rho_w = 1025.0 , no_larvae = 1000000.0 , prob_settle = 0.0001 , d_larvae = 0.001 )) special \u00b6 Morphological development. :param calc_sum: accumulation of calcification of :param dt_year: years [kg m-2 yr-1] :param light_in: incoming light-intensity at water-air interface [umol photons m-2 s-1] :param dt_year: update interval [yr], defaults to 1 :type calc_sum: float, int, list, tuple, numpy.ndarray :type light_in: float, int, list, tuple, numpy.ndarray :type dt_year: float, int Source code in src/core/bio_process/morphology.py def __init__ ( self , calc_sum , light_in , dt_year = 1 , constants : Constants = Constants () ): \"\"\" Morphological development. :param calc_sum: accumulation of calcification of :param dt_year: years [kg m-2 yr-1] :param light_in: incoming light-intensity at water-air interface [umol photons m-2 s-1] :param dt_year: update interval [yr], defaults to 1 :type calc_sum: float, int, list, tuple, numpy.ndarray :type light_in: float, int, list, tuple, numpy.ndarray :type dt_year: float, int \"\"\" _reshape = RESHAPE () try : _ = len ( calc_sum [ 0 ]) except TypeError : self . calc_sum = calc_sum else : self . calc_sum = _reshape . matrix2array ( calc_sum , \"space\" , \"sum\" ) self . dt_year = dt_year self . I0 = _reshape . variable2matrix ( light_in , \"time\" ) self . vol_increase = 0 self . constants = constants delta_volume ( self , coral ) \u00b6 :param coral: coral object :type coral: Coral Source code in src/core/bio_process/morphology.py def delta_volume ( self , coral ): \"\"\" :param coral: coral object :type coral: Coral \"\"\" self . vol_increase = ( 0.5 * coral . ac ** 2 * self . calc_sum * self . dt_year / self . constants . rho_c * coral . light_bc . mean ( axis = 1 ) ) return self . vol_increase ratio_update ( self , coral , ratio ) \u00b6 :param coral: coral object :param ratio: morphological ratio to update :type coral: Coral :type ratio: str Source code in src/core/bio_process/morphology.py def ratio_update ( self , coral , ratio ): \"\"\" :param coral: coral object :param ratio: morphological ratio to update :type coral: Coral :type ratio: str \"\"\" # partial differential equation - mass balance def mass_balance ( r_old , r_opt ): \"\"\"Mass balance.\"\"\" return ( coral . volume * r_old + self . vol_increase * r_opt ) / ( coral . volume + self . vol_increase ) # input check ratios = ( \"rf\" , \"rp\" , \"rs\" ) if ratio not in ratios : msg = f \" { ratio } not in { ratios } .\" raise ValueError ( msg ) # calculations self . delta_volume ( coral ) # optimal ratio setattr ( self , f \" { ratio } _optimal\" , coral ) # update morphological ratio if hasattr ( self , f \" { ratio } _optimal\" ) and hasattr ( coral , ratio ): return mass_balance ( getattr ( coral , ratio ), getattr ( self , f \" { ratio } _optimal\" ) ) rf_optimal property writable \u00b6 Optimal form ratio; height-to-plate diameter. :rtype: float, numpy.ndarray rp_optimal property writable \u00b6 Optimal plate ratio; base diameter-to-plate diameter. :rtype: float, numpy.ndarray rs_optimal property writable \u00b6 Optimal spacing ratio; plate diameter-to-axial distance. :rtype: float, numpy.ndarray update ( self , coral : Coral ) \u00b6 Update morphology. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/morphology.py def update ( self , coral : Coral ): \"\"\"Update morphology. :param coral: coral animal :type coral: Coral \"\"\" # # calculations # updated ratios ratios = { ratio : self . ratio_update ( coral , ratio ) for ratio in ( \"rf\" , \"rp\" , \"rs\" ) } # updated volume volume = coral . volume + self . vol_increase # update coral morphology coral . update_coral_morphology ( volume , ratios ) Photosynthesis \u00b6 Photosynthesis \u00b6 Photosynthesis. __init__ ( self , light_in , first_year , constants : Constants = Constants ( input_file = None , fme = False , tme = False , pfd = False , warn_proc = True , Kd0 = 0.1 , theta_max = 1.5707963267948966 , Cs = 0.17 , Cm = 1.7 , Cf = 0.01 , nu = 1e-06 , alpha = 1e-07 , psi = 2 , wcAngle = 0.0 , rd = 500 , numericTheta = 0.5 , err = 0.001 , maxiter_k = 100000 , maxiter_aw = 100000 , K0 = 80.0 , ap = 0.4 , k = 0.6089 , iota = 0.6 , ik_max = 372.32 , pm_max = 1.0 , betaI = 0.34 , betaP = 0.09 , Icomp = 0.01 , Ea = 60000.0 , R = 8.31446261815324 , k_var = 2.45 , nn = 60 , pfd_min = 0.68886964 , ucr = 0.5173 , r_growth = 0.002 , r_recovery = 0.2 , r_mortality = 0.04 , r_bleaching = 8.0 , gC = 0.5 , omegaA0 = 5.0 , omega0 = 0.14587415 , kappaA = 0.66236107 , rf = 1.0 , rp = 1.0 , prop_form = 0.1 , prop_plate = 0.5 , prop_plate_flow = 0.1 , prop_space = 0.35355339059327373 , prop_space_light = 0.1 , prop_space_flow = 0.1 , u0 = 0.2 , rho_c = 1600.0 , sigma_t = 200000.0 , Cd = 1.0 , rho_w = 1025.0 , no_larvae = 1000000.0 , prob_settle = 0.0001 , d_larvae = 0.001 )) special \u00b6 Photosynthetic efficiency based on photosynthetic dependencies. :param light_in: incoming light-intensity at the water-air interface [umol photons m-2 s-1] :param first_year: first year of the model simulation :type light_in: float, list, tuple, numpy.ndarray :type first_year: bool Source code in src/core/bio_process/photosynthesis.py def __init__ ( self , light_in , first_year , constants : Constants = Constants ()): \"\"\" Photosynthetic efficiency based on photosynthetic dependencies. :param light_in: incoming light-intensity at the water-air interface [umol photons m-2 s-1] :param first_year: first year of the model simulation :type light_in: float, list, tuple, numpy.ndarray :type first_year: bool \"\"\" self . I0 = RESHAPE () . variable2matrix ( light_in , \"time\" ) self . first_year = first_year self . pld = 1 self . ptd = 1 self . pfd = 1 self . constants = constants flow_dependency ( self , coral : Coral ) \u00b6 Photosynthetic flow dependency. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/photosynthesis.py def flow_dependency ( self , coral : Coral ): \"\"\"Photosynthetic flow dependency. :param coral: coral animal :type coral: Coral \"\"\" if self . constants . pfd : pfd = self . constants . pfd_min + ( 1 - self . constants . pfd_min ) * np . tanh ( 2 * coral . ucm / self . constants . ucr ) self . pfd = RESHAPE () . variable2matrix ( pfd , \"space\" ) else : self . pfd = 1 light_dependency ( self , coral , output ) \u00b6 Photosynthetic light dependency. :param coral: coral animal :param output: type of output :type coral: Coral :type output: str Source code in src/core/bio_process/photosynthesis.py def light_dependency ( self , coral , output ): \"\"\"Photosynthetic light dependency. :param coral: coral animal :param output: type of output :type coral: Coral :type output: str \"\"\" def photo_acclimation ( x_old , param ): \"\"\"Photo-acclimation.\"\"\" # input check params = ( \"Ik\" , \"Pmax\" ) if param not in params : message = f \" { param } not in { params } .\" raise ValueError ( message ) # parameter definitions x_max = self . constants . ik_max if param == \"Ik\" else self . constants . pm_max beta_x = self . constants . betaI if param == \"Ik\" else self . constants . betaP # calculations xs = x_max * ( coral . light / self . I0 ) ** beta_x if output == \"qss\" : return xs elif output == \"new\" : return xs + ( x_old - xs ) * np . exp ( - self . constants . iota ) # # parameter definitions if output == \"qss\" : ik = photo_acclimation ( None , \"Ik\" ) p_max = photo_acclimation ( None , \"Pmax\" ) else : msg = f \"Only the quasi-steady state solution is currently implemented; use key-word 'qss'.\" raise NotImplementedError ( msg ) # # calculations self . pld = p_max * ( np . tanh ( coral . light / ik ) - np . tanh ( self . constants . Icomp * self . I0 / ik ) ) photo_rate ( self , coral , environment , year ) \u00b6 Photosynthetic efficiency. :param coral: coral animal :param environment: environmental conditions :param year: year of simulation :type coral: Coral :type environment: Environment :type year: int Source code in src/core/bio_process/photosynthesis.py def photo_rate ( self , coral , environment , year ): \"\"\"Photosynthetic efficiency. :param coral: coral animal :param environment: environmental conditions :param year: year of simulation :type coral: Coral :type environment: Environment :type year: int \"\"\" # components self . light_dependency ( coral , \"qss\" ) self . thermal_dependency ( coral , environment , year ) self . flow_dependency ( coral ) # combined coral . photo_rate = self . pld * self . ptd * self . pfd thermal_dependency ( self , coral : Coral , env , year ) \u00b6 Photosynthetic thermal dependency. :param coral: coral animal :param env: environmental conditions :param year: year of simulation :type coral: Coral :type env: Environment :type year: int Source code in src/core/bio_process/photosynthesis.py def thermal_dependency ( self , coral : Coral , env , year ): \"\"\"Photosynthetic thermal dependency. :param coral: coral animal :param env: environmental conditions :param year: year of simulation :type coral: Coral :type env: Environment :type year: int \"\"\" _reshape = RESHAPE () def thermal_acc (): \"\"\"Thermal-acclimation.\"\"\" if self . constants . tme : if self . first_year : env . tmeMMMmin = ( pd . DataFrame ( data = pd . concat ( [ env . temp_mmm [ \"min\" ]] * _reshape . space , axis = 1 ) . values , columns = [ np . arange ( _reshape . space )], ) + coral . dTc ) env . tmeMMMmax = ( pd . DataFrame ( data = pd . concat ( [ env . temp_mmm [ \"max\" ]] * _reshape . space , axis = 1 ) . values , columns = [ np . arange ( _reshape . space )], ) + coral . dTc ) else : env . tmeMMMmin [ env . tmeMMM . index == year ] += coral . dTc env . tmeMMMmax [ env . tmeMMm . index == year ] += coral . dTc mmm_min = env . tmeMMMmin [ np . logical_and ( env . tmeMMM . index < year , env . tmeMMM . index >= year - int ( self . constants . nn / coral . Csp ), ) ] m_min = mmm_min . mean ( axis = 0 ) s_min = mmm_min . std ( axis = 0 ) mmm_max = env . tmeMMMmax [ np . logical_and ( env . tmeMMM . index < year , env . tmeMMM . index >= year - int ( self . constants . nn / coral . Csp ), ) ] m_max = mmm_max . mean ( axis = 0 ) s_max = mmm_max . std ( axis = 0 ) else : mmm = env . temp_mmm [ np . logical_and ( env . temp_mmm . index < year , env . temp_mmm . index >= year - int ( self . constants . nn / coral . Csp ), ) ] m_min , m_max = mmm . mean ( axis = 0 ) s_min , s_max = mmm . std ( axis = 0 ) coral . Tlo = m_min - self . constants . k_var * s_min coral . Thi = m_max + self . constants . k_var * s_max def adapted_temp (): \"\"\"Adapted temperature response.\"\"\" def spec (): \"\"\"Specialisation term.\"\"\" return 4e-4 * np . exp ( - 0.33 * ( delta_temp - 10 )) response = - ( coral . temp - coral . Tlo ) * ( ( coral . temp - coral . Tlo ) ** 2 - delta_temp ** 2 ) temp_cr = coral . Tlo - ( 1 / np . sqrt ( 3 )) * delta_temp try : if self . constants . tme : response [ coral . temp <= temp_cr ] = - ( ( 2 / ( 3 * np . sqrt ( 3 ))) * delta_temp [ coral . temp <= temp_cr ] ** 3 ) else : response [ coral . temp <= temp_cr ] = - ( ( 2 / ( 3 * np . sqrt ( 3 ))) * delta_temp ** 3 ) except TypeError : if coral . temp <= temp_cr : response = ( 2 / ( 3 * np . sqrt ( 3 ))) * delta_temp ** 3 return response * spec () def thermal_env (): \"\"\"Thermal envelope.\"\"\" return np . exp ( ( self . constants . Ea / self . constants . R ) * ( 1 / 300 - 1 / temp_opt ) ) # # parameter definitions thermal_acc () delta_temp = coral . Thi - coral . Tlo temp_opt = coral . Tlo + ( 1 / np . sqrt ( 3 )) * delta_temp # # calculations f1 = adapted_temp () f2 = thermal_env () self . ptd = f1 * f2 Population states \u00b6 PopulationStates \u00b6 Bleaching response following the population dynamics. __init__ ( self , constants : Constants = Constants ( input_file = None , fme = False , tme = False , pfd = False , warn_proc = True , Kd0 = 0.1 , theta_max = 1.5707963267948966 , Cs = 0.17 , Cm = 1.7 , Cf = 0.01 , nu = 1e-06 , alpha = 1e-07 , psi = 2 , wcAngle = 0.0 , rd = 500 , numericTheta = 0.5 , err = 0.001 , maxiter_k = 100000 , maxiter_aw = 100000 , K0 = 80.0 , ap = 0.4 , k = 0.6089 , iota = 0.6 , ik_max = 372.32 , pm_max = 1.0 , betaI = 0.34 , betaP = 0.09 , Icomp = 0.01 , Ea = 60000.0 , R = 8.31446261815324 , k_var = 2.45 , nn = 60 , pfd_min = 0.68886964 , ucr = 0.5173 , r_growth = 0.002 , r_recovery = 0.2 , r_mortality = 0.04 , r_bleaching = 8.0 , gC = 0.5 , omegaA0 = 5.0 , omega0 = 0.14587415 , kappaA = 0.66236107 , rf = 1.0 , rp = 1.0 , prop_form = 0.1 , prop_plate = 0.5 , prop_plate_flow = 0.1 , prop_space = 0.35355339059327373 , prop_space_light = 0.1 , prop_space_flow = 0.1 , u0 = 0.2 , rho_c = 1600.0 , sigma_t = 200000.0 , Cd = 1.0 , rho_w = 1025.0 , no_larvae = 1000000.0 , prob_settle = 0.0001 , d_larvae = 0.001 ), dt : Optional [ float ] = 1 ) special \u00b6 Population dynamics. :param dt: time step [yrs], defaults to one :type dt: float, optional Source code in src/core/bio_process/population_states.py def __init__ ( self , constants : Constants = Constants (), dt : Optional [ float ] = 1 ): \"\"\"Population dynamics. :param dt: time step [yrs], defaults to one :type dt: float, optional \"\"\" self . dt = dt self . constants = constants pop_states_t ( self , coral : Coral ) \u00b6 Population dynamics over time. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/population_states.py def pop_states_t ( self , coral : Coral ): \"\"\"Population dynamics over time. :param coral: coral animal :type coral: Coral \"\"\" _reshape = RESHAPE () coral . pop_states = np . zeros (( * _reshape . spacetime , 4 )) for n in range ( _reshape . time ): photosynthesis = np . zeros ( _reshape . space ) photosynthesis [ coral . cover > 0.0 ] = coral . photo_rate [ coral . cover > 0.0 , n ] # 21_09 have changed coral.cover>0 to .0. coral . pop_states [:, n , :] = self . pop_states_xy ( coral , photosynthesis ) coral . p0 [ coral . cover > 0.0 , :] = coral . pop_states [ coral . cover > 0.0 , n , :] pop_states_xy ( self , coral : Coral , ps ) \u00b6 Population dynamics over space. :param coral: coral animal :param ps: photosynthetic rate :type coral: Coral :type ps: numpy.ndarray Source code in src/core/bio_process/population_states.py def pop_states_xy ( self , coral : Coral , ps ): \"\"\"Population dynamics over space. :param coral: coral animal :param ps: photosynthetic rate :type coral: Coral :type ps: numpy.ndarray \"\"\" p = np . zeros (( RESHAPE () . space , 4 )) # # calculations # growing conditions # > bleached pop. # ps>0. here represents ps>tsh that is the value of the bleaching treshold light and 1. where 1.0 is a number, not column reference p [ ps > 0.0 , 3 ] = coral . p0 [ ps > 0.0 , 3 ] / ( 1 + self . dt * ( 8.0 * self . constants . r_recovery * ps [ ps > 0.0 ] / coral . Csp + self . constants . r_mortality * coral . Csp ) ) # > pale pop. p [ ps > 0.0 , 2 ] = ( coral . p0 [ ps > 0.0 , 2 ] + ( 8.0 * self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] / coral . Csp ) * p [ ps > 0.0 , 3 ] ) / ( 1.0 + self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp ) # > recovering pop. p [ ps > 0.0 , 1 ] = ( coral . p0 [ ps > 0.0 , 1 ] + self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp * p [ ps > 0.0 , 2 ] ) / ( 1.0 + 0.5 * self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp ) # > healthy pop. a = ( self . dt * self . constants . r_growth * ps [ ps > 0.0 ] * coral . Csp / coral . cover [ ps > 0.0 ] ) b = 1.0 - self . dt * self . constants . r_growth * ps [ ps > 0.0 ] * coral . Csp * ( 1.0 - p [ ps > 0.0 , 1 :] . sum ( axis = 1 ) / coral . cover [ ps > 0.0 ] ) c = - ( coral . p0 [ ps > 0.0 , 0 ] + 0.5 * self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp * p [ ps > 0.0 , 1 ] ) p [ ps > 0.0 , 0 ] = ( - b + np . sqrt ( b ** 2 - 4.0 * a * c )) / ( 2.0 * a ) # bleaching conditions # > healthy pop. p [ ps <= 0.0 , 0 ] = coral . p0 [ ps <= 0.0 , 0 ] / ( 1.0 - self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # > recovering pop. p [ ps <= 0.0 , 1 ] = coral . p0 [ ps <= 0.0 , 1 ] / ( 1.0 - self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # > pale pop. p [ ps <= 0.0 , 2 ] = ( coral . p0 [ ps <= 0.0 , 2 ] - self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp * ( p [ ps <= 0.0 , 0 ] + p [ ps <= 0.0 , 1 ]) ) / ( 1.0 - 0.5 * self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # > bleached pop. p [ ps <= 0.0 , 3 ] = ( coral . p0 [ ps <= 0.0 , 3 ] - 0.5 * self . dt * self . constants . r_bleaching * ps [ ps <= 0 ] * coral . Csp * p [ ps <= 0.0 , 2 ] ) / ( 1.0 - 0.25 * self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # # check on carrying capacity if any ( p . sum ( axis = 1 ) > 1.0001 * coral . cover ): slot_1 = np . arange ( len ( coral . cover ))[ p . sum ( axis = 1 ) > 1.0001 * coral . cover ] slot_2 = p [ p . sum ( axis = 1 ) > 1.0001 * coral . cover ] slot_3 = coral . cover [ p . sum ( axis = 1 ) > 1.0001 * coral . cover ] print ( f \"WARNING: Total population than carrying capacity at { slot_1 } . \" f \" \\n\\t PT = { slot_2 } ; K = { slot_3 } \" ) # # output return p Recruitment \u00b6 Recruitment pydantic-model \u00b6 Recruitment dynamics. recruited ( potential , averaged_healthy_pop , cover_real , cover_potential ) staticmethod \u00b6 Determination of recruitment. :param potential: recruitment potential :param averaged_healthy_pop: model domain averaged healthy population :param cover_real: real coral cover :param cover_potential: potential coral cover :type potential: float :type averaged_healthy_pop: float :type cover_real: float :type cover_potential: float Source code in src/core/bio_process/recruitment.py @staticmethod def recruited ( potential , averaged_healthy_pop , cover_real , cover_potential ): \"\"\"Determination of recruitment. :param potential: recruitment potential :param averaged_healthy_pop: model domain averaged healthy population :param cover_real: real coral cover :param cover_potential: potential coral cover :type potential: float :type averaged_healthy_pop: float :type cover_real: float :type cover_potential: float \"\"\" return potential * averaged_healthy_pop * ( 1 - cover_real / cover_potential ) spawning ( self , coral : Coral , param ) \u00b6 Contribution due to mass coral spawning. :param coral: coral animal :param param: parameter type to which the spawning is added :type coral: Coral :type param: str Source code in src/core/bio_process/recruitment.py def spawning ( self , coral : Coral , param ): \"\"\"Contribution due to mass coral spawning. :param coral: coral animal :param param: parameter type to which the spawning is added :type coral: Coral :type param: str \"\"\" # # input check params = ( \"P\" , \"V\" ) if param not in params : msg = f \" { param } not in { params } .\" raise ValueError ( msg ) # # calculations # potential power = 2 if param == \"P\" else 3 potential = ( self . constants . prob_settle * self . constants . no_larvae * self . constants . d_larvae ** power ) # recruitment averaged_healthy_pop = coral . pop_states [:, - 1 , 0 ] . mean () # living cover living_cover = RESHAPE () . matrix2array ( coral . living_cover , \"space\" ) recruited = CoralOnly () . in_space ( coral = coral , function = self . recruited , args = ( potential , averaged_healthy_pop , living_cover , coral . cover ), ) # # output return recruited update ( self , coral : Coral ) \u00b6 Update coral cover / volume after spawning event. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/recruitment.py def update ( self , coral : Coral ): \"\"\"Update coral cover / volume after spawning event. :param coral: coral animal :type coral: Coral \"\"\" coral . p0 [:, 0 ] += Recruitment . spawning ( self , coral , \"P\" ) coral . update_coral_volume ( coral . volume + Recruitment . spawning ( self , coral , \"V\" )) Temperature \u00b6 Temperature \u00b6 __init__ ( self , temperature , constants : Constants = Constants ( input_file = None , fme = False , tme = False , pfd = False , warn_proc = True , Kd0 = 0.1 , theta_max = 1.5707963267948966 , Cs = 0.17 , Cm = 1.7 , Cf = 0.01 , nu = 1e-06 , alpha = 1e-07 , psi = 2 , wcAngle = 0.0 , rd = 500 , numericTheta = 0.5 , err = 0.001 , maxiter_k = 100000 , maxiter_aw = 100000 , K0 = 80.0 , ap = 0.4 , k = 0.6089 , iota = 0.6 , ik_max = 372.32 , pm_max = 1.0 , betaI = 0.34 , betaP = 0.09 , Icomp = 0.01 , Ea = 60000.0 , R = 8.31446261815324 , k_var = 2.45 , nn = 60 , pfd_min = 0.68886964 , ucr = 0.5173 , r_growth = 0.002 , r_recovery = 0.2 , r_mortality = 0.04 , r_bleaching = 8.0 , gC = 0.5 , omegaA0 = 5.0 , omega0 = 0.14587415 , kappaA = 0.66236107 , rf = 1.0 , rp = 1.0 , prop_form = 0.1 , prop_plate = 0.5 , prop_plate_flow = 0.1 , prop_space = 0.35355339059327373 , prop_space_light = 0.1 , prop_space_flow = 0.1 , u0 = 0.2 , rho_c = 1600.0 , sigma_t = 200000.0 , Cd = 1.0 , rho_w = 1025.0 , no_larvae = 1000000.0 , prob_settle = 0.0001 , d_larvae = 0.001 )) special \u00b6 Thermal micro-environment. Parameters \u00b6 temperature : numeric Temperature of water [K]. Source code in src/core/bio_process/temperature.py def __init__ ( self , temperature , constants : Constants = Constants ()): \"\"\" Thermal micro-environment. Parameters ---------- temperature : numeric Temperature of water [K]. \"\"\" self . T = RESHAPE () . variable2matrix ( temperature , \"time\" ) self . constants = constants coral_temperature ( self , coral : Coral ) \u00b6 Coral temperature. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/temperature.py def coral_temperature ( self , coral : Coral ): \"\"\"Coral temperature. :param coral: coral animal :type coral: Coral \"\"\" if self . constants . tme : delta_t = RESHAPE () . variable2matrix ( coral . delta_t , \"space\" ) coral . dTc = ( ( delta_t * self . constants . ap ) / ( self . constants . k * self . constants . K0 ) * coral . light ) coral . temp = self . T + coral . dTc else : coral . temp = self . T","title":"Processes"},{"location":"reference/bio_process/processes/#biophysical-processes","text":"","title":"Biophysical processes"},{"location":"reference/bio_process/processes/#calcification","text":"","title":"Calcification"},{"location":"reference/bio_process/processes/#src.core.bio_process.calcification.Calcification","text":"Calcification rate.","title":"Calcification"},{"location":"reference/bio_process/processes/#src.core.bio_process.calcification.Calcification.__init__","text":"Calcification rate. Source code in src/core/bio_process/calcification.py def __init__ ( self , constants : Constants = Constants ()): \"\"\"Calcification rate.\"\"\" self . ad = 1 self . constants = constants","title":"__init__()"},{"location":"reference/bio_process/processes/#src.core.bio_process.calcification.Calcification.calcification_rate","text":"Calcification rate. :param coral: coral animal :param omega: aragonite saturation state :type coral: Coral :type omega: float, list, tuple, numpy.ndarray Source code in src/core/bio_process/calcification.py def calcification_rate ( self , coral , omega ): \"\"\"Calcification rate. :param coral: coral animal :param omega: aragonite saturation state :type coral: Coral :type omega: float, list, tuple, numpy.ndarray \"\"\" def aragonite_dependency ( calcification_object ): \"\"\"Aragonite dependency.\"\"\" calcification_object . ad = ( omega - self . constants . omega0 ) / ( self . constants . kappaA + omega - self . constants . omega0 ) calcification_object . ad = RESHAPE () . variable2matrix ( calcification_object . ad , \"time\" ) aragonite_dependency ( self ) coral . calc = ( self . constants . gC * coral . Csp * coral . pop_states [:, :, 0 ] * self . ad * coral . photo_rate )","title":"calcification_rate()"},{"location":"reference/bio_process/processes/#dislodgement","text":"","title":"Dislodgement"},{"location":"reference/bio_process/processes/#src.core.bio_process.dislodgment.Dislodgement","text":"Dislodgement due to storm conditions.","title":"Dislodgement"},{"location":"reference/bio_process/processes/#src.core.bio_process.dislodgment.Dislodgement.colony_shape_factor","text":"Colony Shape Factor. Parameters: Name Type Description Default coral Coral Coral animal. required Source code in src/core/bio_process/dislodgment.py def colony_shape_factor ( self , coral : Coral ): \"\"\" Colony Shape Factor. Args: coral (Coral): Coral animal. \"\"\" self . csf = CoralOnly () . in_space ( coral = coral , function = self . csf_formula , args = ( coral . dc , coral . hc , coral . bc , coral . tc ), )","title":"colony_shape_factor()"},{"location":"reference/bio_process/processes/#src.core.bio_process.dislodgment.Dislodgement.csf_formula","text":"Determine the Colony Shape Factor. :param dc: diameter coral plate [m] :param hc: coral height [m] :param bc: diameter coral base [m] :param tc: thickness coral plate [m] :type dc: float, numpy.ndarray :type hc: float, numpy.ndarray :type bc: float, numpy.ndarray :type tc: float, numpy.ndarray :return: colony shape factor :rtype: float, numpy.ndarray Source code in src/core/bio_process/dislodgment.py @staticmethod def csf_formula ( dc , hc , bc , tc ): \"\"\"Determine the Colony Shape Factor. :param dc: diameter coral plate [m] :param hc: coral height [m] :param bc: diameter coral base [m] :param tc: thickness coral plate [m] :type dc: float, numpy.ndarray :type hc: float, numpy.ndarray :type bc: float, numpy.ndarray :type tc: float, numpy.ndarray :return: colony shape factor :rtype: float, numpy.ndarray \"\"\" # arms of moment arm_top = hc - 0.5 * tc arm_bottom = 0.5 * ( hc - tc ) # area of moment area_top = dc * tc area_bottom = bc * ( hc - tc ) # integral integral = arm_top * area_top + arm_bottom * area_bottom # colony shape factor return 16.0 / ( np . pi * bc ** 3 ) * integral","title":"csf_formula()"},{"location":"reference/bio_process/processes/#src.core.bio_process.dislodgment.Dislodgement.dislodgement_criterion","text":"Dislodgement criterion. Returns boolean (array). :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/dislodgment.py def dislodgement_criterion ( self , coral : Coral ): \"\"\"Dislodgement criterion. Returns boolean (array). :param coral: coral animal :type coral: Coral \"\"\" self . dislodgement_mechanical_threshold ( coral ) self . colony_shape_factor ( coral ) return self . dmt <= self . csf","title":"dislodgement_criterion()"},{"location":"reference/bio_process/processes/#src.core.bio_process.dislodgment.Dislodgement.dislodgement_mechanical_threshold","text":"Dislodgement Mechanical Threshold. Parameters: Name Type Description Default coral Coral Coral animal. required Source code in src/core/bio_process/dislodgment.py def dislodgement_mechanical_threshold ( self , coral : Coral ): \"\"\" Dislodgement Mechanical Threshold. Args: coral (Coral): Coral animal. \"\"\" # # check input if not hasattr ( coral . um , \"__iter__\" ): coral . um = np . array ([ coral . um ]) if isinstance ( coral . um , ( list , tuple )): coral . um = np . array ( coral . um ) # # calculations self . dmt = 1e20 * np . ones ( coral . um . shape ) self . dmt [ coral . um > 0 ] = self . dmt_formula ( self . constants , coral . um [ coral . um > 0 ] )","title":"dislodgement_mechanical_threshold()"},{"location":"reference/bio_process/processes/#src.core.bio_process.dislodgment.Dislodgement.dmt_formula","text":"Determine the Dislodgement Mechanical Threshold. :param flow_velocity: depth-averaged flow velocity :type flow_velocity: float, numpy.ndarray Source code in src/core/bio_process/dislodgment.py @staticmethod def dmt_formula ( constants , flow_velocity ): \"\"\"Determine the Dislodgement Mechanical Threshold. :param flow_velocity: depth-averaged flow velocity :type flow_velocity: float, numpy.ndarray \"\"\" return constants . sigma_t / ( constants . rho_w * constants . Cd * flow_velocity ** 2 )","title":"dmt_formula()"},{"location":"reference/bio_process/processes/#src.core.bio_process.dislodgment.Dislodgement.partial_dislodgement","text":"Percentage surviving storm event. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional Source code in src/core/bio_process/dislodgment.py def partial_dislodgement ( self , coral , survival_coefficient = 1.0 ): \"\"\"Percentage surviving storm event. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional \"\"\" # TODO: Rewrite such that the distinction between an array or a float is well build in. try : self . survival = np . ones ( coral . dc . shape ) except TypeError : if Dislodgement . dislodgement_criterion ( self , coral ): self . survival = survival_coefficient * self . dmt / self . csf else : self . survival = 1.0 else : dislodged = Dislodgement . dislodgement_criterion ( self , coral ) self . survival [ dislodged ] = survival_coefficient * ( self . dmt [ dislodged ] / self . csf [ dislodged ] )","title":"partial_dislodgement()"},{"location":"reference/bio_process/processes/#src.core.bio_process.dislodgment.Dislodgement.update","text":"Update morphology due to storm damage. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional Source code in src/core/bio_process/dislodgment.py def update ( self , coral : Coral , survival_coefficient = 1 ): \"\"\"Update morphology due to storm damage. :param coral: coral animal :param survival_coefficient: percentage of partial survival, defualts to 1 :type coral: Coral :type survival_coefficient: float, optional \"\"\" # # partial dislodgement Dislodgement . partial_dislodgement ( self , coral , survival_coefficient ) # # update # ulation states for s in range ( 4 ): coral . p0 [:, s ] *= self . survival # morphology coral . update_coral_volume ( coral . volume * self . survival )","title":"update()"},{"location":"reference/bio_process/processes/#flow","text":"","title":"Flow"},{"location":"reference/bio_process/processes/#src.core.bio_process.flow.Flow","text":"Flow micro-environment.","title":"Flow"},{"location":"reference/bio_process/processes/#src.core.bio_process.flow.Flow.__init__","text":":param u_current: current flow velocity [m s-1] :param u_wave: wave flow velocity [m s-1] :param h: water depth [m] :param peak_period: peak wave period [s] :type u_current: float, list, tuple, numpy.ndarray :type u_wave: float, list, tuple, numpy.ndarray :type h: float, list, tuple, numpy.ndarray :type peak_period: float, list, tuple, numpy.ndarray Source code in src/core/bio_process/flow.py def __init__ ( self , u_current , u_wave , h , peak_period , constants : Constants = Constants (), ): \"\"\" :param u_current: current flow velocity [m s-1] :param u_wave: wave flow velocity [m s-1] :param h: water depth [m] :param peak_period: peak wave period [s] :type u_current: float, list, tuple, numpy.ndarray :type u_wave: float, list, tuple, numpy.ndarray :type h: float, list, tuple, numpy.ndarray :type peak_period: float, list, tuple, numpy.ndarray \"\"\" _reshape = RESHAPE () self . uc = _reshape . variable2array ( u_current ) self . uw = _reshape . variable2array ( u_wave ) self . h = _reshape . variable2matrix ( h , \"space\" ) self . Tp = _reshape . variable2array ( peak_period ) self . active = False if u_current is None and u_wave is None else True self . constants = constants","title":"__init__()"},{"location":"reference/bio_process/processes/#src.core.bio_process.flow.Flow.thermal_boundary_layer","text":"Thermal boundary layer. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/flow.py def thermal_boundary_layer ( self , coral ): \"\"\"Thermal boundary layer. :param coral: coral animal :type coral: Coral \"\"\" if self . active and self . constants . tme : delta = self . velocity_boundary_layer ( self . constants , coral ) coral . delta_t = delta * ( ( self . constants . alpha / self . constants . nu ) ** ( 1 / 3 ) )","title":"thermal_boundary_layer()"},{"location":"reference/bio_process/processes/#src.core.bio_process.flow.Flow.uc_matrix","text":"Reshaped current flow velocity.","title":"uc_matrix"},{"location":"reference/bio_process/processes/#src.core.bio_process.flow.Flow.uw_matrix","text":"Reshaped wave flow velocity.","title":"uw_matrix"},{"location":"reference/bio_process/processes/#src.core.bio_process.flow.Flow.velocities","text":"In-canopy flow velocities, and depth-averaged flow velocities. :param coral: coral animal :param in_canopy: determine in-canopy flow (or depth-averaged), defaults to True :type coral: Coral :type in_canopy: bool, optional Source code in src/core/bio_process/flow.py def velocities ( self , coral , in_canopy = True ): \"\"\"In-canopy flow velocities, and depth-averaged flow velocities. :param coral: coral animal :param in_canopy: determine in-canopy flow (or depth-averaged), defaults to True :type coral: Coral :type in_canopy: bool, optional \"\"\" if self . active : alpha_w = np . ones ( self . uw . shape ) alpha_c = np . ones ( self . uc . shape ) if in_canopy : idx = coral . volume > 0 for i in idx : alpha_w [ i ] = self . wave_attenuation ( self . constants , coral . dc_rep [ i ], coral . hc [ i ], coral . ac [ i ], self . uw [ i ], self . Tp [ i ], self . h [ i ], wac_type = \"wave\" , ) alpha_c [ i ] = self . wave_attenuation ( self . constants , coral . dc_rep [ i ], coral . hc [ i ], coral . ac [ i ], self . uc [ i ], 1e3 , self . h [ i ], wac_type = \"current\" , ) coral . ucm = self . wave_current ( alpha_w , alpha_c ) coral . um = self . wave_current () else : coral . ucm = 9999 * np . ones ( RESHAPE () . space )","title":"velocities()"},{"location":"reference/bio_process/processes/#src.core.bio_process.flow.Flow.velocity_boundary_layer","text":"Velocity boundary layer. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/flow.py @staticmethod def velocity_boundary_layer ( constants , coral ): \"\"\"Velocity boundary layer. :param coral: coral animal :type coral: Coral \"\"\" def boundary_layer ( rd , nu , cf , ucm ): \"\"\"Thickness velocity boundary layer.\"\"\" return ( rd * nu ) / ( np . sqrt ( cf ) * ucm ) return CoralOnly () . in_space ( coral = coral , function = boundary_layer , args = ( constants . rd , constants . nu , constants . Cf , coral . ucm ), )","title":"velocity_boundary_layer()"},{"location":"reference/bio_process/processes/#src.core.bio_process.flow.Flow.wave_attenuation","text":"Wave-attenuation coefficient. :param diameter: representative coral diameter [m] :param height: coral height [m] :param distance: axial distance [m] :param velocity: flow velocity [m s-1] :param period: wave period [s] :param depth: water depth [m] :param wac_type: type of wave-attenuation coefficient [-] :type diameter: float :type height: float :type distance: float :type velocity: float :type depth: float :type depth: float :type wac_type: str Source code in src/core/bio_process/flow.py @staticmethod def wave_attenuation ( constants , diameter , height , distance , velocity , period , depth , wac_type ): \"\"\"Wave-attenuation coefficient. :param diameter: representative coral diameter [m] :param height: coral height [m] :param distance: axial distance [m] :param velocity: flow velocity [m s-1] :param period: wave period [s] :param depth: water depth [m] :param wac_type: type of wave-attenuation coefficient [-] :type diameter: float :type height: float :type distance: float :type velocity: float :type depth: float :type depth: float :type wac_type: str \"\"\" # TODO: Split this method in one solely focusing on the wave attenuation coefficient; # and one implementing this method to dynamically determine the drag coefficient. # Thus, reformat this method as in coral_model_v0. # # function and derivative definitions def function ( beta ): \"\"\"Complex-valued function to be solved, where beta is the complex representation of the wave-attenuation coefficient. \"\"\" # components shear = ( ( 8.0 * above_motion ) / ( 3.0 * np . pi * shear_length ) * ( abs ( 1.0 - beta ) * ( 1.0 - beta )) ) drag = ( ( 8.0 * above_motion ) / ( 3.0 * np . pi * drag_length ) * ( abs ( beta ) * beta ) ) inertia = ( 1 j * beta * (( constants . Cm * lambda_planar ) / ( 1.0 - lambda_planar )) ) # combined f = 1 j * ( beta - 1.0 ) - shear + drag + inertia # output return f def derivative ( beta ): \"\"\"Complex-valued derivative to be used to solve the complex-valued function, where beta is the complex representation of the wave-attenuation coefficient. \"\"\" # components shear = ( ( 1.0 - beta ) ** 2 / abs ( 1.0 - beta ) - abs ( 1.0 - beta ) ) / shear_length drag = ( beta ** 2 / abs ( beta ) + beta ) / drag_length inertia = 1 j * ( constants . Cm * lambda_planar ) / ( 1.0 - lambda_planar ) # combined df = 1 j + ( 8.0 * above_motion ) / ( 3.0 * np . pi ) * ( - shear + drag ) + inertia # output return df # # Input check def wave_wac (): return abs ( newton ( function , x0 = complex ( 0.1 , 0.1 ), fprime = derivative , maxiter = constants . maxiter_aw , ) ) def current_wac (): x = drag_length / shear_length * ( height / ( depth - height ) + 1 ) return ( x - np . sqrt ( x )) / ( x - 1 ) wac_type_funcs = dict ( current = current_wac , wave = wave_wac ) wac_function = wac_type_funcs . get ( wac_type , None ) if wac_function is None : raise ValueError ( f \"WAC-type ( { wac_type } ) not in { wac_type_funcs . keys () } .\" ) # # parameter definitions # geometric parameters planar_area = 0.25 * np . pi * diameter ** 2 frontal_area = diameter * height total_area = 0.5 * distance ** 2 lambda_planar = planar_area / total_area lambda_frontal = frontal_area / total_area shear_length = height / ( constants . Cs ** 2 ) # # calculations wac = 1.0 if depth <= height : return wac # If depth > height # initial iteration values above_flow = velocity drag_coefficient = 1.0 # iteration for k in range ( int ( constants . maxiter_k )): drag_length = ( 2 * height * ( 1 - lambda_planar )) / ( drag_coefficient * lambda_frontal ) above_motion = ( above_flow * period ) / ( 2 * np . pi ) wac = wac_function () porous_flow = wac * above_flow constricted_flow = ( ( 1 - lambda_planar ) / ( 1 - np . sqrt (( 4 * lambda_planar ) / ( constants . psi * np . pi ))) * porous_flow ) reynolds = ( constricted_flow * diameter ) / constants . nu new_drag = 1 + 10 * reynolds ** ( - 2.0 / 3 ) if abs (( new_drag - drag_coefficient ) / new_drag ) <= constants . err : break else : drag_coefficient = float ( new_drag ) above_flow = abs ( ( 1 - constants . numericTheta ) * above_flow + constants . numericTheta * ( depth * velocity - height * porous_flow ) / ( depth - height ) ) if k == constants . maxiter_k : print ( f \"WARNING: maximum number of iterations reached \" f \"( { constants . maxiter_k } )\" ) return wac","title":"wave_attenuation()"},{"location":"reference/bio_process/processes/#src.core.bio_process.flow.Flow.wave_current","text":"Wave-current interaction. :param alpha_w: wave-attenuation coefficient, defaults to 1 :param alpha_c: current-attenuation coefficient, defaults to 1 :type alpha_w: float, list, tuple, numpy.ndarray, optional :type alpha_c: float, list, tuple, numpy.ndarray, optional :return: wave-current interaction :rtype: float, numpy.ndarray Source code in src/core/bio_process/flow.py def wave_current ( self , alpha_w = 1 , alpha_c = 1 ): \"\"\"Wave-current interaction. :param alpha_w: wave-attenuation coefficient, defaults to 1 :param alpha_c: current-attenuation coefficient, defaults to 1 :type alpha_w: float, list, tuple, numpy.ndarray, optional :type alpha_c: float, list, tuple, numpy.ndarray, optional :return: wave-current interaction :rtype: float, numpy.ndarray \"\"\" return np . sqrt ( ( alpha_w * self . uw ) ** 2 + ( alpha_c * self . uc ) ** 2 + 2 * alpha_w * self . uw * alpha_c * self . uc * np . cos ( self . constants . wcAngle ) )","title":"wave_current()"},{"location":"reference/bio_process/processes/#light","text":"","title":"Light"},{"location":"reference/bio_process/processes/#src.core.bio_process.light.Light","text":"Light micro-environment.","title":"Light"},{"location":"reference/bio_process/processes/#src.core.bio_process.light.Light.__init__","text":"Light micro-environment. Parameters: Name Type Description Default light_in Union[float, list, tuple, numpy.ndarray] Incoming light-intensity at the water-air interface [u mol photons m-2 s-1] required lac Union[float, list, tuple, numpy.ndarray] light-attenuation coefficient [m-1] required depth Union[float, list, tuple, numpy.ndarray] water depth [m] required constants Constants List of constants to be used for this object. Constants(input_file=None, fme=False, tme=False, pfd=False, warn_proc=True, Kd0=0.1, theta_max=1.5707963267948966, Cs=0.17, Cm=1.7, Cf=0.01, nu=1e-06, alpha=1e-07, psi=2, wcAngle=0.0, rd=500, numericTheta=0.5, err=0.001, maxiter_k=100000, maxiter_aw=100000, K0=80.0, ap=0.4, k=0.6089, iota=0.6, ik_max=372.32, pm_max=1.0, betaI=0.34, betaP=0.09, Icomp=0.01, Ea=60000.0, R=8.31446261815324, k_var=2.45, nn=60, pfd_min=0.68886964, ucr=0.5173, r_growth=0.002, r_recovery=0.2, r_mortality=0.04, r_bleaching=8.0, gC=0.5, omegaA0=5.0, omega0=0.14587415, kappaA=0.66236107, rf=1.0, rp=1.0, prop_form=0.1, prop_plate=0.5, prop_plate_flow=0.1, prop_space=0.35355339059327373, prop_space_light=0.1, prop_space_flow=0.1, u0=0.2, rho_c=1600.0, sigma_t=200000.0, Cd=1.0, rho_w=1025.0, no_larvae=1000000.0, prob_settle=0.0001, d_larvae=0.001) Source code in src/core/bio_process/light.py def __init__ ( self , light_in : LightVariable , lac : LightVariable , depth : LightVariable , constants : Constants = Constants (), ): \"\"\" Light micro-environment. Args: light_in (LightVariable): Incoming light-intensity at the water-air interface [u mol photons m-2 s-1] lac (LightVariable): light-attenuation coefficient [m-1] depth (LightVariable): water depth [m] constants (Constants): List of constants to be used for this object. \"\"\" _reshape = RESHAPE () self . I0 = _reshape . variable2matrix ( light_in , \"time\" ) self . Kd = _reshape . variable2matrix ( lac , \"time\" ) self . h = _reshape . variable2matrix ( depth , \"space\" ) self . constants = constants","title":"__init__()"},{"location":"reference/bio_process/processes/#src.core.bio_process.light.Light.base_light","text":"Section of coral base receiving light. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/light.py def base_light ( self , coral ): \"\"\"Section of coral base receiving light. :param coral: coral animal :type coral: Coral \"\"\" # # spreading of light theta = self . light_spreading ( coral ) # # coral base section base_section = ( coral . hc_matrix - coral . tc_matrix - (( coral . dc_matrix - coral . bc_matrix ) / ( 2.0 * np . tan ( 0.5 * theta ))) ) # no negative lengths base_section [ base_section < 0 ] = 0 return base_section","title":"base_light()"},{"location":"reference/bio_process/processes/#src.core.bio_process.light.Light.biomass","text":"Coral biomass; as surface. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/light.py def biomass ( self , coral ): \"\"\"Coral biomass; as surface. :param coral: coral animal :type coral: Coral \"\"\" base_section = self . base_light ( coral ) coral . light_bc = np . pi * ( 0.25 * coral . dc_matrix ** 2 + coral . dc_matrix * coral . tc_matrix + coral . bc_matrix * base_section )","title":"biomass()"},{"location":"reference/bio_process/processes/#src.core.bio_process.light.Light.light_spreading","text":"Spreading of light as function of depth. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/light.py def light_spreading ( self , coral ): \"\"\"Spreading of light as function of depth. :param coral: coral animal :type coral: Coral \"\"\" return self . constants . theta_max * np . exp ( - self . Kd * ( self . h - coral . hc_matrix + coral . tc_matrix ) )","title":"light_spreading()"},{"location":"reference/bio_process/processes/#src.core.bio_process.light.Light.rep_light","text":"Representative light-intensity. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/light.py def rep_light ( self , coral ): \"\"\"Representative light-intensity. :param coral: coral animal :type coral: Coral \"\"\" base_section = self . base_light ( coral ) # # light catchment per coral section # top of plate top = ( 0.25 * np . pi * coral . dc_matrix ** 2 * self . I0 * np . exp ( - self . Kd * ( self . h - coral . hc_matrix )) ) # side of plate side = ( ( np . pi * coral . dc_matrix * self . I0 ) / self . Kd * ( np . exp ( - self . Kd * ( self . h - coral . hc_matrix )) - np . exp ( - self . Kd * ( self . h - coral . hc_matrix + coral . tc_matrix )) ) * self . side_correction ( coral ) ) # side of base base = ( ( np . pi * coral . bc_matrix * self . I0 ) / self . Kd * ( np . exp ( - self . Kd * ( self . h - base_section )) - np . exp ( - self . Kd * self . h )) * self . side_correction ( coral ) ) # total total = top + side + base # # biomass-averaged self . biomass ( coral ) def averaged_light ( total_light , biomass ): \"\"\"Averaged light-intensity.\"\"\" return total_light / biomass coral . light = CoralOnly () . in_spacetime ( coral = coral , function = averaged_light , args = ( total , coral . light_bc ), no_cover_value = self . I0 * np . exp ( - self . Kd * self . h ), )","title":"rep_light()"},{"location":"reference/bio_process/processes/#src.core.bio_process.light.Light.side_correction","text":"Correction of the light-intensity on the sides of the coral object. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/light.py def side_correction ( self , coral ): \"\"\"Correction of the light-intensity on the sides of the coral object. :param coral: coral animal :type coral: Coral \"\"\" # # spreading of light theta = self . light_spreading ( coral ) # # correction factor return np . sin ( 0.5 * theta )","title":"side_correction()"},{"location":"reference/bio_process/processes/#morphology","text":"","title":"Morphology"},{"location":"reference/bio_process/processes/#src.core.bio_process.morphology.Morphology","text":"Morphological development.","title":"Morphology"},{"location":"reference/bio_process/processes/#src.core.bio_process.morphology.Morphology.__init__","text":"Morphological development. :param calc_sum: accumulation of calcification of :param dt_year: years [kg m-2 yr-1] :param light_in: incoming light-intensity at water-air interface [umol photons m-2 s-1] :param dt_year: update interval [yr], defaults to 1 :type calc_sum: float, int, list, tuple, numpy.ndarray :type light_in: float, int, list, tuple, numpy.ndarray :type dt_year: float, int Source code in src/core/bio_process/morphology.py def __init__ ( self , calc_sum , light_in , dt_year = 1 , constants : Constants = Constants () ): \"\"\" Morphological development. :param calc_sum: accumulation of calcification of :param dt_year: years [kg m-2 yr-1] :param light_in: incoming light-intensity at water-air interface [umol photons m-2 s-1] :param dt_year: update interval [yr], defaults to 1 :type calc_sum: float, int, list, tuple, numpy.ndarray :type light_in: float, int, list, tuple, numpy.ndarray :type dt_year: float, int \"\"\" _reshape = RESHAPE () try : _ = len ( calc_sum [ 0 ]) except TypeError : self . calc_sum = calc_sum else : self . calc_sum = _reshape . matrix2array ( calc_sum , \"space\" , \"sum\" ) self . dt_year = dt_year self . I0 = _reshape . variable2matrix ( light_in , \"time\" ) self . vol_increase = 0 self . constants = constants","title":"__init__()"},{"location":"reference/bio_process/processes/#src.core.bio_process.morphology.Morphology.delta_volume","text":":param coral: coral object :type coral: Coral Source code in src/core/bio_process/morphology.py def delta_volume ( self , coral ): \"\"\" :param coral: coral object :type coral: Coral \"\"\" self . vol_increase = ( 0.5 * coral . ac ** 2 * self . calc_sum * self . dt_year / self . constants . rho_c * coral . light_bc . mean ( axis = 1 ) ) return self . vol_increase","title":"delta_volume()"},{"location":"reference/bio_process/processes/#src.core.bio_process.morphology.Morphology.ratio_update","text":":param coral: coral object :param ratio: morphological ratio to update :type coral: Coral :type ratio: str Source code in src/core/bio_process/morphology.py def ratio_update ( self , coral , ratio ): \"\"\" :param coral: coral object :param ratio: morphological ratio to update :type coral: Coral :type ratio: str \"\"\" # partial differential equation - mass balance def mass_balance ( r_old , r_opt ): \"\"\"Mass balance.\"\"\" return ( coral . volume * r_old + self . vol_increase * r_opt ) / ( coral . volume + self . vol_increase ) # input check ratios = ( \"rf\" , \"rp\" , \"rs\" ) if ratio not in ratios : msg = f \" { ratio } not in { ratios } .\" raise ValueError ( msg ) # calculations self . delta_volume ( coral ) # optimal ratio setattr ( self , f \" { ratio } _optimal\" , coral ) # update morphological ratio if hasattr ( self , f \" { ratio } _optimal\" ) and hasattr ( coral , ratio ): return mass_balance ( getattr ( coral , ratio ), getattr ( self , f \" { ratio } _optimal\" ) )","title":"ratio_update()"},{"location":"reference/bio_process/processes/#src.core.bio_process.morphology.Morphology.rf_optimal","text":"Optimal form ratio; height-to-plate diameter. :rtype: float, numpy.ndarray","title":"rf_optimal"},{"location":"reference/bio_process/processes/#src.core.bio_process.morphology.Morphology.rp_optimal","text":"Optimal plate ratio; base diameter-to-plate diameter. :rtype: float, numpy.ndarray","title":"rp_optimal"},{"location":"reference/bio_process/processes/#src.core.bio_process.morphology.Morphology.rs_optimal","text":"Optimal spacing ratio; plate diameter-to-axial distance. :rtype: float, numpy.ndarray","title":"rs_optimal"},{"location":"reference/bio_process/processes/#src.core.bio_process.morphology.Morphology.update","text":"Update morphology. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/morphology.py def update ( self , coral : Coral ): \"\"\"Update morphology. :param coral: coral animal :type coral: Coral \"\"\" # # calculations # updated ratios ratios = { ratio : self . ratio_update ( coral , ratio ) for ratio in ( \"rf\" , \"rp\" , \"rs\" ) } # updated volume volume = coral . volume + self . vol_increase # update coral morphology coral . update_coral_morphology ( volume , ratios )","title":"update()"},{"location":"reference/bio_process/processes/#photosynthesis","text":"","title":"Photosynthesis"},{"location":"reference/bio_process/processes/#src.core.bio_process.photosynthesis.Photosynthesis","text":"Photosynthesis.","title":"Photosynthesis"},{"location":"reference/bio_process/processes/#src.core.bio_process.photosynthesis.Photosynthesis.__init__","text":"Photosynthetic efficiency based on photosynthetic dependencies. :param light_in: incoming light-intensity at the water-air interface [umol photons m-2 s-1] :param first_year: first year of the model simulation :type light_in: float, list, tuple, numpy.ndarray :type first_year: bool Source code in src/core/bio_process/photosynthesis.py def __init__ ( self , light_in , first_year , constants : Constants = Constants ()): \"\"\" Photosynthetic efficiency based on photosynthetic dependencies. :param light_in: incoming light-intensity at the water-air interface [umol photons m-2 s-1] :param first_year: first year of the model simulation :type light_in: float, list, tuple, numpy.ndarray :type first_year: bool \"\"\" self . I0 = RESHAPE () . variable2matrix ( light_in , \"time\" ) self . first_year = first_year self . pld = 1 self . ptd = 1 self . pfd = 1 self . constants = constants","title":"__init__()"},{"location":"reference/bio_process/processes/#src.core.bio_process.photosynthesis.Photosynthesis.flow_dependency","text":"Photosynthetic flow dependency. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/photosynthesis.py def flow_dependency ( self , coral : Coral ): \"\"\"Photosynthetic flow dependency. :param coral: coral animal :type coral: Coral \"\"\" if self . constants . pfd : pfd = self . constants . pfd_min + ( 1 - self . constants . pfd_min ) * np . tanh ( 2 * coral . ucm / self . constants . ucr ) self . pfd = RESHAPE () . variable2matrix ( pfd , \"space\" ) else : self . pfd = 1","title":"flow_dependency()"},{"location":"reference/bio_process/processes/#src.core.bio_process.photosynthesis.Photosynthesis.light_dependency","text":"Photosynthetic light dependency. :param coral: coral animal :param output: type of output :type coral: Coral :type output: str Source code in src/core/bio_process/photosynthesis.py def light_dependency ( self , coral , output ): \"\"\"Photosynthetic light dependency. :param coral: coral animal :param output: type of output :type coral: Coral :type output: str \"\"\" def photo_acclimation ( x_old , param ): \"\"\"Photo-acclimation.\"\"\" # input check params = ( \"Ik\" , \"Pmax\" ) if param not in params : message = f \" { param } not in { params } .\" raise ValueError ( message ) # parameter definitions x_max = self . constants . ik_max if param == \"Ik\" else self . constants . pm_max beta_x = self . constants . betaI if param == \"Ik\" else self . constants . betaP # calculations xs = x_max * ( coral . light / self . I0 ) ** beta_x if output == \"qss\" : return xs elif output == \"new\" : return xs + ( x_old - xs ) * np . exp ( - self . constants . iota ) # # parameter definitions if output == \"qss\" : ik = photo_acclimation ( None , \"Ik\" ) p_max = photo_acclimation ( None , \"Pmax\" ) else : msg = f \"Only the quasi-steady state solution is currently implemented; use key-word 'qss'.\" raise NotImplementedError ( msg ) # # calculations self . pld = p_max * ( np . tanh ( coral . light / ik ) - np . tanh ( self . constants . Icomp * self . I0 / ik ) )","title":"light_dependency()"},{"location":"reference/bio_process/processes/#src.core.bio_process.photosynthesis.Photosynthesis.photo_rate","text":"Photosynthetic efficiency. :param coral: coral animal :param environment: environmental conditions :param year: year of simulation :type coral: Coral :type environment: Environment :type year: int Source code in src/core/bio_process/photosynthesis.py def photo_rate ( self , coral , environment , year ): \"\"\"Photosynthetic efficiency. :param coral: coral animal :param environment: environmental conditions :param year: year of simulation :type coral: Coral :type environment: Environment :type year: int \"\"\" # components self . light_dependency ( coral , \"qss\" ) self . thermal_dependency ( coral , environment , year ) self . flow_dependency ( coral ) # combined coral . photo_rate = self . pld * self . ptd * self . pfd","title":"photo_rate()"},{"location":"reference/bio_process/processes/#src.core.bio_process.photosynthesis.Photosynthesis.thermal_dependency","text":"Photosynthetic thermal dependency. :param coral: coral animal :param env: environmental conditions :param year: year of simulation :type coral: Coral :type env: Environment :type year: int Source code in src/core/bio_process/photosynthesis.py def thermal_dependency ( self , coral : Coral , env , year ): \"\"\"Photosynthetic thermal dependency. :param coral: coral animal :param env: environmental conditions :param year: year of simulation :type coral: Coral :type env: Environment :type year: int \"\"\" _reshape = RESHAPE () def thermal_acc (): \"\"\"Thermal-acclimation.\"\"\" if self . constants . tme : if self . first_year : env . tmeMMMmin = ( pd . DataFrame ( data = pd . concat ( [ env . temp_mmm [ \"min\" ]] * _reshape . space , axis = 1 ) . values , columns = [ np . arange ( _reshape . space )], ) + coral . dTc ) env . tmeMMMmax = ( pd . DataFrame ( data = pd . concat ( [ env . temp_mmm [ \"max\" ]] * _reshape . space , axis = 1 ) . values , columns = [ np . arange ( _reshape . space )], ) + coral . dTc ) else : env . tmeMMMmin [ env . tmeMMM . index == year ] += coral . dTc env . tmeMMMmax [ env . tmeMMm . index == year ] += coral . dTc mmm_min = env . tmeMMMmin [ np . logical_and ( env . tmeMMM . index < year , env . tmeMMM . index >= year - int ( self . constants . nn / coral . Csp ), ) ] m_min = mmm_min . mean ( axis = 0 ) s_min = mmm_min . std ( axis = 0 ) mmm_max = env . tmeMMMmax [ np . logical_and ( env . tmeMMM . index < year , env . tmeMMM . index >= year - int ( self . constants . nn / coral . Csp ), ) ] m_max = mmm_max . mean ( axis = 0 ) s_max = mmm_max . std ( axis = 0 ) else : mmm = env . temp_mmm [ np . logical_and ( env . temp_mmm . index < year , env . temp_mmm . index >= year - int ( self . constants . nn / coral . Csp ), ) ] m_min , m_max = mmm . mean ( axis = 0 ) s_min , s_max = mmm . std ( axis = 0 ) coral . Tlo = m_min - self . constants . k_var * s_min coral . Thi = m_max + self . constants . k_var * s_max def adapted_temp (): \"\"\"Adapted temperature response.\"\"\" def spec (): \"\"\"Specialisation term.\"\"\" return 4e-4 * np . exp ( - 0.33 * ( delta_temp - 10 )) response = - ( coral . temp - coral . Tlo ) * ( ( coral . temp - coral . Tlo ) ** 2 - delta_temp ** 2 ) temp_cr = coral . Tlo - ( 1 / np . sqrt ( 3 )) * delta_temp try : if self . constants . tme : response [ coral . temp <= temp_cr ] = - ( ( 2 / ( 3 * np . sqrt ( 3 ))) * delta_temp [ coral . temp <= temp_cr ] ** 3 ) else : response [ coral . temp <= temp_cr ] = - ( ( 2 / ( 3 * np . sqrt ( 3 ))) * delta_temp ** 3 ) except TypeError : if coral . temp <= temp_cr : response = ( 2 / ( 3 * np . sqrt ( 3 ))) * delta_temp ** 3 return response * spec () def thermal_env (): \"\"\"Thermal envelope.\"\"\" return np . exp ( ( self . constants . Ea / self . constants . R ) * ( 1 / 300 - 1 / temp_opt ) ) # # parameter definitions thermal_acc () delta_temp = coral . Thi - coral . Tlo temp_opt = coral . Tlo + ( 1 / np . sqrt ( 3 )) * delta_temp # # calculations f1 = adapted_temp () f2 = thermal_env () self . ptd = f1 * f2","title":"thermal_dependency()"},{"location":"reference/bio_process/processes/#population-states","text":"","title":"Population states"},{"location":"reference/bio_process/processes/#src.core.bio_process.population_states.PopulationStates","text":"Bleaching response following the population dynamics.","title":"PopulationStates"},{"location":"reference/bio_process/processes/#src.core.bio_process.population_states.PopulationStates.__init__","text":"Population dynamics. :param dt: time step [yrs], defaults to one :type dt: float, optional Source code in src/core/bio_process/population_states.py def __init__ ( self , constants : Constants = Constants (), dt : Optional [ float ] = 1 ): \"\"\"Population dynamics. :param dt: time step [yrs], defaults to one :type dt: float, optional \"\"\" self . dt = dt self . constants = constants","title":"__init__()"},{"location":"reference/bio_process/processes/#src.core.bio_process.population_states.PopulationStates.pop_states_t","text":"Population dynamics over time. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/population_states.py def pop_states_t ( self , coral : Coral ): \"\"\"Population dynamics over time. :param coral: coral animal :type coral: Coral \"\"\" _reshape = RESHAPE () coral . pop_states = np . zeros (( * _reshape . spacetime , 4 )) for n in range ( _reshape . time ): photosynthesis = np . zeros ( _reshape . space ) photosynthesis [ coral . cover > 0.0 ] = coral . photo_rate [ coral . cover > 0.0 , n ] # 21_09 have changed coral.cover>0 to .0. coral . pop_states [:, n , :] = self . pop_states_xy ( coral , photosynthesis ) coral . p0 [ coral . cover > 0.0 , :] = coral . pop_states [ coral . cover > 0.0 , n , :]","title":"pop_states_t()"},{"location":"reference/bio_process/processes/#src.core.bio_process.population_states.PopulationStates.pop_states_xy","text":"Population dynamics over space. :param coral: coral animal :param ps: photosynthetic rate :type coral: Coral :type ps: numpy.ndarray Source code in src/core/bio_process/population_states.py def pop_states_xy ( self , coral : Coral , ps ): \"\"\"Population dynamics over space. :param coral: coral animal :param ps: photosynthetic rate :type coral: Coral :type ps: numpy.ndarray \"\"\" p = np . zeros (( RESHAPE () . space , 4 )) # # calculations # growing conditions # > bleached pop. # ps>0. here represents ps>tsh that is the value of the bleaching treshold light and 1. where 1.0 is a number, not column reference p [ ps > 0.0 , 3 ] = coral . p0 [ ps > 0.0 , 3 ] / ( 1 + self . dt * ( 8.0 * self . constants . r_recovery * ps [ ps > 0.0 ] / coral . Csp + self . constants . r_mortality * coral . Csp ) ) # > pale pop. p [ ps > 0.0 , 2 ] = ( coral . p0 [ ps > 0.0 , 2 ] + ( 8.0 * self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] / coral . Csp ) * p [ ps > 0.0 , 3 ] ) / ( 1.0 + self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp ) # > recovering pop. p [ ps > 0.0 , 1 ] = ( coral . p0 [ ps > 0.0 , 1 ] + self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp * p [ ps > 0.0 , 2 ] ) / ( 1.0 + 0.5 * self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp ) # > healthy pop. a = ( self . dt * self . constants . r_growth * ps [ ps > 0.0 ] * coral . Csp / coral . cover [ ps > 0.0 ] ) b = 1.0 - self . dt * self . constants . r_growth * ps [ ps > 0.0 ] * coral . Csp * ( 1.0 - p [ ps > 0.0 , 1 :] . sum ( axis = 1 ) / coral . cover [ ps > 0.0 ] ) c = - ( coral . p0 [ ps > 0.0 , 0 ] + 0.5 * self . dt * self . constants . r_recovery * ps [ ps > 0.0 ] * coral . Csp * p [ ps > 0.0 , 1 ] ) p [ ps > 0.0 , 0 ] = ( - b + np . sqrt ( b ** 2 - 4.0 * a * c )) / ( 2.0 * a ) # bleaching conditions # > healthy pop. p [ ps <= 0.0 , 0 ] = coral . p0 [ ps <= 0.0 , 0 ] / ( 1.0 - self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # > recovering pop. p [ ps <= 0.0 , 1 ] = coral . p0 [ ps <= 0.0 , 1 ] / ( 1.0 - self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # > pale pop. p [ ps <= 0.0 , 2 ] = ( coral . p0 [ ps <= 0.0 , 2 ] - self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp * ( p [ ps <= 0.0 , 0 ] + p [ ps <= 0.0 , 1 ]) ) / ( 1.0 - 0.5 * self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # > bleached pop. p [ ps <= 0.0 , 3 ] = ( coral . p0 [ ps <= 0.0 , 3 ] - 0.5 * self . dt * self . constants . r_bleaching * ps [ ps <= 0 ] * coral . Csp * p [ ps <= 0.0 , 2 ] ) / ( 1.0 - 0.25 * self . dt * self . constants . r_bleaching * ps [ ps <= 0.0 ] * coral . Csp ) # # check on carrying capacity if any ( p . sum ( axis = 1 ) > 1.0001 * coral . cover ): slot_1 = np . arange ( len ( coral . cover ))[ p . sum ( axis = 1 ) > 1.0001 * coral . cover ] slot_2 = p [ p . sum ( axis = 1 ) > 1.0001 * coral . cover ] slot_3 = coral . cover [ p . sum ( axis = 1 ) > 1.0001 * coral . cover ] print ( f \"WARNING: Total population than carrying capacity at { slot_1 } . \" f \" \\n\\t PT = { slot_2 } ; K = { slot_3 } \" ) # # output return p","title":"pop_states_xy()"},{"location":"reference/bio_process/processes/#recruitment","text":"","title":"Recruitment"},{"location":"reference/bio_process/processes/#src.core.bio_process.recruitment.Recruitment","text":"Recruitment dynamics.","title":"Recruitment"},{"location":"reference/bio_process/processes/#src.core.bio_process.recruitment.Recruitment.recruited","text":"Determination of recruitment. :param potential: recruitment potential :param averaged_healthy_pop: model domain averaged healthy population :param cover_real: real coral cover :param cover_potential: potential coral cover :type potential: float :type averaged_healthy_pop: float :type cover_real: float :type cover_potential: float Source code in src/core/bio_process/recruitment.py @staticmethod def recruited ( potential , averaged_healthy_pop , cover_real , cover_potential ): \"\"\"Determination of recruitment. :param potential: recruitment potential :param averaged_healthy_pop: model domain averaged healthy population :param cover_real: real coral cover :param cover_potential: potential coral cover :type potential: float :type averaged_healthy_pop: float :type cover_real: float :type cover_potential: float \"\"\" return potential * averaged_healthy_pop * ( 1 - cover_real / cover_potential )","title":"recruited()"},{"location":"reference/bio_process/processes/#src.core.bio_process.recruitment.Recruitment.spawning","text":"Contribution due to mass coral spawning. :param coral: coral animal :param param: parameter type to which the spawning is added :type coral: Coral :type param: str Source code in src/core/bio_process/recruitment.py def spawning ( self , coral : Coral , param ): \"\"\"Contribution due to mass coral spawning. :param coral: coral animal :param param: parameter type to which the spawning is added :type coral: Coral :type param: str \"\"\" # # input check params = ( \"P\" , \"V\" ) if param not in params : msg = f \" { param } not in { params } .\" raise ValueError ( msg ) # # calculations # potential power = 2 if param == \"P\" else 3 potential = ( self . constants . prob_settle * self . constants . no_larvae * self . constants . d_larvae ** power ) # recruitment averaged_healthy_pop = coral . pop_states [:, - 1 , 0 ] . mean () # living cover living_cover = RESHAPE () . matrix2array ( coral . living_cover , \"space\" ) recruited = CoralOnly () . in_space ( coral = coral , function = self . recruited , args = ( potential , averaged_healthy_pop , living_cover , coral . cover ), ) # # output return recruited","title":"spawning()"},{"location":"reference/bio_process/processes/#src.core.bio_process.recruitment.Recruitment.update","text":"Update coral cover / volume after spawning event. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/recruitment.py def update ( self , coral : Coral ): \"\"\"Update coral cover / volume after spawning event. :param coral: coral animal :type coral: Coral \"\"\" coral . p0 [:, 0 ] += Recruitment . spawning ( self , coral , \"P\" ) coral . update_coral_volume ( coral . volume + Recruitment . spawning ( self , coral , \"V\" ))","title":"update()"},{"location":"reference/bio_process/processes/#temperature","text":"","title":"Temperature"},{"location":"reference/bio_process/processes/#src.core.bio_process.temperature.Temperature","text":"","title":"Temperature"},{"location":"reference/bio_process/processes/#src.core.bio_process.temperature.Temperature.__init__","text":"Thermal micro-environment.","title":"__init__()"},{"location":"reference/bio_process/processes/#src.core.bio_process.temperature.Temperature.__init__--parameters","text":"temperature : numeric Temperature of water [K]. Source code in src/core/bio_process/temperature.py def __init__ ( self , temperature , constants : Constants = Constants ()): \"\"\" Thermal micro-environment. Parameters ---------- temperature : numeric Temperature of water [K]. \"\"\" self . T = RESHAPE () . variable2matrix ( temperature , \"time\" ) self . constants = constants","title":"Parameters"},{"location":"reference/bio_process/processes/#src.core.bio_process.temperature.Temperature.coral_temperature","text":"Coral temperature. :param coral: coral animal :type coral: Coral Source code in src/core/bio_process/temperature.py def coral_temperature ( self , coral : Coral ): \"\"\"Coral temperature. :param coral: coral animal :type coral: Coral \"\"\" if self . constants . tme : delta_t = RESHAPE () . variable2matrix ( coral . delta_t , \"space\" ) coral . dTc = ( ( delta_t * self . constants . ap ) / ( self . constants . k * self . constants . K0 ) * coral . light ) coral . temp = self . T + coral . dTc else : coral . temp = self . T","title":"coral_temperature()"},{"location":"reference/common/common/","text":"Common classes for the NBSDynamics package. \u00b6 Constants \u00b6 Constants pydantic-model \u00b6 Object containing all constants used in coral_model simulations. check_processes ( values : dict ) -> dict classmethod \u00b6 Validates the input values so that the processes are compatible between themselves. Parameters: Name Type Description Default values dict Dictionary of values already validated individually. required Returns: Type Description dict dict: Dictionary of validated values as a whole. Source code in src/core/common/constants.py @root_validator @classmethod def check_processes ( cls , values : dict ) -> dict : \"\"\" Validates the input values so that the processes are compatible between themselves. Args: values (dict): Dictionary of values already validated individually. Returns: dict: Dictionary of validated values as a whole. \"\"\" if not values [ \"pfd\" ]: if values [ \"fme\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Flow micro-environment (FME) not possible \" \"when photosynthetic flow dependency (PFD) is disabled.\" ) values [ \"fme\" ] = False values [ \"tme\" ] = False else : if not values [ \"fme\" ]: if values [ \"tme\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Thermal micro-environment (TME) not possible \" \"when flow micro-environment is disabled.\" ) values [ \"tme\" ] = False if values [ \"tme\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Thermal micro-environment not fully implemented yet.\" ) if not values [ \"pfd\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Exclusion of photosynthetic flow dependency not fully implemented yet.\" ) return values correct_values ( self ) \u00b6 Corrects values that require extra operations, such as theta_max and prop_space. Source code in src/core/common/constants.py def correct_values ( self ): \"\"\" Corrects values that require extra operations, such as theta_max and prop_space. \"\"\" self . theta_max *= np . pi self . prop_space /= np . sqrt ( 2.0 ) from_input_file ( input_file : Path ) classmethod \u00b6 Generates a 'Constants' class based on the defined parameters in the input_file. Parameters: Name Type Description Default input_file Path Path to the constants input (.txt) file. required Source code in src/core/common/constants.py @classmethod def from_input_file ( cls , input_file : Path ): \"\"\" Generates a 'Constants' class based on the defined parameters in the input_file. Args: input_file (Path): Path to the constants input (.txt) file. \"\"\" def split_line ( line : str ): s_line = line . split ( \"=\" ) if len ( s_line ) <= 1 : raise ValueError return s_line [ 0 ] . strip (), s_line [ 1 ] . strip () def format_line ( line : str ) -> str : return split_line ( line . split ( \"#\" )[ 0 ]) def normalize_line ( line : str ) -> str : return line . strip () input_lines = [ format_line ( n_line ) for line in input_file . read_text () . splitlines ( keepends = False ) if line and not ( n_line := normalize_line ( line )) . startswith ( \"#\" ) ] cls_constants = cls ( ** dict ( input_lines )) cls_constants . correct_values () return cls_constants validate_scientific_int_value ( v ) -> int classmethod \u00b6 Validates the parameters that can be provided with scientific notation. Parameters: Name Type Description Default v Any Scientific value to validate. required Returns: Type Description int int: Validated value as integer. Source code in src/core/common/constants.py @validator ( \"maxiter_k\" , \"maxiter_aw\" , pre = True , always = True ) @classmethod def validate_scientific_int_value ( cls , v ) -> int : \"\"\" Validates the parameters that can be provided with scientific notation. Args: v (Any): Scientific value to validate. Returns: int: Validated value as integer. \"\"\" if isinstance ( v , int ): return v if isinstance ( v , float ): return int ( v ) if isinstance ( v , str ): return int ( float ( v )) raise NotImplementedError ( f \"No converter available for { type ( v ) } .\" ) Environment \u00b6 coral_mostoel - environment @author: Gijs G. Hendrickx @contributor: Peter M.J. Herman Environment pydantic-model \u00b6 check_dates ( v : Optional [ pandas . core . frame . DataFrame ], values : dict ) -> DataFrame classmethod \u00b6 Validates the dates value (post-process). Parameters: Name Type Description Default v Optional[pandas.core.frame.DataFrame] Value pre-validated for dates (if any). required values dict Dictionary containing the rest of values given to initialize 'Environment'. required Returns: Type Description DataFrame pd.DataFrame: Validated dates value. Source code in src/core/common/environment.py @validator ( \"dates\" , always = True , pre = False ) @classmethod def check_dates ( cls , v : Optional [ pd . DataFrame ], values : dict ) -> pd . DataFrame : \"\"\" Validates the dates value (post-process). Args: v (Optional[pd.DataFrame]): Value pre-validated for dates (if any). values (dict): Dictionary containing the rest of values given to initialize 'Environment'. Returns: pd.DataFrame: Validated dates value. \"\"\" # Validate dates have values. if isinstance ( v , pd . DataFrame ): return v light_value : pd . DataFrame = values . get ( \"light\" , None ) if light_value is not None : # TODO: Check column name of light-file return light_value . reset_index () . drop ( \"light\" , axis = 1 ) temp_value : pd . DataFrame = values . get ( \"temperature\" , None ) if temp_value is not None : return temp_value . reset_index () . drop ( \"sst\" , axis = 1 ) return None get_dates ( self ) -> Iterable [ datetime . datetime ] \u00b6 Just a shortcut being used in some occasions to get the datetime series array. Exceptions: Type Description ValueError When no dates could be set for the 'Environment'. Returns: Type Description Iterable[datetime.datetime] pd.Series[datetime]: Collection of timeseries stored in Environment.dates Source code in src/core/common/environment.py def get_dates ( self ) -> Iterable [ datetime ]: \"\"\" Just a shortcut being used in some occasions to get the datetime series array. Raises: ValueError: When no dates could be set for the 'Environment'. Returns: pd.Series[datetime]: Collection of timeseries stored in Environment.dates \"\"\" if self . dates is None : raise ValueError ( \"No values were assigned to dates.\" ) return pd . to_datetime ( self . dates [ \"date\" ]) prevalidate_dates ( value : Union [ pandas . core . frame . DataFrame , Iterable [ Union [ str , datetime . datetime ]]]) -> DataFrame classmethod \u00b6 Prevalidates the the input value given for the 'dates' parameter transforming it into a valid 'Environment' attribute. Parameters: Name Type Description Default value Union[pandas.core.frame.DataFrame, Iterable[Union[str, datetime.datetime]]] Value assigned to the attribute. required Exceptions: Type Description NotImplementedError When the provided value is not supported. Returns: Type Description DataFrame pd.DataFrame: Validated value. Source code in src/core/common/environment.py @validator ( \"dates\" , pre = True ) @classmethod def prevalidate_dates ( cls , value : Union [ pd . DataFrame , Iterable [ Union [ str , datetime ]]] ) -> pd . DataFrame : \"\"\" Prevalidates the the input value given for the 'dates' parameter transforming it into a valid 'Environment' attribute. Args: value (Union[pd.DataFrame, Iterable[Union[str, datetime]]]): Value assigned to the attribute. Raises: NotImplementedError: When the provided value is not supported. Returns: pd.DataFrame: Validated value. \"\"\" if isinstance ( value , pd . DataFrame ): return value if isinstance ( value , Iterable ): return cls . get_dates_dataframe ( value [ 0 ], value [ - 1 ]) raise NotImplementedError ( f \"Validator not available for type { type ( value ) } \" ) set_dates ( self , start_date : Union [ str , datetime . datetime ], end_date : Union [ str , datetime . datetime ]) \u00b6 Set dates manually, ignoring possible dates in environmental time-series. Parameters: Name Type Description Default start_date Union[str, datetime.datetime] Start of the range dates. required end_date Union[str, datetime.datetime] End of the range dates. required Source code in src/core/common/environment.py def set_dates ( self , start_date : Union [ str , datetime ], end_date : Union [ str , datetime ] ): \"\"\" Set dates manually, ignoring possible dates in environmental time-series. Args: start_date (Union[str, datetime]): Start of the range dates. end_date (Union[str, datetime]): End of the range dates. \"\"\" self . dates = self . get_dates_dataframe ( start_date , end_date ) set_parameter_values ( self , parameter : str , value : Union [ float , list , tuple , numpy . ndarray , pandas . core . frame . DataFrame ], pre_date : Optional [ int ] = None ) \u00b6 Set the time-series data to a time-series, or a value. In case :param value: is not iterable, the :param parameter: is assumed to be constant over time. In case :param value: is iterable, make sure its length complies with the simulation length. Included parameters: light : incoming light-intensity [umol photons m-2 s-1] LAC / light_attenuation : light attenuation coefficient [m-1] temperature : sea surface temperature [K] aragonite : aragonite saturation state [-] storm : storm category, annually [-] Parameters: Name Type Description Default parameter str Parameter to be set. required value Union[float, list, tuple, numpy.ndarray, pandas.core.frame.DataFrame] New value for the parameter. required pre_date Optional[int] Time-series start before simulation dates [yrs]. Defaults to None. None Source code in src/core/common/environment.py def set_parameter_values ( self , parameter : str , value : EnvironmentValue , pre_date : Optional [ int ] = None ): \"\"\" Set the time-series data to a time-series, or a value. In case :param value: is not iterable, the :param parameter: is assumed to be constant over time. In case :param value: is iterable, make sure its length complies with the simulation length. Included parameters: light : incoming light-intensity [umol photons m-2 s-1] LAC / light_attenuation : light attenuation coefficient [m-1] temperature : sea surface temperature [K] aragonite : aragonite saturation state [-] storm : storm category, annually [-] Args: parameter (str): Parameter to be set. value (EnvironmentValue): New value for the parameter. pre_date (Optional[int], optional): Time-series start before simulation dates [yrs]. Defaults to None. \"\"\" def set_value ( val ): \"\"\"Function to set value.\"\"\" simple_dates = self . get_dates () if pre_date is None : return pd . DataFrame ({ parameter : val }, index = simple_dates ) dates = pd . date_range ( simple_dates . iloc [ 0 ] - pd . DateOffset ( years = pre_date ), simple_dates . iloc [ - 1 ], freq = \"D\" , ) return pd . DataFrame ({ parameter : val }, index = dates ) if self . dates is None : msg = ( f \"No dates are defined. \" f \"Please, first specify the dates before setting the time-series of { parameter } ; \" f 'or make use of the \"from_file\"-method.' ) raise TypeError ( msg ) if parameter == \"LAC\" : parameter = \"light_attenuation\" daily_params = ( \"light\" , \"light_attenuation\" , \"temperature\" , \"aragonite\" ) if parameter in daily_params : setattr ( self , parameter , set_value ( value )) elif parameter == \"storm\" : years = set ( self . get_dates () . dt . year ) self . storm_category = pd . DataFrame ( data = value , index = years ) else : msg = f \"Entered parameter ( { parameter } ) not included. See documentation.\" raise ValueError ( msg ) temp_celsius : DataFrame property readonly \u00b6 Gets the temperature property in Celsius. Returns: Type Description DataFrame pd.DataFrame: value representation. temp_kelvin : DataFrame property readonly \u00b6 Gets the temperature property in Kelvin. Returns: Type Description DataFrame pd.DataFrame: value representation. temp_mmm : DataFrame property readonly \u00b6 Temperature in Monthly mean. Returns: Type Description DataFrame pd.DataFrame: value as a pandas DataFrame. validate_dataframe_or_path ( value : Union [ pandas . core . frame . DataFrame , pathlib . Path , str ]) -> DataFrame classmethod \u00b6 Transforms an input into the expected type for the parameter. In case a file it's provided it's content is converted into a pandas DataFrame. Parameters: Name Type Description Default value Union[pandas.core.frame.DataFrame, pathlib.Path, str] Value to be validated (Union[pd.DataFrame, Path, str]). required Exceptions: Type Description FileNotFoundError When the provided value is a non-existent Path. NotImplementedError When the provided value is not supported. Returns: Type Description DataFrame pd.DataFrame: Validated attribute value. Source code in src/core/common/environment.py @validator ( \"light\" , \"light_attenuation\" , \"temperature\" , \"aragonite\" , pre = True ) @classmethod def validate_dataframe_or_path ( cls , value : EnvInputAttr ) -> pd . DataFrame : \"\"\" Transforms an input into the expected type for the parameter. In case a file it's provided it's content is converted into a pandas DataFrame. Args: value (EnvInputAttr): Value to be validated (Union[pd.DataFrame, Path, str]). Raises: FileNotFoundError: When the provided value is a non-existent Path. NotImplementedError: When the provided value is not supported. Returns: pd.DataFrame: Validated attribute value. \"\"\" def read_index ( value_file : Path ) -> pd . DataFrame : \"\"\"Function applicable to time-series in Pandas.\"\"\" time_series = pd . read_csv ( value_file , sep = \" \\t \" ) if time_series . isnull () . values . any (): msg = f \"NaNs detected in time series { value_file } \" raise ValueError ( msg ) time_series [ \"date\" ] = pd . to_datetime ( time_series [ \"date\" ]) time_series . set_index ( \"date\" , inplace = True ) return time_series if isinstance ( value , pd . DataFrame ): return value if isinstance ( value , str ): value = Path ( value ) if isinstance ( value , Path ): if not value . is_file (): raise FileNotFoundError ( value ) return read_index ( value ) raise NotImplementedError ( f \"Validator not available for type { type ( value ) } \" ) validate_storm_category ( value : Union [ pandas . core . frame . DataFrame , pathlib . Path , str ]) -> DataFrame classmethod \u00b6 Transforms the input value given for the 'storm_category' parameter into a valid 'Environment' attribute. Parameters: Name Type Description Default value Union[pandas.core.frame.DataFrame, pathlib.Path, str] Value assigned to the attribute (Union[pd.DataFrame, Path, str]). required Exceptions: Type Description FileNotFoundError When the provided value is a non-existent Path. NotImplementedError When the provided value is not supported. Returns: Type Description DataFrame pd.DataFrame: Validated value. Source code in src/core/common/environment.py @validator ( \"storm_category\" , pre = True ) @classmethod def validate_storm_category ( cls , value : EnvInputAttr ) -> pd . DataFrame : \"\"\" Transforms the input value given for the 'storm_category' parameter into a valid 'Environment' attribute. Args: value (EnvInputAttr): Value assigned to the attribute (Union[pd.DataFrame, Path, str]). Raises: FileNotFoundError: When the provided value is a non-existent Path. NotImplementedError: When the provided value is not supported. Returns: pd.DataFrame: Validated value. \"\"\" if isinstance ( value , pd . DataFrame ): return value if isinstance ( value , str ): value = Path ( value ) if isinstance ( value , Path ): if not value . is_file (): raise FileNotFoundError ( value ) csv_values = pd . read_csv ( value , sep = \" \\t \" ) csv_values . set_index ( \"year\" , inplace = True ) return csv_values raise NotImplementedError ( f \"Validator not available for type { type ( value ) } \" ) SpaceTime \u00b6 coral_model - utils @author: Gijs G. Hendrickx @contributor: Peter M.J. Herman DataReshape \u00b6 Reshape data to create a spacetime matrix. dimension_value ( self , variable : Union [ list , tuple , numpy . ndarray ], dimension : str ) \u00b6 Check consistency between variable's dimensions and the defined spacetime dimensions. :param variable: variable to be checked :param dimension: dimension under consideration :type variable: list, tuple, numpy.ndarray :type dimension: str Source code in src/core/common/space_time.py def dimension_value ( self , variable : Union [ list , tuple , np . ndarray ], dimension : str ): \"\"\"Check consistency between variable's dimensions and the defined spacetime dimensions. :param variable: variable to be checked :param dimension: dimension under consideration :type variable: list, tuple, numpy.ndarray :type dimension: str \"\"\" try : _ = len ( variable ) except TypeError : variable = [ variable ] if not len ( variable ) == getattr ( self , dimension ): msg = f \"Incorrect variable size, { len ( variable ) } =/= { getattr ( self , dimension ) } .\" raise ValueError ( msg ) matrix2array ( self , matrix : ndarray , dimension : str , conversion : Optional [ str ] = None ) \u00b6 Transform matrix to array. :param matrix: variable as matrix in spacetime :param dimension: dimension to convert matrix to :param conversion: how to convert the matrix to an array, defaults to None None : take the last value 'mean' : take the mean value 'max' : take the maximum value 'min' : take the minimum value 'sum' : take the summation :type matrix: numpy.ndarray :type dimension: str :type conversion: None, str, optional :return: variable as array :rtype: numpy.ndarray Source code in src/core/common/space_time.py def matrix2array ( self , matrix : np . ndarray , dimension : str , conversion : Optional [ str ] = None ): \"\"\"Transform matrix to array. :param matrix: variable as matrix in spacetime :param dimension: dimension to convert matrix to :param conversion: how to convert the matrix to an array, defaults to None None : take the last value 'mean' : take the mean value 'max' : take the maximum value 'min' : take the minimum value 'sum' : take the summation :type matrix: numpy.ndarray :type dimension: str :type conversion: None, str, optional :return: variable as array :rtype: numpy.ndarray \"\"\" # # input check # dimension-type dimensions = ( \"space\" , \"time\" ) if dimension not in dimensions : msg = f \" { dimension } not in { dimensions } .\" raise ValueError ( msg ) # input as numpy.array matrix = np . array ( matrix ) # dimension-value if ( not matrix . shape == self . spacetime and not matrix . shape [: 2 ] == self . spacetime ): msg = ( f \"Matrix-shape does not correspond with spacetime-dimensions:\" f \" \\n { matrix . shape } =/= { self . spacetime } \" ) raise ValueError ( msg ) # conversion-strategy conversions = ( None , \"mean\" , \"max\" , \"min\" , \"sum\" ) if conversion not in conversions : msg = f \" { conversion } not in { conversions } .\" raise ValueError ( msg ) # # transformation # last position if conversion is None : if dimension == \"space\" : return matrix [:, - 1 ] elif dimension == \"time\" : return matrix [ - 1 , :] # conversion if dimension == \"space\" : return getattr ( matrix , conversion )( axis = 1 ) elif dimension == \"time\" : return getattr ( matrix , conversion )( axis = 0 ) variable2array ( variable : Union [ float , int , list , numpy . ndarray ]) staticmethod \u00b6 \"Transform variable to numpy.array (if float or string). :param variable: variable to be transformed :type variable: float, int, list, numpy.ndarray :return: variable as array :rtype: numpy.ndarray Source code in src/core/common/space_time.py @staticmethod def variable2array ( variable : Union [ float , int , list , np . ndarray ]): \"\"\" \"Transform variable to numpy.array (if float or string). :param variable: variable to be transformed :type variable: float, int, list, numpy.ndarray :return: variable as array :rtype: numpy.ndarray \"\"\" if isinstance ( variable , str ): msg = f \"Variable cannot be of { type ( variable ) } .\" raise NotImplementedError ( msg ) elif isinstance ( variable , ( float , int )): return np . array ([ float ( variable )]) elif isinstance ( variable , ( list , tuple )): return np . array ( variable ) elif isinstance ( variable , np . ndarray ) and not variable . shape : return np . array ([ variable ]) return variable variable2matrix ( self , variable : Union [ float , int , list , Tuple , numpy . ndarray ], dimension : str ) \u00b6 Transform variable to matrix. :param variable: variable to be transformed :param dimension: dimension of :param variable: :type variable: float, int, list, tuple, numpy.ndarray :type dimension: str :return: variable as matrix in space-time :rtype: numpy.ndarray Source code in src/core/common/space_time.py def variable2matrix ( self , variable : Union [ float , int , list , Tuple , np . ndarray ], dimension : str ): \"\"\"Transform variable to matrix. :param variable: variable to be transformed :param dimension: dimension of :param variable: :type variable: float, int, list, tuple, numpy.ndarray :type dimension: str :return: variable as matrix in space-time :rtype: numpy.ndarray \"\"\" # # input check # dimension-type dimensions = ( \"space\" , \"time\" ) if dimension not in dimensions : msg = f \" { dimension } not in { dimensions } .\" raise ValueError ( msg ) # dimension-value variable = self . variable2array ( variable ) self . dimension_value ( variable , dimension ) # # transformation if dimension == \"space\" : return np . tile ( variable , ( self . time , 1 )) . transpose () elif dimension == \"time\" : return np . tile ( variable , ( self . space , 1 )) SpaceTime \u00b6 Spacetime-object, which validates the definition of the spacetime dimensions. __init__ ( self , spacetime : Optional [ Tuple ] = None ) special \u00b6 :param spacetime: spacetime dimensions, defaults to None :type spacetime: None, tuple, optional Source code in src/core/common/space_time.py def __init__ ( self , spacetime : Optional [ Tuple ] = None ): \"\"\" :param spacetime: spacetime dimensions, defaults to None :type spacetime: None, tuple, optional \"\"\" if spacetime is not None : self . spacetime = spacetime self . set_coral_only ( self . spacetime ) __repr__ ( self ) special \u00b6 Development representation. Source code in src/core/common/space_time.py def __repr__ ( self ): \"\"\"Development representation.\"\"\" return f \"SpaceTime( { self . __spacetime } )\" __str__ ( self ) special \u00b6 Print representation. Source code in src/core/common/space_time.py def __str__ ( self ): \"\"\"Print representation.\"\"\" return str ( self . spacetime ) set_coral_only ( self , spacetime : Tuple ) \u00b6 Automatically set the spacetime dimensions for the CoralOnly-class. :param spacetime: spacetime dimension :type spacetime: tuple Source code in src/core/common/space_time.py def set_coral_only ( self , spacetime : Tuple ): \"\"\"Automatically set the spacetime dimensions for the CoralOnly-class. :param spacetime: spacetime dimension :type spacetime: tuple \"\"\" CoralOnly . spacetime = spacetime space : int property writable \u00b6 Space dimension. :rtype: int spacetime property writable \u00b6 Spacetime dimensions. :rtype: tuple time : int property writable \u00b6 Time dimension. :rtype: int time_series_year ( time_series : DataFrame , year : int ) \u00b6 Extract a section of the time-series based on the year. :param time_series: time-series to be extracted :param year: year to be extracted :type time_series: pandas.DataFrame :type year: int Source code in src/core/common/space_time.py def time_series_year ( time_series : DataFrame , year : int ): \"\"\"Extract a section of the time-series based on the year. :param time_series: time-series to be extracted :param year: year to be extracted :type time_series: pandas.DataFrame :type year: int \"\"\" return time_series [ time_series . index . year == year ] . values . transpose ()[ 0 ] Singletons \u00b6 This file is intended to contain all the common classes used as unique object throughout the NBSDynamics project. Although these classes are defined elsewhere, here we implement them as singletons. RESHAPE \u00b6 DataReshape Singleton. Singleton \u00b6 Singleton class representing the design pattern. This class can be used for concepts that are not meant to change state during a simulation such as DataReshape, represented by RESHAPE. __new__ ( cls , * args , ** kwargs ) special staticmethod \u00b6 Create and return a new object. See help(type) for accurate signature. Source code in src/core/common/singletons.py def __new__ ( cls , * args , ** kwargs ): if not isinstance ( cls . _instance , cls ): cls . _instance = object . __new__ ( cls , * args , ** kwargs ) return cls . _instance","title":"Common"},{"location":"reference/common/common/#common-classes-for-the-nbsdynamics-package","text":"","title":"Common classes for the NBSDynamics package."},{"location":"reference/common/common/#constants","text":"","title":"Constants"},{"location":"reference/common/common/#src.core.common.constants.Constants","text":"Object containing all constants used in coral_model simulations.","title":"Constants"},{"location":"reference/common/common/#src.core.common.constants.Constants.check_processes","text":"Validates the input values so that the processes are compatible between themselves. Parameters: Name Type Description Default values dict Dictionary of values already validated individually. required Returns: Type Description dict dict: Dictionary of validated values as a whole. Source code in src/core/common/constants.py @root_validator @classmethod def check_processes ( cls , values : dict ) -> dict : \"\"\" Validates the input values so that the processes are compatible between themselves. Args: values (dict): Dictionary of values already validated individually. Returns: dict: Dictionary of validated values as a whole. \"\"\" if not values [ \"pfd\" ]: if values [ \"fme\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Flow micro-environment (FME) not possible \" \"when photosynthetic flow dependency (PFD) is disabled.\" ) values [ \"fme\" ] = False values [ \"tme\" ] = False else : if not values [ \"fme\" ]: if values [ \"tme\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Thermal micro-environment (TME) not possible \" \"when flow micro-environment is disabled.\" ) values [ \"tme\" ] = False if values [ \"tme\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Thermal micro-environment not fully implemented yet.\" ) if not values [ \"pfd\" ] and values [ \"warn_proc\" ]: print ( \"WARNING: Exclusion of photosynthetic flow dependency not fully implemented yet.\" ) return values","title":"check_processes()"},{"location":"reference/common/common/#src.core.common.constants.Constants.correct_values","text":"Corrects values that require extra operations, such as theta_max and prop_space. Source code in src/core/common/constants.py def correct_values ( self ): \"\"\" Corrects values that require extra operations, such as theta_max and prop_space. \"\"\" self . theta_max *= np . pi self . prop_space /= np . sqrt ( 2.0 )","title":"correct_values()"},{"location":"reference/common/common/#src.core.common.constants.Constants.from_input_file","text":"Generates a 'Constants' class based on the defined parameters in the input_file. Parameters: Name Type Description Default input_file Path Path to the constants input (.txt) file. required Source code in src/core/common/constants.py @classmethod def from_input_file ( cls , input_file : Path ): \"\"\" Generates a 'Constants' class based on the defined parameters in the input_file. Args: input_file (Path): Path to the constants input (.txt) file. \"\"\" def split_line ( line : str ): s_line = line . split ( \"=\" ) if len ( s_line ) <= 1 : raise ValueError return s_line [ 0 ] . strip (), s_line [ 1 ] . strip () def format_line ( line : str ) -> str : return split_line ( line . split ( \"#\" )[ 0 ]) def normalize_line ( line : str ) -> str : return line . strip () input_lines = [ format_line ( n_line ) for line in input_file . read_text () . splitlines ( keepends = False ) if line and not ( n_line := normalize_line ( line )) . startswith ( \"#\" ) ] cls_constants = cls ( ** dict ( input_lines )) cls_constants . correct_values () return cls_constants","title":"from_input_file()"},{"location":"reference/common/common/#src.core.common.constants.Constants.validate_scientific_int_value","text":"Validates the parameters that can be provided with scientific notation. Parameters: Name Type Description Default v Any Scientific value to validate. required Returns: Type Description int int: Validated value as integer. Source code in src/core/common/constants.py @validator ( \"maxiter_k\" , \"maxiter_aw\" , pre = True , always = True ) @classmethod def validate_scientific_int_value ( cls , v ) -> int : \"\"\" Validates the parameters that can be provided with scientific notation. Args: v (Any): Scientific value to validate. Returns: int: Validated value as integer. \"\"\" if isinstance ( v , int ): return v if isinstance ( v , float ): return int ( v ) if isinstance ( v , str ): return int ( float ( v )) raise NotImplementedError ( f \"No converter available for { type ( v ) } .\" )","title":"validate_scientific_int_value()"},{"location":"reference/common/common/#environment","text":"coral_mostoel - environment @author: Gijs G. Hendrickx @contributor: Peter M.J. Herman","title":"Environment"},{"location":"reference/common/common/#src.core.common.environment.Environment","text":"","title":"Environment"},{"location":"reference/common/common/#src.core.common.environment.Environment.check_dates","text":"Validates the dates value (post-process). Parameters: Name Type Description Default v Optional[pandas.core.frame.DataFrame] Value pre-validated for dates (if any). required values dict Dictionary containing the rest of values given to initialize 'Environment'. required Returns: Type Description DataFrame pd.DataFrame: Validated dates value. Source code in src/core/common/environment.py @validator ( \"dates\" , always = True , pre = False ) @classmethod def check_dates ( cls , v : Optional [ pd . DataFrame ], values : dict ) -> pd . DataFrame : \"\"\" Validates the dates value (post-process). Args: v (Optional[pd.DataFrame]): Value pre-validated for dates (if any). values (dict): Dictionary containing the rest of values given to initialize 'Environment'. Returns: pd.DataFrame: Validated dates value. \"\"\" # Validate dates have values. if isinstance ( v , pd . DataFrame ): return v light_value : pd . DataFrame = values . get ( \"light\" , None ) if light_value is not None : # TODO: Check column name of light-file return light_value . reset_index () . drop ( \"light\" , axis = 1 ) temp_value : pd . DataFrame = values . get ( \"temperature\" , None ) if temp_value is not None : return temp_value . reset_index () . drop ( \"sst\" , axis = 1 ) return None","title":"check_dates()"},{"location":"reference/common/common/#src.core.common.environment.Environment.get_dates","text":"Just a shortcut being used in some occasions to get the datetime series array. Exceptions: Type Description ValueError When no dates could be set for the 'Environment'. Returns: Type Description Iterable[datetime.datetime] pd.Series[datetime]: Collection of timeseries stored in Environment.dates Source code in src/core/common/environment.py def get_dates ( self ) -> Iterable [ datetime ]: \"\"\" Just a shortcut being used in some occasions to get the datetime series array. Raises: ValueError: When no dates could be set for the 'Environment'. Returns: pd.Series[datetime]: Collection of timeseries stored in Environment.dates \"\"\" if self . dates is None : raise ValueError ( \"No values were assigned to dates.\" ) return pd . to_datetime ( self . dates [ \"date\" ])","title":"get_dates()"},{"location":"reference/common/common/#src.core.common.environment.Environment.prevalidate_dates","text":"Prevalidates the the input value given for the 'dates' parameter transforming it into a valid 'Environment' attribute. Parameters: Name Type Description Default value Union[pandas.core.frame.DataFrame, Iterable[Union[str, datetime.datetime]]] Value assigned to the attribute. required Exceptions: Type Description NotImplementedError When the provided value is not supported. Returns: Type Description DataFrame pd.DataFrame: Validated value. Source code in src/core/common/environment.py @validator ( \"dates\" , pre = True ) @classmethod def prevalidate_dates ( cls , value : Union [ pd . DataFrame , Iterable [ Union [ str , datetime ]]] ) -> pd . DataFrame : \"\"\" Prevalidates the the input value given for the 'dates' parameter transforming it into a valid 'Environment' attribute. Args: value (Union[pd.DataFrame, Iterable[Union[str, datetime]]]): Value assigned to the attribute. Raises: NotImplementedError: When the provided value is not supported. Returns: pd.DataFrame: Validated value. \"\"\" if isinstance ( value , pd . DataFrame ): return value if isinstance ( value , Iterable ): return cls . get_dates_dataframe ( value [ 0 ], value [ - 1 ]) raise NotImplementedError ( f \"Validator not available for type { type ( value ) } \" )","title":"prevalidate_dates()"},{"location":"reference/common/common/#src.core.common.environment.Environment.set_dates","text":"Set dates manually, ignoring possible dates in environmental time-series. Parameters: Name Type Description Default start_date Union[str, datetime.datetime] Start of the range dates. required end_date Union[str, datetime.datetime] End of the range dates. required Source code in src/core/common/environment.py def set_dates ( self , start_date : Union [ str , datetime ], end_date : Union [ str , datetime ] ): \"\"\" Set dates manually, ignoring possible dates in environmental time-series. Args: start_date (Union[str, datetime]): Start of the range dates. end_date (Union[str, datetime]): End of the range dates. \"\"\" self . dates = self . get_dates_dataframe ( start_date , end_date )","title":"set_dates()"},{"location":"reference/common/common/#src.core.common.environment.Environment.set_parameter_values","text":"Set the time-series data to a time-series, or a value. In case :param value: is not iterable, the :param parameter: is assumed to be constant over time. In case :param value: is iterable, make sure its length complies with the simulation length. Included parameters: light : incoming light-intensity [umol photons m-2 s-1] LAC / light_attenuation : light attenuation coefficient [m-1] temperature : sea surface temperature [K] aragonite : aragonite saturation state [-] storm : storm category, annually [-] Parameters: Name Type Description Default parameter str Parameter to be set. required value Union[float, list, tuple, numpy.ndarray, pandas.core.frame.DataFrame] New value for the parameter. required pre_date Optional[int] Time-series start before simulation dates [yrs]. Defaults to None. None Source code in src/core/common/environment.py def set_parameter_values ( self , parameter : str , value : EnvironmentValue , pre_date : Optional [ int ] = None ): \"\"\" Set the time-series data to a time-series, or a value. In case :param value: is not iterable, the :param parameter: is assumed to be constant over time. In case :param value: is iterable, make sure its length complies with the simulation length. Included parameters: light : incoming light-intensity [umol photons m-2 s-1] LAC / light_attenuation : light attenuation coefficient [m-1] temperature : sea surface temperature [K] aragonite : aragonite saturation state [-] storm : storm category, annually [-] Args: parameter (str): Parameter to be set. value (EnvironmentValue): New value for the parameter. pre_date (Optional[int], optional): Time-series start before simulation dates [yrs]. Defaults to None. \"\"\" def set_value ( val ): \"\"\"Function to set value.\"\"\" simple_dates = self . get_dates () if pre_date is None : return pd . DataFrame ({ parameter : val }, index = simple_dates ) dates = pd . date_range ( simple_dates . iloc [ 0 ] - pd . DateOffset ( years = pre_date ), simple_dates . iloc [ - 1 ], freq = \"D\" , ) return pd . DataFrame ({ parameter : val }, index = dates ) if self . dates is None : msg = ( f \"No dates are defined. \" f \"Please, first specify the dates before setting the time-series of { parameter } ; \" f 'or make use of the \"from_file\"-method.' ) raise TypeError ( msg ) if parameter == \"LAC\" : parameter = \"light_attenuation\" daily_params = ( \"light\" , \"light_attenuation\" , \"temperature\" , \"aragonite\" ) if parameter in daily_params : setattr ( self , parameter , set_value ( value )) elif parameter == \"storm\" : years = set ( self . get_dates () . dt . year ) self . storm_category = pd . DataFrame ( data = value , index = years ) else : msg = f \"Entered parameter ( { parameter } ) not included. See documentation.\" raise ValueError ( msg )","title":"set_parameter_values()"},{"location":"reference/common/common/#src.core.common.environment.Environment.temp_celsius","text":"Gets the temperature property in Celsius. Returns: Type Description DataFrame pd.DataFrame: value representation.","title":"temp_celsius"},{"location":"reference/common/common/#src.core.common.environment.Environment.temp_kelvin","text":"Gets the temperature property in Kelvin. Returns: Type Description DataFrame pd.DataFrame: value representation.","title":"temp_kelvin"},{"location":"reference/common/common/#src.core.common.environment.Environment.temp_mmm","text":"Temperature in Monthly mean. Returns: Type Description DataFrame pd.DataFrame: value as a pandas DataFrame.","title":"temp_mmm"},{"location":"reference/common/common/#src.core.common.environment.Environment.validate_dataframe_or_path","text":"Transforms an input into the expected type for the parameter. In case a file it's provided it's content is converted into a pandas DataFrame. Parameters: Name Type Description Default value Union[pandas.core.frame.DataFrame, pathlib.Path, str] Value to be validated (Union[pd.DataFrame, Path, str]). required Exceptions: Type Description FileNotFoundError When the provided value is a non-existent Path. NotImplementedError When the provided value is not supported. Returns: Type Description DataFrame pd.DataFrame: Validated attribute value. Source code in src/core/common/environment.py @validator ( \"light\" , \"light_attenuation\" , \"temperature\" , \"aragonite\" , pre = True ) @classmethod def validate_dataframe_or_path ( cls , value : EnvInputAttr ) -> pd . DataFrame : \"\"\" Transforms an input into the expected type for the parameter. In case a file it's provided it's content is converted into a pandas DataFrame. Args: value (EnvInputAttr): Value to be validated (Union[pd.DataFrame, Path, str]). Raises: FileNotFoundError: When the provided value is a non-existent Path. NotImplementedError: When the provided value is not supported. Returns: pd.DataFrame: Validated attribute value. \"\"\" def read_index ( value_file : Path ) -> pd . DataFrame : \"\"\"Function applicable to time-series in Pandas.\"\"\" time_series = pd . read_csv ( value_file , sep = \" \\t \" ) if time_series . isnull () . values . any (): msg = f \"NaNs detected in time series { value_file } \" raise ValueError ( msg ) time_series [ \"date\" ] = pd . to_datetime ( time_series [ \"date\" ]) time_series . set_index ( \"date\" , inplace = True ) return time_series if isinstance ( value , pd . DataFrame ): return value if isinstance ( value , str ): value = Path ( value ) if isinstance ( value , Path ): if not value . is_file (): raise FileNotFoundError ( value ) return read_index ( value ) raise NotImplementedError ( f \"Validator not available for type { type ( value ) } \" )","title":"validate_dataframe_or_path()"},{"location":"reference/common/common/#src.core.common.environment.Environment.validate_storm_category","text":"Transforms the input value given for the 'storm_category' parameter into a valid 'Environment' attribute. Parameters: Name Type Description Default value Union[pandas.core.frame.DataFrame, pathlib.Path, str] Value assigned to the attribute (Union[pd.DataFrame, Path, str]). required Exceptions: Type Description FileNotFoundError When the provided value is a non-existent Path. NotImplementedError When the provided value is not supported. Returns: Type Description DataFrame pd.DataFrame: Validated value. Source code in src/core/common/environment.py @validator ( \"storm_category\" , pre = True ) @classmethod def validate_storm_category ( cls , value : EnvInputAttr ) -> pd . DataFrame : \"\"\" Transforms the input value given for the 'storm_category' parameter into a valid 'Environment' attribute. Args: value (EnvInputAttr): Value assigned to the attribute (Union[pd.DataFrame, Path, str]). Raises: FileNotFoundError: When the provided value is a non-existent Path. NotImplementedError: When the provided value is not supported. Returns: pd.DataFrame: Validated value. \"\"\" if isinstance ( value , pd . DataFrame ): return value if isinstance ( value , str ): value = Path ( value ) if isinstance ( value , Path ): if not value . is_file (): raise FileNotFoundError ( value ) csv_values = pd . read_csv ( value , sep = \" \\t \" ) csv_values . set_index ( \"year\" , inplace = True ) return csv_values raise NotImplementedError ( f \"Validator not available for type { type ( value ) } \" )","title":"validate_storm_category()"},{"location":"reference/common/common/#spacetime","text":"coral_model - utils @author: Gijs G. Hendrickx @contributor: Peter M.J. Herman","title":"SpaceTime"},{"location":"reference/common/common/#src.core.common.space_time.DataReshape","text":"Reshape data to create a spacetime matrix.","title":"DataReshape"},{"location":"reference/common/common/#src.core.common.space_time.DataReshape.dimension_value","text":"Check consistency between variable's dimensions and the defined spacetime dimensions. :param variable: variable to be checked :param dimension: dimension under consideration :type variable: list, tuple, numpy.ndarray :type dimension: str Source code in src/core/common/space_time.py def dimension_value ( self , variable : Union [ list , tuple , np . ndarray ], dimension : str ): \"\"\"Check consistency between variable's dimensions and the defined spacetime dimensions. :param variable: variable to be checked :param dimension: dimension under consideration :type variable: list, tuple, numpy.ndarray :type dimension: str \"\"\" try : _ = len ( variable ) except TypeError : variable = [ variable ] if not len ( variable ) == getattr ( self , dimension ): msg = f \"Incorrect variable size, { len ( variable ) } =/= { getattr ( self , dimension ) } .\" raise ValueError ( msg )","title":"dimension_value()"},{"location":"reference/common/common/#src.core.common.space_time.DataReshape.matrix2array","text":"Transform matrix to array. :param matrix: variable as matrix in spacetime :param dimension: dimension to convert matrix to :param conversion: how to convert the matrix to an array, defaults to None None : take the last value 'mean' : take the mean value 'max' : take the maximum value 'min' : take the minimum value 'sum' : take the summation :type matrix: numpy.ndarray :type dimension: str :type conversion: None, str, optional :return: variable as array :rtype: numpy.ndarray Source code in src/core/common/space_time.py def matrix2array ( self , matrix : np . ndarray , dimension : str , conversion : Optional [ str ] = None ): \"\"\"Transform matrix to array. :param matrix: variable as matrix in spacetime :param dimension: dimension to convert matrix to :param conversion: how to convert the matrix to an array, defaults to None None : take the last value 'mean' : take the mean value 'max' : take the maximum value 'min' : take the minimum value 'sum' : take the summation :type matrix: numpy.ndarray :type dimension: str :type conversion: None, str, optional :return: variable as array :rtype: numpy.ndarray \"\"\" # # input check # dimension-type dimensions = ( \"space\" , \"time\" ) if dimension not in dimensions : msg = f \" { dimension } not in { dimensions } .\" raise ValueError ( msg ) # input as numpy.array matrix = np . array ( matrix ) # dimension-value if ( not matrix . shape == self . spacetime and not matrix . shape [: 2 ] == self . spacetime ): msg = ( f \"Matrix-shape does not correspond with spacetime-dimensions:\" f \" \\n { matrix . shape } =/= { self . spacetime } \" ) raise ValueError ( msg ) # conversion-strategy conversions = ( None , \"mean\" , \"max\" , \"min\" , \"sum\" ) if conversion not in conversions : msg = f \" { conversion } not in { conversions } .\" raise ValueError ( msg ) # # transformation # last position if conversion is None : if dimension == \"space\" : return matrix [:, - 1 ] elif dimension == \"time\" : return matrix [ - 1 , :] # conversion if dimension == \"space\" : return getattr ( matrix , conversion )( axis = 1 ) elif dimension == \"time\" : return getattr ( matrix , conversion )( axis = 0 )","title":"matrix2array()"},{"location":"reference/common/common/#src.core.common.space_time.DataReshape.variable2array","text":"\"Transform variable to numpy.array (if float or string). :param variable: variable to be transformed :type variable: float, int, list, numpy.ndarray :return: variable as array :rtype: numpy.ndarray Source code in src/core/common/space_time.py @staticmethod def variable2array ( variable : Union [ float , int , list , np . ndarray ]): \"\"\" \"Transform variable to numpy.array (if float or string). :param variable: variable to be transformed :type variable: float, int, list, numpy.ndarray :return: variable as array :rtype: numpy.ndarray \"\"\" if isinstance ( variable , str ): msg = f \"Variable cannot be of { type ( variable ) } .\" raise NotImplementedError ( msg ) elif isinstance ( variable , ( float , int )): return np . array ([ float ( variable )]) elif isinstance ( variable , ( list , tuple )): return np . array ( variable ) elif isinstance ( variable , np . ndarray ) and not variable . shape : return np . array ([ variable ]) return variable","title":"variable2array()"},{"location":"reference/common/common/#src.core.common.space_time.DataReshape.variable2matrix","text":"Transform variable to matrix. :param variable: variable to be transformed :param dimension: dimension of :param variable: :type variable: float, int, list, tuple, numpy.ndarray :type dimension: str :return: variable as matrix in space-time :rtype: numpy.ndarray Source code in src/core/common/space_time.py def variable2matrix ( self , variable : Union [ float , int , list , Tuple , np . ndarray ], dimension : str ): \"\"\"Transform variable to matrix. :param variable: variable to be transformed :param dimension: dimension of :param variable: :type variable: float, int, list, tuple, numpy.ndarray :type dimension: str :return: variable as matrix in space-time :rtype: numpy.ndarray \"\"\" # # input check # dimension-type dimensions = ( \"space\" , \"time\" ) if dimension not in dimensions : msg = f \" { dimension } not in { dimensions } .\" raise ValueError ( msg ) # dimension-value variable = self . variable2array ( variable ) self . dimension_value ( variable , dimension ) # # transformation if dimension == \"space\" : return np . tile ( variable , ( self . time , 1 )) . transpose () elif dimension == \"time\" : return np . tile ( variable , ( self . space , 1 ))","title":"variable2matrix()"},{"location":"reference/common/common/#src.core.common.space_time.SpaceTime","text":"Spacetime-object, which validates the definition of the spacetime dimensions.","title":"SpaceTime"},{"location":"reference/common/common/#src.core.common.space_time.SpaceTime.__init__","text":":param spacetime: spacetime dimensions, defaults to None :type spacetime: None, tuple, optional Source code in src/core/common/space_time.py def __init__ ( self , spacetime : Optional [ Tuple ] = None ): \"\"\" :param spacetime: spacetime dimensions, defaults to None :type spacetime: None, tuple, optional \"\"\" if spacetime is not None : self . spacetime = spacetime self . set_coral_only ( self . spacetime )","title":"__init__()"},{"location":"reference/common/common/#src.core.common.space_time.SpaceTime.__repr__","text":"Development representation. Source code in src/core/common/space_time.py def __repr__ ( self ): \"\"\"Development representation.\"\"\" return f \"SpaceTime( { self . __spacetime } )\"","title":"__repr__()"},{"location":"reference/common/common/#src.core.common.space_time.SpaceTime.__str__","text":"Print representation. Source code in src/core/common/space_time.py def __str__ ( self ): \"\"\"Print representation.\"\"\" return str ( self . spacetime )","title":"__str__()"},{"location":"reference/common/common/#src.core.common.space_time.SpaceTime.set_coral_only","text":"Automatically set the spacetime dimensions for the CoralOnly-class. :param spacetime: spacetime dimension :type spacetime: tuple Source code in src/core/common/space_time.py def set_coral_only ( self , spacetime : Tuple ): \"\"\"Automatically set the spacetime dimensions for the CoralOnly-class. :param spacetime: spacetime dimension :type spacetime: tuple \"\"\" CoralOnly . spacetime = spacetime","title":"set_coral_only()"},{"location":"reference/common/common/#src.core.common.space_time.SpaceTime.space","text":"Space dimension. :rtype: int","title":"space"},{"location":"reference/common/common/#src.core.common.space_time.SpaceTime.spacetime","text":"Spacetime dimensions. :rtype: tuple","title":"spacetime"},{"location":"reference/common/common/#src.core.common.space_time.SpaceTime.time","text":"Time dimension. :rtype: int","title":"time"},{"location":"reference/common/common/#src.core.common.space_time.time_series_year","text":"Extract a section of the time-series based on the year. :param time_series: time-series to be extracted :param year: year to be extracted :type time_series: pandas.DataFrame :type year: int Source code in src/core/common/space_time.py def time_series_year ( time_series : DataFrame , year : int ): \"\"\"Extract a section of the time-series based on the year. :param time_series: time-series to be extracted :param year: year to be extracted :type time_series: pandas.DataFrame :type year: int \"\"\" return time_series [ time_series . index . year == year ] . values . transpose ()[ 0 ]","title":"time_series_year()"},{"location":"reference/common/common/#singletons","text":"This file is intended to contain all the common classes used as unique object throughout the NBSDynamics project. Although these classes are defined elsewhere, here we implement them as singletons.","title":"Singletons"},{"location":"reference/common/common/#src.core.common.singletons.RESHAPE","text":"DataReshape Singleton.","title":"RESHAPE"},{"location":"reference/common/common/#src.core.common.singletons.Singleton","text":"Singleton class representing the design pattern. This class can be used for concepts that are not meant to change state during a simulation such as DataReshape, represented by RESHAPE.","title":"Singleton"},{"location":"reference/common/common/#src.core.common.singletons.Singleton.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in src/core/common/singletons.py def __new__ ( cls , * args , ** kwargs ): if not isinstance ( cls . _instance , cls ): cls . _instance = object . __new__ ( cls , * args , ** kwargs ) return cls . _instance","title":"__new__()"},{"location":"reference/coral/coral/","text":"Coral models for the NBSDynamics package. \u00b6 Coral Protocol \u00b6 CoralProtocol \u00b6 Protocol for all Corals to be used in the NBSDynamics Project. constants : Constants property readonly \u00b6 Constants associated to the Coral Model to be run. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description Constants Constants: Instance of constants. initiate_coral_morphology ( self , cover : Optional [ numpy . ndarray ]) \u00b6 Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Parameters: Name Type Description Default cover Optional[numpy.ndarray] Custom coral definition. required Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/coral/coral_protocol.py def initiate_coral_morphology ( self , cover : Optional [ np . ndarray ]): \"\"\" Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Args: cover (Optional[np.ndarray]): Custom coral definition. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError update_coral_morphology ( self , coral_volume : Union [ float , numpy . ndarray ], morphology_ratios : Dict [ str , Union [ float , numpy . ndarray ]]) \u00b6 Update the coral morphology based on updated coral volume and morphology ratios. Parameters: Name Type Description Default coral_volume Union[float, numpy.ndarray] Coral volume required morphology_ratios Dict[str, Union[float, numpy.ndarray]] Morphology ratios (rf, rp, rs, ..) required Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/coral/coral_protocol.py def update_coral_morphology ( self , coral_volume : Union [ float , np . ndarray ], morphology_ratios : Dict [ str , Union [ float , np . ndarray ]], ): \"\"\" Update the coral morphology based on updated coral volume and morphology ratios. Args: coral_volume (Union[float, np.ndarray]): Coral volume morphology_ratios (Dict[str, Union[float, np.ndarray]]): Morphology ratios (rf, rp, rs, ..) Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError Coral model \u00b6 Coral pydantic-model \u00b6 Implements the CoralProtocol . Coral object, representing one coral type. __repr__ ( self ) special \u00b6 Development representation. Source code in src/core/coral/coral_model.py def __repr__ ( self ): \"\"\"Development representation.\"\"\" return f \"Morphology( { self . dc } , { self . hc } , { self . bc } , { self . bc } , { self . ac } )\" __str__ ( self ) special \u00b6 Print representation. Source code in src/core/coral/coral_model.py def __str__ ( self ): \"\"\"Print representation.\"\"\" return ( f \"Coral morphology with: dc = { self . dc } m; hc = { self . hc } ;\" f \"bc = { self . bc } m; tc = { self . tc } m; ac = { self . ac } m\" ) ac_matrix property readonly \u00b6 self.RESHAPEd axial distance. as_vegetation_density property readonly \u00b6 Translation from coral morphology to (vegetation) density. bc_matrix property readonly \u00b6 self.RESHAPEd coral base diameter. cover property readonly \u00b6 Carrying capacity. dc_matrix property readonly \u00b6 self.RESHAPEd coral plate diameter. dc_rep property readonly \u00b6 Representative coral diameter; weighted average of base and plate diameters. dc_rep_matrix property readonly \u00b6 self.RESHAPEd representative coral diameter. hc_matrix property readonly \u00b6 self.RESHAPEd coral height. initiate_coral_morphology ( self , cover : Optional [ numpy . ndarray ] = None ) \u00b6 Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Parameters: Name Type Description Default cover Optional[numpy.ndarray] Custom coral definition. None Source code in src/core/coral/coral_model.py def initiate_coral_morphology ( self , cover : Optional [ np . ndarray ] = None ): \"\"\" Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Args: cover (Optional[np.ndarray]): Custom coral definition. \"\"\" _reshape = RESHAPE () if cover is not None : cover = _reshape . variable2array ( cover ) if not cover . shape [ 0 ] == _reshape . space : msg = f \"Spatial dimension of cover does not match: { cover . shape } =/= { _reshape . space } .\" raise ValueError ( msg ) else : cover = np . ones ( _reshape . space ) self . p0 = np . array ( [ cover , np . zeros ( cover . shape ), np . zeros ( cover . shape ), np . zeros ( cover . shape ), ] ) . transpose () self . dc = cover * self . dc self . hc = cover * self . hc self . bc = cover * self . bc self . tc = cover * self . tc self . ac = cover * self . ac living_cover property readonly \u00b6 Living coral cover based on population states. rf property readonly \u00b6 Form ratio: height-to-diameter ratio. rp property readonly \u00b6 Plate ratio: base-to-diameter ratio. rs property readonly \u00b6 Spacing ratio: diameter-to-axial distance ratio. tc_matrix property readonly \u00b6 self.RESHAPEd coral plate thickness. update_coral_morphology ( self , coral_volume : Union [ float , numpy . ndarray ], morphology_ratios : Dict [ str , Union [ float , numpy . ndarray ]]) \u00b6 Update the coral morphology based on updated coral volume and morphology ratios. Parameters: Name Type Description Default coral_volume Union[float, numpy.ndarray] Coral volume required morphology_ratios Dict[str, Union[float, numpy.ndarray]] Morphology ratios (rf, rp, rs, ..) required Source code in src/core/coral/coral_model.py def update_coral_morphology ( self , coral_volume : Union [ float , np . ndarray ], morphology_ratios : Dict [ str , Union [ float , np . ndarray ]], ): \"\"\" Update the coral morphology based on updated coral volume and morphology ratios. Args: coral_volume (Union[float, np.ndarray]): Coral volume morphology_ratios (Dict[str, Union[float, np.ndarray]]): Morphology ratios (rf, rp, rs, ..) \"\"\" rf = morphology_ratios [ \"rf\" ] rp = morphology_ratios [ \"rp\" ] rs = morphology_ratios [ \"rs\" ] def vc2dc ( coral_volume , rf , rp ): \"\"\"Coral volume to coral plate diameter.\"\"\" dc = (( 4.0 * coral_volume ) / ( np . pi * rf * rp * ( 1.0 + rp - rp ** 2 ))) ** ( 1.0 / 3.0 ) return dc def vc2hc ( coral_volume , rf , rp ): \"\"\"Coral volume to coral height.\"\"\" hc = ( ( 4.0 * coral_volume * rf ** 2 ) / ( np . pi * rp * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return hc def vc2bc ( coral_volume , rf , rp ): \"\"\"Coral volume > diameter of the base.\"\"\" bc = ( ( 4.0 * coral_volume * rp ** 2 ) / ( np . pi * rf * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return bc def vc2tc ( coral_volume , rf , rp ): \"\"\"Coral volume > thickness of the plate.\"\"\" tc = ( ( 4.0 * coral_volume * rf ** 2 * rp ** 2 ) / ( np . pi * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return tc def vc2ac ( coral_volume , rf , rp , rs ): \"\"\"Coral volume > axial distance.\"\"\" ac = ( 1.0 / rs ) * ( ( 4.0 * coral_volume ) / ( np . pi * rf * rp * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return ac # # update morphology self . dc = vc2dc ( coral_volume , rf , rp ) self . hc = vc2hc ( coral_volume , rf , rp ) self . bc = vc2bc ( coral_volume , rf , rp ) self . tc = vc2tc ( coral_volume , rf , rp ) self . ac = vc2ac ( coral_volume , rf , rp , rs ) update_coral_volume ( self , coral_volume : Union [ float , list , tuple , numpy . ndarray ]) \u00b6 Updates the coral morphology based on the given coral volume. Parameters: Name Type Description Default coral_volume Union[float, list, tuple, numpy.ndarray] New coral volume. required Source code in src/core/coral/coral_model.py def update_coral_volume ( self , coral_volume : CoralAttribute ): \"\"\" Updates the coral morphology based on the given coral volume. Args: coral_volume (CoralAttribute): New coral volume. \"\"\" # TODO what is the difference? And which volume does it call then? # TODO also function update morphology does not update coral volume self . update_coral_morphology ( coral_volume , dict ( rf = self . rf , rp = self . rp , rs = self . rs ) ) update_cover ( self , carrying_capacity : Union [ float , list , tuple , numpy . ndarray ]) \u00b6 Update cover value based on given parameters. Parameters: Name Type Description Default carrying_capacity Union[float, list, tuple, numpy.ndarray] Carrying capacity [m2 m-2]. required Source code in src/core/coral/coral_model.py def update_cover ( self , carrying_capacity : CoralAttribute ): \"\"\" Update cover value based on given parameters. Args: carrying_capacity (CoralAttribute): Carrying capacity [m2 m-2]. \"\"\" carrying_capacity = RESHAPE () . variable2array ( carrying_capacity ) if not self . volume . shape == carrying_capacity . shape : raise ValueError ( f \"Shapes do not match: \" f \" { self . volume . shape } =/= { carrying_capacity . shape } \" ) if sum ( self . volume [ carrying_capacity == 0.0 ]) > 0.0 : print ( f \"WARNING: Coral volume present where the carrying capacity is zero. This is unrealistic.\" ) self . _cover = carrying_capacity volume property readonly \u00b6 Coral volume. Coral only model \u00b6 CoralOnly \u00b6 Execute functions only in the presence of corals. in_space ( self , coral , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 ) -> ndarray \u00b6 Only execute the function when there is coral cover. Parameters: Name Type Description Default coral Coral Coral object. required function Callable Function to be executed. required args Tuple input arguments of the function. required no_cover_value Optional[float] Default value in absence of coral cover. Defaults to 0. 0 Exceptions: Type Description ValueError When sizes do not match. Returns: Type Description ndarray np.ndarray: Result of the coral function. Source code in src/core/coral/coral_only.py def in_space ( self , coral , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ) -> np . ndarray : \"\"\" Only execute the function when there is coral cover. Args: coral (Coral): Coral object. function (Callable): Function to be executed. args (Tuple): input arguments of the function. no_cover_value (Optional[float], optional): Default value in absence of coral cover. Defaults to 0. Raises: ValueError: When sizes do not match. Returns: np.ndarray: Result of the coral function. \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = np . repeat ( arg , self . space ) elif not len ( arg ) == self . space : msg = f \"Sizes do not match up, { len ( arg ) } =/= { self . space } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . space ) output [ coral . cover > 0 ] = function ( * [ arg [ coral . cover > 0 ] for arg in args ]) return output in_spacetime ( self , coral , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 ) \u00b6 Only execute the function when there is coral cover. :param coral: coral object :param function: function to be executed :param args: input arguments of the function :param no_cover_value: default value in absence of coral cover :type coral: Coral :type args: tuple :type no_cover_value: float, optional Source code in src/core/coral/coral_only.py def in_spacetime ( self , coral , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ): \"\"\"Only execute the function when there is coral cover. :param coral: coral object :param function: function to be executed :param args: input arguments of the function :param no_cover_value: default value in absence of coral cover :type coral: Coral :type args: tuple :type no_cover_value: float, optional \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = arg * np . ones ( self . spacetime ) elif arg . shape == coral . cover . shape : args [ i ] = np . tile ( arg , ( self . time , 1 )) . transpose () elif not arg . shape == self . spacetime : msg = f \"Sizes do not match up, { arg . shape } =/= { self . spacetime } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . spacetime ) output [ coral . cover > 0 ] = function ( * [ arg [ coral . cover > 0 ] for arg in args ]) return output space property readonly \u00b6 Space dimension. time property readonly \u00b6 Time dimension.","title":"Coral"},{"location":"reference/coral/coral/#coral-models-for-the-nbsdynamics-package","text":"","title":"Coral models for the NBSDynamics package."},{"location":"reference/coral/coral/#coral-protocol","text":"","title":"Coral Protocol"},{"location":"reference/coral/coral/#src.core.coral.coral_protocol.CoralProtocol","text":"Protocol for all Corals to be used in the NBSDynamics Project.","title":"CoralProtocol"},{"location":"reference/coral/coral/#src.core.coral.coral_protocol.CoralProtocol.constants","text":"Constants associated to the Coral Model to be run. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description Constants Constants: Instance of constants.","title":"constants"},{"location":"reference/coral/coral/#src.core.coral.coral_protocol.CoralProtocol.initiate_coral_morphology","text":"Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Parameters: Name Type Description Default cover Optional[numpy.ndarray] Custom coral definition. required Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/coral/coral_protocol.py def initiate_coral_morphology ( self , cover : Optional [ np . ndarray ]): \"\"\" Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Args: cover (Optional[np.ndarray]): Custom coral definition. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"initiate_coral_morphology()"},{"location":"reference/coral/coral/#src.core.coral.coral_protocol.CoralProtocol.update_coral_morphology","text":"Update the coral morphology based on updated coral volume and morphology ratios. Parameters: Name Type Description Default coral_volume Union[float, numpy.ndarray] Coral volume required morphology_ratios Dict[str, Union[float, numpy.ndarray]] Morphology ratios (rf, rp, rs, ..) required Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/coral/coral_protocol.py def update_coral_morphology ( self , coral_volume : Union [ float , np . ndarray ], morphology_ratios : Dict [ str , Union [ float , np . ndarray ]], ): \"\"\" Update the coral morphology based on updated coral volume and morphology ratios. Args: coral_volume (Union[float, np.ndarray]): Coral volume morphology_ratios (Dict[str, Union[float, np.ndarray]]): Morphology ratios (rf, rp, rs, ..) Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"update_coral_morphology()"},{"location":"reference/coral/coral/#coral-model","text":"","title":"Coral model"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral","text":"Implements the CoralProtocol . Coral object, representing one coral type.","title":"Coral"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.__repr__","text":"Development representation. Source code in src/core/coral/coral_model.py def __repr__ ( self ): \"\"\"Development representation.\"\"\" return f \"Morphology( { self . dc } , { self . hc } , { self . bc } , { self . bc } , { self . ac } )\"","title":"__repr__()"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.__str__","text":"Print representation. Source code in src/core/coral/coral_model.py def __str__ ( self ): \"\"\"Print representation.\"\"\" return ( f \"Coral morphology with: dc = { self . dc } m; hc = { self . hc } ;\" f \"bc = { self . bc } m; tc = { self . tc } m; ac = { self . ac } m\" )","title":"__str__()"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.ac_matrix","text":"self.RESHAPEd axial distance.","title":"ac_matrix"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.as_vegetation_density","text":"Translation from coral morphology to (vegetation) density.","title":"as_vegetation_density"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.bc_matrix","text":"self.RESHAPEd coral base diameter.","title":"bc_matrix"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.cover","text":"Carrying capacity.","title":"cover"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.dc_matrix","text":"self.RESHAPEd coral plate diameter.","title":"dc_matrix"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.dc_rep","text":"Representative coral diameter; weighted average of base and plate diameters.","title":"dc_rep"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.dc_rep_matrix","text":"self.RESHAPEd representative coral diameter.","title":"dc_rep_matrix"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.hc_matrix","text":"self.RESHAPEd coral height.","title":"hc_matrix"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.initiate_coral_morphology","text":"Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Parameters: Name Type Description Default cover Optional[numpy.ndarray] Custom coral definition. None Source code in src/core/coral/coral_model.py def initiate_coral_morphology ( self , cover : Optional [ np . ndarray ] = None ): \"\"\" Initiate the morphology based on the on set of morphological dimensions and the coral cover. This method contains a catch that it can only be used to initiate the morphology, and cannot overwrite existing spatial heterogeneous morphology definitions. Args: cover (Optional[np.ndarray]): Custom coral definition. \"\"\" _reshape = RESHAPE () if cover is not None : cover = _reshape . variable2array ( cover ) if not cover . shape [ 0 ] == _reshape . space : msg = f \"Spatial dimension of cover does not match: { cover . shape } =/= { _reshape . space } .\" raise ValueError ( msg ) else : cover = np . ones ( _reshape . space ) self . p0 = np . array ( [ cover , np . zeros ( cover . shape ), np . zeros ( cover . shape ), np . zeros ( cover . shape ), ] ) . transpose () self . dc = cover * self . dc self . hc = cover * self . hc self . bc = cover * self . bc self . tc = cover * self . tc self . ac = cover * self . ac","title":"initiate_coral_morphology()"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.living_cover","text":"Living coral cover based on population states.","title":"living_cover"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.rf","text":"Form ratio: height-to-diameter ratio.","title":"rf"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.rp","text":"Plate ratio: base-to-diameter ratio.","title":"rp"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.rs","text":"Spacing ratio: diameter-to-axial distance ratio.","title":"rs"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.tc_matrix","text":"self.RESHAPEd coral plate thickness.","title":"tc_matrix"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.update_coral_morphology","text":"Update the coral morphology based on updated coral volume and morphology ratios. Parameters: Name Type Description Default coral_volume Union[float, numpy.ndarray] Coral volume required morphology_ratios Dict[str, Union[float, numpy.ndarray]] Morphology ratios (rf, rp, rs, ..) required Source code in src/core/coral/coral_model.py def update_coral_morphology ( self , coral_volume : Union [ float , np . ndarray ], morphology_ratios : Dict [ str , Union [ float , np . ndarray ]], ): \"\"\" Update the coral morphology based on updated coral volume and morphology ratios. Args: coral_volume (Union[float, np.ndarray]): Coral volume morphology_ratios (Dict[str, Union[float, np.ndarray]]): Morphology ratios (rf, rp, rs, ..) \"\"\" rf = morphology_ratios [ \"rf\" ] rp = morphology_ratios [ \"rp\" ] rs = morphology_ratios [ \"rs\" ] def vc2dc ( coral_volume , rf , rp ): \"\"\"Coral volume to coral plate diameter.\"\"\" dc = (( 4.0 * coral_volume ) / ( np . pi * rf * rp * ( 1.0 + rp - rp ** 2 ))) ** ( 1.0 / 3.0 ) return dc def vc2hc ( coral_volume , rf , rp ): \"\"\"Coral volume to coral height.\"\"\" hc = ( ( 4.0 * coral_volume * rf ** 2 ) / ( np . pi * rp * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return hc def vc2bc ( coral_volume , rf , rp ): \"\"\"Coral volume > diameter of the base.\"\"\" bc = ( ( 4.0 * coral_volume * rp ** 2 ) / ( np . pi * rf * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return bc def vc2tc ( coral_volume , rf , rp ): \"\"\"Coral volume > thickness of the plate.\"\"\" tc = ( ( 4.0 * coral_volume * rf ** 2 * rp ** 2 ) / ( np . pi * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return tc def vc2ac ( coral_volume , rf , rp , rs ): \"\"\"Coral volume > axial distance.\"\"\" ac = ( 1.0 / rs ) * ( ( 4.0 * coral_volume ) / ( np . pi * rf * rp * ( 1.0 + rp - rp ** 2 )) ) ** ( 1.0 / 3.0 ) return ac # # update morphology self . dc = vc2dc ( coral_volume , rf , rp ) self . hc = vc2hc ( coral_volume , rf , rp ) self . bc = vc2bc ( coral_volume , rf , rp ) self . tc = vc2tc ( coral_volume , rf , rp ) self . ac = vc2ac ( coral_volume , rf , rp , rs )","title":"update_coral_morphology()"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.update_coral_volume","text":"Updates the coral morphology based on the given coral volume. Parameters: Name Type Description Default coral_volume Union[float, list, tuple, numpy.ndarray] New coral volume. required Source code in src/core/coral/coral_model.py def update_coral_volume ( self , coral_volume : CoralAttribute ): \"\"\" Updates the coral morphology based on the given coral volume. Args: coral_volume (CoralAttribute): New coral volume. \"\"\" # TODO what is the difference? And which volume does it call then? # TODO also function update morphology does not update coral volume self . update_coral_morphology ( coral_volume , dict ( rf = self . rf , rp = self . rp , rs = self . rs ) )","title":"update_coral_volume()"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.update_cover","text":"Update cover value based on given parameters. Parameters: Name Type Description Default carrying_capacity Union[float, list, tuple, numpy.ndarray] Carrying capacity [m2 m-2]. required Source code in src/core/coral/coral_model.py def update_cover ( self , carrying_capacity : CoralAttribute ): \"\"\" Update cover value based on given parameters. Args: carrying_capacity (CoralAttribute): Carrying capacity [m2 m-2]. \"\"\" carrying_capacity = RESHAPE () . variable2array ( carrying_capacity ) if not self . volume . shape == carrying_capacity . shape : raise ValueError ( f \"Shapes do not match: \" f \" { self . volume . shape } =/= { carrying_capacity . shape } \" ) if sum ( self . volume [ carrying_capacity == 0.0 ]) > 0.0 : print ( f \"WARNING: Coral volume present where the carrying capacity is zero. This is unrealistic.\" ) self . _cover = carrying_capacity","title":"update_cover()"},{"location":"reference/coral/coral/#src.core.coral.coral_model.Coral.volume","text":"Coral volume.","title":"volume"},{"location":"reference/coral/coral/#coral-only-model","text":"","title":"Coral only model"},{"location":"reference/coral/coral/#src.core.coral.coral_only.CoralOnly","text":"Execute functions only in the presence of corals.","title":"CoralOnly"},{"location":"reference/coral/coral/#src.core.coral.coral_only.CoralOnly.in_space","text":"Only execute the function when there is coral cover. Parameters: Name Type Description Default coral Coral Coral object. required function Callable Function to be executed. required args Tuple input arguments of the function. required no_cover_value Optional[float] Default value in absence of coral cover. Defaults to 0. 0 Exceptions: Type Description ValueError When sizes do not match. Returns: Type Description ndarray np.ndarray: Result of the coral function. Source code in src/core/coral/coral_only.py def in_space ( self , coral , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ) -> np . ndarray : \"\"\" Only execute the function when there is coral cover. Args: coral (Coral): Coral object. function (Callable): Function to be executed. args (Tuple): input arguments of the function. no_cover_value (Optional[float], optional): Default value in absence of coral cover. Defaults to 0. Raises: ValueError: When sizes do not match. Returns: np.ndarray: Result of the coral function. \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = np . repeat ( arg , self . space ) elif not len ( arg ) == self . space : msg = f \"Sizes do not match up, { len ( arg ) } =/= { self . space } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . space ) output [ coral . cover > 0 ] = function ( * [ arg [ coral . cover > 0 ] for arg in args ]) return output","title":"in_space()"},{"location":"reference/coral/coral/#src.core.coral.coral_only.CoralOnly.in_spacetime","text":"Only execute the function when there is coral cover. :param coral: coral object :param function: function to be executed :param args: input arguments of the function :param no_cover_value: default value in absence of coral cover :type coral: Coral :type args: tuple :type no_cover_value: float, optional Source code in src/core/coral/coral_only.py def in_spacetime ( self , coral , function : Callable , args : Tuple , no_cover_value : Optional [ float ] = 0 , ): \"\"\"Only execute the function when there is coral cover. :param coral: coral object :param function: function to be executed :param args: input arguments of the function :param no_cover_value: default value in absence of coral cover :type coral: Coral :type args: tuple :type no_cover_value: float, optional \"\"\" args = list ( args ) for i , arg in enumerate ( args ): if isinstance ( arg , ( float , int )) or ( isinstance ( arg , np . ndarray ) and not arg . shape ): args [ i ] = arg * np . ones ( self . spacetime ) elif arg . shape == coral . cover . shape : args [ i ] = np . tile ( arg , ( self . time , 1 )) . transpose () elif not arg . shape == self . spacetime : msg = f \"Sizes do not match up, { arg . shape } =/= { self . spacetime } .\" raise ValueError ( msg ) output = no_cover_value * np . ones ( self . spacetime ) output [ coral . cover > 0 ] = function ( * [ arg [ coral . cover > 0 ] for arg in args ]) return output","title":"in_spacetime()"},{"location":"reference/coral/coral/#src.core.coral.coral_only.CoralOnly.space","text":"Space dimension.","title":"space"},{"location":"reference/coral/coral/#src.core.coral.coral_only.CoralOnly.time","text":"Time dimension.","title":"time"},{"location":"reference/hydrodynamics/hydromodels/","text":"Hydrodynamic simulation models. \u00b6 Factory \u00b6 HydrodynamicsFactory \u00b6 Factory class to select hydrodynamic models. It also works as a binding model-protocol between the hydrodynamic models and the HydrodynamicProtocol . create ( model_name : str , * args , ** kwargs ) -> HydrodynamicProtocol staticmethod \u00b6 Creates a HydrodynamicProtocol based on the model_name type and the dictionary of values (if any) given. Parameters: Name Type Description Default model_name str Model type name. required Returns: Type Description HydrodynamicProtocol HydrodynamicProtocol: Instance of the requested model. Source code in src/core/hydrodynamics/factory.py @staticmethod def create ( model_name : str , * args , ** kwargs ) -> HydrodynamicProtocol : \"\"\" Creates a `HydrodynamicProtocol` based on the model_name type and the dictionary of values (if any) given. Args: model_name (str): Model type name. Returns: HydrodynamicProtocol: Instance of the requested model. \"\"\" m_type : HydrodynamicProtocol = HydrodynamicsFactory . get_hydrodynamic_model_type ( model_name ) return m_type ( ** kwargs ) get_hydrodynamic_model_type ( model_name : str ) -> HydrodynamicProtocol staticmethod \u00b6 Returns the type associated with the given model name. Parameters: Name Type Description Default model_name str Model name to retrieve. required Exceptions: Type Description ValueError When the model name is not associated with a valid HydrodynamicProtocol . Returns: Type Description HydrodynamicProtocol HydrodynamicProtocol: The requested model type. Source code in src/core/hydrodynamics/factory.py @staticmethod def get_hydrodynamic_model_type ( model_name : str ) -> HydrodynamicProtocol : \"\"\" Returns the type associated with the given model name. Args: model_name (str): Model name to retrieve. Raises: ValueError: When the model name is not associated with a valid `HydrodynamicProtocol`. Returns: HydrodynamicProtocol: The requested model type. \"\"\" nm_name = model_name . lower () if model_name is not None else model_name hydromodel : HydrodynamicProtocol = next ( ( m_type for m_type in HydrodynamicsFactory . supported_modes if m_type . __name__ . lower () == nm_name ), None , ) if hydromodel is None : msg = f \" { model_name } not in { [ x . __name__ for x in HydrodynamicsFactory . supported_modes ] } .\" raise ValueError ( msg ) return hydromodel Protocol \u00b6 HydrodynamicProtocol \u00b6 Protocol describing the mandatory properties and methods to be implemented by any hydromodel. The binding between a model and the protocol is made at the factory level ('HydrodynamicsFactory'). config_file : Path property readonly \u00b6 Configuration file for the model. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description Path Path: The path to the configuration file. definition_file : Path property readonly \u00b6 Model definition file, its format (extension) may vary per file. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description Path Path: The path to the definition file. finalise ( self ) \u00b6 Finalizes the model. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py def finalise ( self ): \"\"\" Finalizes the model. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError initiate ( self ) \u00b6 Initiates the working model. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py def initiate ( self ): \"\"\" Initiates the working model. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError settings : str property readonly \u00b6 Print settings of the hydrodynamic model. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description str str: The settings as string representation. space : int property readonly \u00b6 Space-dimension Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description int int: Value of the space-dimension. update ( self , coral : Coral , stormcat : int ) \u00b6 Updates the model with the given parameters. Parameters: Name Type Description Default coral Coral Coral model to be used. required stormcat int Category of storm to apply. required Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py def update ( self , coral : Coral , stormcat : int ): \"\"\" Updates the model with the given parameters. Args: coral (Coral): Coral model to be used. stormcat (int): Category of storm to apply. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError water_depth : ndarray property readonly \u00b6 Water depth, retrieved from hydodynamic model; otherwise base on provided definitino. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description ndarray np.ndarray: Water depth value as numpy array. x_coordinates : ndarray property readonly \u00b6 The x-coordinates of the model domain. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description ndarray np.ndarray: X coordinates as numpy array. xy_coordinates : ndarray property readonly \u00b6 The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description ndarray np.ndarray: X,Y coordinates as numpy array. y_coordinates : ndarray property readonly \u00b6 The y-coordinates of the model domain. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description ndarray np.ndarray: Y coordinates as numpy array. Delft3D \u00b6 Delft3D pydantic-model \u00b6 Implements the HydrodynamicProtocol . Coupling of coral_model to Delft3D using the BMI wrapper. __repr__ ( self ) special \u00b6 Return repr(self). Source code in src/core/hydrodynamics/delft3d.py def __repr__ ( self ): return \"Delft3D()\" cleanup_environment_variables ( self ) \u00b6 Remove unnecessary environment variables from system. Source code in src/core/hydrodynamics/delft3d.py def cleanup_environment_variables ( self ): \"\"\" Remove unnecessary environment variables from system. \"\"\" env_variables = self . get_environment_variables () env_key = self . _get_sys_environment_key () # Set variable path_var : str = os . environ [ env_key ] for env_var in env_variables : if str ( env_var ) in path_var : path_var . replace ( f \"; { str ( env_var ) } \" , \"\" ) os . environ [ env_key ] = path_var configure_model_wrapper ( self ) \u00b6 Configures the model wrapper with the specifics of its type. Exceptions: Type Description NotImplementedError When the concrete class does not define its own implementation. Source code in src/core/hydrodynamics/delft3d.py @abstractmethod def configure_model_wrapper ( self ): \"\"\" Configures the model wrapper with the specifics of its type. Raises: NotImplementedError: When the concrete class does not define its own implementation. \"\"\" raise NotImplementedError finalise ( self ) \u00b6 Finalize the working model. Source code in src/core/hydrodynamics/delft3d.py def finalise ( self ): \"\"\"Finalize the working model.\"\"\" self . model_wrapper . finalize () self . cleanup_environment_variables () get_environment_variables ( self ) -> List [ str ] \u00b6 Gets the Python environment variables to include in a Delft3D model run. Source code in src/core/hydrodynamics/delft3d.py @abstractmethod def get_environment_variables ( self ) -> List [ str ]: \"\"\" Gets the Python environment variables to include in a Delft3D model run. \"\"\" raise NotImplementedError ( \"Implement in concrete class\" ) get_max_hydrodynamics ( self ) \u00b6 Get hydrodynamic results; max. values. Source code in src/core/hydrodynamics/delft3d.py def get_max_hydrodynamics ( self ): \"\"\"Get hydrodynamic results; max. values.\"\"\" current_vel = self . get_variable ( \"is_maxvalsnd\" )[ range ( self . space ), 1 ] wave_vel = self . get_variable ( \"Uorb\" )[ range ( self . space )] wave_per = self . get_variable ( \"twav\" )[ range ( self . space )] return current_vel , wave_vel , wave_per get_mean_hydrodynamics ( self ) \u00b6 Get hydrodynamic results; mean values. Source code in src/core/hydrodynamics/delft3d.py def get_mean_hydrodynamics ( self ): \"\"\"Get hydrodynamic results; mean values.\"\"\" if self . time_step is None : self . time_step = self . get_variable ( \"is_dtint\" ) current_vel = ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 1 ] / self . time_step ) wave_vel = self . get_variable ( \"Uorb\" )[ range ( self . space )] wave_per = self . get_variable ( \"twav\" )[ range ( self . space )] return current_vel , wave_vel , wave_per get_variable ( self , variable : str ) -> Union [ float , list , tuple , numpy . ndarray ] \u00b6 Get variable from the model wrapper. Parameters: Name Type Description Default variable str Variable to retrieve. required Returns: Type Description Union[float, list, tuple, numpy.ndarray] Optional[WrapperVariable]: Value found. Source code in src/core/hydrodynamics/delft3d.py def get_variable ( self , variable : str ) -> Optional [ WrapperVariable ]: \"\"\" Get variable from the model wrapper. Args: variable (str): Variable to retrieve. Returns: Optional[WrapperVariable]: Value found. \"\"\" return self . model_wrapper . get_var ( variable ) initiate ( self ) \u00b6 Creates a BMIWrapper and initializes it based on the given parameters for a FM Model. Source code in src/core/hydrodynamics/delft3d.py def initiate ( self ): \"\"\" Creates a BMIWrapper and initializes it based on the given parameters for a FM Model. \"\"\" self . set_environment_variables () self . configure_model_wrapper () self . model_wrapper . initialize () input_check ( self ) \u00b6 Check if all requested content is provided Source code in src/core/hydrodynamics/delft3d.py def input_check ( self ): \"\"\"Check if all requested content is provided\"\"\" self . input_check_definition ( \"xy_coordinates\" ) self . input_check_definition ( \"water_depth\" ) files = ( \"mdu\" ,) [ self . input_check_definition ( file ) for file in files ] interval_types = ( \"update_interval\" , \"update_interval_storm\" ) [ self . input_check_definition ( interval ) for interval in interval_types ] input_check_definition ( self , obj ) \u00b6 Check definition of critical object. Source code in src/core/hydrodynamics/delft3d.py def input_check_definition ( self , obj ): \"\"\"Check definition of critical object.\"\"\" if getattr ( self . model_wrapper , obj ) is None : msg = f \" { obj } undefined (required for Delft3D coupling)\" raise ValueError ( msg ) reset_counters ( self ) \u00b6 Reset properties for next model update. Source code in src/core/hydrodynamics/delft3d.py def reset_counters ( self ): \"\"\"Reset properties for next model update.\"\"\" sums = self . get_variable ( \"is_sumvalsnd\" ) sums . fill ( 0.0 ) self . set_variable ( \"is_sumvalsnd\" , sums ) maxs = self . get_variable ( \"is_maxvalsnd\" ) maxs . fill ( 0.0 ) self . set_variable ( \"is_maxvalsnd\" , maxs ) set_environment_variables ( self ) \u00b6 Adds the required environment variables in to the systems path. Windows: PATH Linux: LD_LIBRARY_PATH Os (Darwin): DYLD_LIBRARY_PATH Source code in src/core/hydrodynamics/delft3d.py def set_environment_variables ( self ): \"\"\" Adds the required environment variables in to the systems path. Windows: PATH Linux: LD_LIBRARY_PATH Os (Darwin): DYLD_LIBRARY_PATH \"\"\" env_variables = self . get_environment_variables () env_key = self . _get_sys_environment_key () # Set variable path_var : str = os . environ [ env_key ] for env_var in env_variables : if str ( env_var ) not in path_var : path_var += f \"; { str ( env_var ) } \" os . environ [ env_key ] = path_var set_morphology ( self , coral : Coral ) \u00b6 Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral Source code in src/core/hydrodynamics/delft3d.py def set_morphology ( self , coral : Coral ): \"\"\"Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral \"\"\" self . set_variable ( \"rnveg\" , coral . as_vegetation_density ) self . set_variable ( \"diaveg\" , coral . dc_rep ) self . set_variable ( \"stemheight\" , coral . hc ) set_variable ( self , variable : str , value : Union [ float , list , tuple , numpy . ndarray ]) \u00b6 Set variable to model wrapper. Parameters: Name Type Description Default variable str Variable to set. required value Union[float, list, tuple, numpy.ndarray] Value to set. required Source code in src/core/hydrodynamics/delft3d.py def set_variable ( self , variable : str , value : Optional [ WrapperVariable ]): \"\"\" Set variable to model wrapper. Args: variable (str): Variable to set. value (Optional[WrapperVariable]): Value to set. \"\"\" self . model_wrapper . set_var ( variable , value ) update ( self , coral , stormcat = 0 ) \u00b6 Update the Delft3D-model. Source code in src/core/hydrodynamics/delft3d.py def update ( self , coral , stormcat = 0 ): \"\"\"Update the Delft3D-model.\"\"\" self . time_step = ( self . update_interval_storm if stormcat > 0 else self . update_interval ) self . reset_counters () self . model_wrapper . update ( self . time_step ) return ( self . get_max_hydrodynamics () if stormcat > 0 else self . get_mean_hydrodynamics () ) DimrModel pydantic-model \u00b6 Class implementing the HydrodynamicProtocol which makes use of a BMIWrapper to run its calculations. Based on a DIMR model configuration. check_dll_path ( values : dict ) -> dict classmethod \u00b6 Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Parameters: Name Type Description Default values dict Validated (and formatted) dictionary of values for a Delft3D object. required Returns: Type Description dict dict: Validated dictionary with a dll_path . Source code in src/core/hydrodynamics/delft3d.py @root_validator @classmethod def check_dll_path ( cls , values : dict ) -> dict : \"\"\" Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Args: values (dict): Validated (and formatted) dictionary of values for a Delft3D object. Returns: dict: Validated dictionary with a `dll_path`. \"\"\" dll_path_value = values . get ( \"dll_path\" , None ) if dll_path_value is None and values . get ( \"d3d_home\" , None ) is not None : values [ \"dll_path\" ] = values [ \"d3d_home\" ] / \"dimr\" / \"bin\" / \"dimr_dll.dll\" return values configure_model_wrapper ( self ) \u00b6 Initilizes a BMIWrapper instance based on the given DIMR parameters. It is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. Source code in src/core/hydrodynamics/delft3d.py def configure_model_wrapper ( self ): \"\"\" Initilizes a BMIWrapper instance based on the given DIMR parameters. It is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. \"\"\" self . model_wrapper = BMIWrapper ( engine = self . dll_path . as_posix (), configfile = self . config_file . as_posix () ) get_environment_variables ( self ) -> List [ str ] \u00b6 Gets the Python environment variables required to run a Dimr model. Source code in src/core/hydrodynamics/delft3d.py def get_environment_variables ( self ) -> List [ str ]: \"\"\" Gets the Python environment variables required to run a Dimr model. \"\"\" return [ self . d3d_home / \"share\" / \"bin\" , self . d3d_home / \"dflowfm\" / \"bin\" , self . d3d_home / \"dimr\" / \"bin\" , self . d3d_home / \"dwaves\" / \"bin\" , self . d3d_home / \"esmf\" / \"scripts\" , self . d3d_home / \"swan\" / \"scripts\" , ] FlowFmModel pydantic-model \u00b6 Class implementing the HydrodynamicProtocol which makes use of a BMIWrapper to run its calculations. Based on a FlowFM model configuration. check_dll_path ( values : dict ) -> dict classmethod \u00b6 Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Parameters: Name Type Description Default values dict Validated (and formatted) dictionary of values for a Delft3D object. required Returns: Type Description dict dict: Validated dictionary with a dll_path . Source code in src/core/hydrodynamics/delft3d.py @root_validator @classmethod def check_dll_path ( cls , values : dict ) -> dict : \"\"\" Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Args: values (dict): Validated (and formatted) dictionary of values for a Delft3D object. Returns: dict: Validated dictionary with a `dll_path`. \"\"\" dll_path_value = values . get ( \"dll_path\" , None ) if dll_path_value is None and values . get ( \"d3d_home\" , None ) is not None : values [ \"dll_path\" ] = values [ \"d3d_home\" ] / \"dflowfm\" / \"bin\" / \"dflowfm.dll\" return values configure_model_wrapper ( self ) \u00b6 Initilizes a BMIWrapper instance based on the given FlowFM parameters. Configures the model wrapper, it is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. Source code in src/core/hydrodynamics/delft3d.py def configure_model_wrapper ( self ): \"\"\" Initilizes a BMIWrapper instance based on the given FlowFM parameters. Configures the model wrapper, it is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. \"\"\" self . model_wrapper = BMIWrapper ( engine = self . dll_path . as_posix (), configfile = self . definition_file . as_posix () ) get_environment_variables ( self ) -> List [ str ] \u00b6 Gets the Python environment variables required to run a FlowFM model. Source code in src/core/hydrodynamics/delft3d.py def get_environment_variables ( self ) -> List [ str ]: \"\"\"Gets the Python environment variables required to run a FlowFM model.\"\"\" return [ self . d3d_home / \"share\" / \"bin\" , self . d3d_home / \"dflowfm\" / \"bin\" , ] space : Optional [ int ] property readonly \u00b6 Number of non-boundary boxes; i.e. within-domain boxes. water_depth : Optional [ numpy . ndarray ] property readonly \u00b6 Water depth. x_coordinates : ndarray property readonly \u00b6 Center of gravity's x-coordinates as part of space . xy_coordinates : ndarray property readonly \u00b6 The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. :rtype: numpy.ndarray y_coordinates : ndarray property readonly \u00b6 Center of gravity's y-coodinates as part of space . Transect \u00b6 Transect pydantic-model \u00b6 Implements the HydrodynamicProtocol . Simple 1D depth transect with imposed currents and waves __repr__ ( self ) special \u00b6 Return repr(self). Source code in src/core/hydrodynamics/transect.py def __repr__ ( self ): return \"Transect()\" finalise ( self ) \u00b6 Finalize the working model. Source code in src/core/hydrodynamics/transect.py def finalise ( self ): \"\"\"Finalize the working model.\"\"\" pass initiate ( self ) \u00b6 Initialize the working model. In this case, read the spatial configuration and the forcings from files. Set the computing environment. Source code in src/core/hydrodynamics/transect.py def initiate ( self ): \"\"\" Initialize the working model. In this case, read the spatial configuration and the forcings from files. Set the computing environment. \"\"\" csv : np . ndarray = np . genfromtxt ( self . config_file , delimiter = \",\" , skip_header = 1 ) self . x_coordinates = csv [:, 0 ] self . y_coordinates = csv [:, 1 ] self . water_depth = csv [:, 2 ] self . outpoint = csv [:, 3 ] == 1 forcings : np . ndarray = np . genfromtxt ( self . definition_file , delimiter = \",\" , skip_header = 1 ) self . stormcat = forcings [:, 0 ] self . return_period = forcings [:, 1 ] self . wave_height = forcings [:, 2 ] self . wave_period = forcings [:, 3 ] self . wave_angle = forcings [:, 4 ] self . max_curr_vel = forcings [:, 5 ] input_check ( self ) \u00b6 Check if all requested content is provided Source code in src/core/hydrodynamics/transect.py def input_check ( self ): \"\"\"Check if all requested content is provided\"\"\" self . input_check_definition ( \"xy_coordinates\" ) self . input_check_definition ( \"water_depth\" ) files = ( \"mdu\" , \"config\" ) [ self . input_check_definition ( file ) for file in files ] input_check_definition ( self , obj ) \u00b6 Check definition of critical object. Source code in src/core/hydrodynamics/transect.py def input_check_definition ( self , obj ): \"\"\"Check definition of critical object.\"\"\" if getattr ( self , obj ) is None : msg = f \" { obj } undefined (required for Transect)\" raise ValueError ( msg ) reset_counters ( self ) \u00b6 Reset properties for next model update. Source code in src/core/hydrodynamics/transect.py def reset_counters ( self ): \"\"\"Reset properties for next model update.\"\"\" pass set_morphology ( self , coral ) \u00b6 Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral Source code in src/core/hydrodynamics/transect.py def set_morphology ( self , coral ): \"\"\"Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral \"\"\" pass settings property readonly \u00b6 Print settings of simple transect imposed forcing. space property readonly \u00b6 Number of non-boundary boxes; i.e. within-domain boxes. update ( self , coral , stormcat = 0 ) \u00b6 Update the model, which is just knowing the waves Parameters: Name Type Description Default coral Coral Coral morphology to use. required stormcat int Storm category. Defaults to 0. 0 Exceptions: Type Description ValueError When stormcat not in [0,3] range. Returns: Type Description Tuple Tuple containing calculated current velocity, wave velocity and wave period. Source code in src/core/hydrodynamics/transect.py def update ( self , coral , stormcat = 0 ): \"\"\" Update the model, which is just knowing the waves Args: coral (Coral): Coral morphology to use. stormcat (int, optional): Storm category. Defaults to 0. Raises: ValueError: When stormcat not in [0,3] range. Returns: Tuple: Tuple containing calculated current velocity, wave velocity and wave period. \"\"\" mean_current_vel = 0 if stormcat in [ 0 , 1 , 2 , 3 ]: Hs = self . wave_height [ stormcat ] T = self . wave_period [ stormcat ] max_current_vel = self . max_curr_vel [ stormcat ] h = self . water_depth wave_vel = ( Hs / 4 * np . sqrt ( 9.81 / h ) * np . exp ( - np . power (( 3.65 / T * np . sqrt ( h / 9.81 )), 2.1 )) ) else : raise ValueError ( f \"stormcat = { stormcat } , must be either 0,1,2,3\" ) if stormcat == 0 : return mean_current_vel , wave_vel , T else : return max_current_vel , wave_vel , T xy_coordinates : ndarray property readonly \u00b6 The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. Returns: Type Description ndarray np.ndarray: The (x,y) coordinates. Reef 0D \u00b6 Reef0D pydantic-model \u00b6 Implements the HydrodynamicProtocol . finalise ( self ) \u00b6 Finalise hydrodynamic model. Source code in src/core/hydrodynamics/reef_0d.py def finalise ( self ): \"\"\"Finalise hydrodynamic model.\"\"\" raise NotImplementedError initiate ( self ) \u00b6 Initiate hydrodynamic model. Source code in src/core/hydrodynamics/reef_0d.py def initiate ( self ): \"\"\"Initiate hydrodynamic model.\"\"\" raise NotImplementedError settings property readonly \u00b6 Print settings of Reef0D-model. update ( self , coral : Coral , storm = False ) -> tuple \u00b6 Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional Source code in src/core/hydrodynamics/reef_0d.py def update ( self , coral : Coral , storm = False ) -> tuple : \"\"\"Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional \"\"\" if storm : # max(current_vel, wave_vel) return None , None # mean(current_vel, wave_vel, wave_per) return None , None , None Reef 1D \u00b6 Reef1D pydantic-model \u00b6 Implements the HydrodynamicProtocol . Simplified one-dimensional hydrodynamic model over a (coral) reef. Internal 1D hydrodynamic model for order-of-magnitude calculations on the hydrodynamic conditions on a coral reef, where both flow and waves are included. __repr__ ( self ) special \u00b6 Return repr(self). Source code in src/core/hydrodynamics/reef_1d.py def __repr__ ( self ): msg = ( f \"Reef1D(bathymetry= { self . bath } , wave_height= { self . Hs } , \" f \"wave_period= { self . Tp } )\" ) return msg dispersion ( wave_length , wave_period , depth , grav_acc ) staticmethod \u00b6 Dispersion relation to determine the wave length based on the wave period. Source code in src/core/hydrodynamics/reef_1d.py @staticmethod def dispersion ( wave_length , wave_period , depth , grav_acc ): \"\"\"Dispersion relation to determine the wave length based on the wave period. \"\"\" func = wave_length - (( grav_acc * wave_period ** 2 ) / ( 2 * np . pi )) * np . tanh ( 2 * np . pi * depth / wave_length ) return func finalise ( self ) \u00b6 Finalise hydrodynamic model. Source code in src/core/hydrodynamics/reef_1d.py def finalise ( self ): \"\"\"Finalise hydrodynamic model.\"\"\" raise NotImplementedError initiate ( self ) \u00b6 Initiate hydrodynamic model. Source code in src/core/hydrodynamics/reef_1d.py def initiate ( self ): \"\"\"Initiate hydrodynamic model.\"\"\" raise NotImplementedError settings property readonly \u00b6 Print settings of Reef1D-model. update ( self , coral : Coral , storm = False ) -> tuple \u00b6 Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional Source code in src/core/hydrodynamics/reef_1d.py def update ( self , coral : Coral , storm = False ) -> tuple : \"\"\"Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional \"\"\" if storm : # max(current_vel, wave_vel) return None , None # mean(current_vel, wave_vel, wave_per) return None , None , None wave_length property readonly \u00b6 Solve the dispersion relation to retrieve the wave length.","title":"Hydromodels"},{"location":"reference/hydrodynamics/hydromodels/#hydrodynamic-simulation-models","text":"","title":"Hydrodynamic simulation models."},{"location":"reference/hydrodynamics/hydromodels/#factory","text":"","title":"Factory"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.factory.HydrodynamicsFactory","text":"Factory class to select hydrodynamic models. It also works as a binding model-protocol between the hydrodynamic models and the HydrodynamicProtocol .","title":"HydrodynamicsFactory"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.factory.HydrodynamicsFactory.create","text":"Creates a HydrodynamicProtocol based on the model_name type and the dictionary of values (if any) given. Parameters: Name Type Description Default model_name str Model type name. required Returns: Type Description HydrodynamicProtocol HydrodynamicProtocol: Instance of the requested model. Source code in src/core/hydrodynamics/factory.py @staticmethod def create ( model_name : str , * args , ** kwargs ) -> HydrodynamicProtocol : \"\"\" Creates a `HydrodynamicProtocol` based on the model_name type and the dictionary of values (if any) given. Args: model_name (str): Model type name. Returns: HydrodynamicProtocol: Instance of the requested model. \"\"\" m_type : HydrodynamicProtocol = HydrodynamicsFactory . get_hydrodynamic_model_type ( model_name ) return m_type ( ** kwargs )","title":"create()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.factory.HydrodynamicsFactory.get_hydrodynamic_model_type","text":"Returns the type associated with the given model name. Parameters: Name Type Description Default model_name str Model name to retrieve. required Exceptions: Type Description ValueError When the model name is not associated with a valid HydrodynamicProtocol . Returns: Type Description HydrodynamicProtocol HydrodynamicProtocol: The requested model type. Source code in src/core/hydrodynamics/factory.py @staticmethod def get_hydrodynamic_model_type ( model_name : str ) -> HydrodynamicProtocol : \"\"\" Returns the type associated with the given model name. Args: model_name (str): Model name to retrieve. Raises: ValueError: When the model name is not associated with a valid `HydrodynamicProtocol`. Returns: HydrodynamicProtocol: The requested model type. \"\"\" nm_name = model_name . lower () if model_name is not None else model_name hydromodel : HydrodynamicProtocol = next ( ( m_type for m_type in HydrodynamicsFactory . supported_modes if m_type . __name__ . lower () == nm_name ), None , ) if hydromodel is None : msg = f \" { model_name } not in { [ x . __name__ for x in HydrodynamicsFactory . supported_modes ] } .\" raise ValueError ( msg ) return hydromodel","title":"get_hydrodynamic_model_type()"},{"location":"reference/hydrodynamics/hydromodels/#protocol","text":"","title":"Protocol"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol","text":"Protocol describing the mandatory properties and methods to be implemented by any hydromodel. The binding between a model and the protocol is made at the factory level ('HydrodynamicsFactory').","title":"HydrodynamicProtocol"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.config_file","text":"Configuration file for the model. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description Path Path: The path to the configuration file.","title":"config_file"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.definition_file","text":"Model definition file, its format (extension) may vary per file. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description Path Path: The path to the definition file.","title":"definition_file"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.finalise","text":"Finalizes the model. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py def finalise ( self ): \"\"\" Finalizes the model. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"finalise()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.initiate","text":"Initiates the working model. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py def initiate ( self ): \"\"\" Initiates the working model. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"initiate()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.settings","text":"Print settings of the hydrodynamic model. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description str str: The settings as string representation.","title":"settings"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.space","text":"Space-dimension Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description int int: Value of the space-dimension.","title":"space"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.update","text":"Updates the model with the given parameters. Parameters: Name Type Description Default coral Coral Coral model to be used. required stormcat int Category of storm to apply. required Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/hydrodynamics/hydrodynamic_protocol.py def update ( self , coral : Coral , stormcat : int ): \"\"\" Updates the model with the given parameters. Args: coral (Coral): Coral model to be used. stormcat (int): Category of storm to apply. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"update()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.water_depth","text":"Water depth, retrieved from hydodynamic model; otherwise base on provided definitino. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description ndarray np.ndarray: Water depth value as numpy array.","title":"water_depth"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.x_coordinates","text":"The x-coordinates of the model domain. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description ndarray np.ndarray: X coordinates as numpy array.","title":"x_coordinates"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.xy_coordinates","text":"The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description ndarray np.ndarray: X,Y coordinates as numpy array.","title":"xy_coordinates"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol.y_coordinates","text":"The y-coordinates of the model domain. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description ndarray np.ndarray: Y coordinates as numpy array.","title":"y_coordinates"},{"location":"reference/hydrodynamics/hydromodels/#delft3d","text":"","title":"Delft3D"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D","text":"Implements the HydrodynamicProtocol . Coupling of coral_model to Delft3D using the BMI wrapper.","title":"Delft3D"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.__repr__","text":"Return repr(self). Source code in src/core/hydrodynamics/delft3d.py def __repr__ ( self ): return \"Delft3D()\"","title":"__repr__()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.cleanup_environment_variables","text":"Remove unnecessary environment variables from system. Source code in src/core/hydrodynamics/delft3d.py def cleanup_environment_variables ( self ): \"\"\" Remove unnecessary environment variables from system. \"\"\" env_variables = self . get_environment_variables () env_key = self . _get_sys_environment_key () # Set variable path_var : str = os . environ [ env_key ] for env_var in env_variables : if str ( env_var ) in path_var : path_var . replace ( f \"; { str ( env_var ) } \" , \"\" ) os . environ [ env_key ] = path_var","title":"cleanup_environment_variables()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.configure_model_wrapper","text":"Configures the model wrapper with the specifics of its type. Exceptions: Type Description NotImplementedError When the concrete class does not define its own implementation. Source code in src/core/hydrodynamics/delft3d.py @abstractmethod def configure_model_wrapper ( self ): \"\"\" Configures the model wrapper with the specifics of its type. Raises: NotImplementedError: When the concrete class does not define its own implementation. \"\"\" raise NotImplementedError","title":"configure_model_wrapper()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.finalise","text":"Finalize the working model. Source code in src/core/hydrodynamics/delft3d.py def finalise ( self ): \"\"\"Finalize the working model.\"\"\" self . model_wrapper . finalize () self . cleanup_environment_variables ()","title":"finalise()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.get_environment_variables","text":"Gets the Python environment variables to include in a Delft3D model run. Source code in src/core/hydrodynamics/delft3d.py @abstractmethod def get_environment_variables ( self ) -> List [ str ]: \"\"\" Gets the Python environment variables to include in a Delft3D model run. \"\"\" raise NotImplementedError ( \"Implement in concrete class\" )","title":"get_environment_variables()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.get_max_hydrodynamics","text":"Get hydrodynamic results; max. values. Source code in src/core/hydrodynamics/delft3d.py def get_max_hydrodynamics ( self ): \"\"\"Get hydrodynamic results; max. values.\"\"\" current_vel = self . get_variable ( \"is_maxvalsnd\" )[ range ( self . space ), 1 ] wave_vel = self . get_variable ( \"Uorb\" )[ range ( self . space )] wave_per = self . get_variable ( \"twav\" )[ range ( self . space )] return current_vel , wave_vel , wave_per","title":"get_max_hydrodynamics()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.get_mean_hydrodynamics","text":"Get hydrodynamic results; mean values. Source code in src/core/hydrodynamics/delft3d.py def get_mean_hydrodynamics ( self ): \"\"\"Get hydrodynamic results; mean values.\"\"\" if self . time_step is None : self . time_step = self . get_variable ( \"is_dtint\" ) current_vel = ( self . get_variable ( \"is_sumvalsnd\" )[ range ( self . space ), 1 ] / self . time_step ) wave_vel = self . get_variable ( \"Uorb\" )[ range ( self . space )] wave_per = self . get_variable ( \"twav\" )[ range ( self . space )] return current_vel , wave_vel , wave_per","title":"get_mean_hydrodynamics()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.get_variable","text":"Get variable from the model wrapper. Parameters: Name Type Description Default variable str Variable to retrieve. required Returns: Type Description Union[float, list, tuple, numpy.ndarray] Optional[WrapperVariable]: Value found. Source code in src/core/hydrodynamics/delft3d.py def get_variable ( self , variable : str ) -> Optional [ WrapperVariable ]: \"\"\" Get variable from the model wrapper. Args: variable (str): Variable to retrieve. Returns: Optional[WrapperVariable]: Value found. \"\"\" return self . model_wrapper . get_var ( variable )","title":"get_variable()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.initiate","text":"Creates a BMIWrapper and initializes it based on the given parameters for a FM Model. Source code in src/core/hydrodynamics/delft3d.py def initiate ( self ): \"\"\" Creates a BMIWrapper and initializes it based on the given parameters for a FM Model. \"\"\" self . set_environment_variables () self . configure_model_wrapper () self . model_wrapper . initialize ()","title":"initiate()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.input_check","text":"Check if all requested content is provided Source code in src/core/hydrodynamics/delft3d.py def input_check ( self ): \"\"\"Check if all requested content is provided\"\"\" self . input_check_definition ( \"xy_coordinates\" ) self . input_check_definition ( \"water_depth\" ) files = ( \"mdu\" ,) [ self . input_check_definition ( file ) for file in files ] interval_types = ( \"update_interval\" , \"update_interval_storm\" ) [ self . input_check_definition ( interval ) for interval in interval_types ]","title":"input_check()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.input_check_definition","text":"Check definition of critical object. Source code in src/core/hydrodynamics/delft3d.py def input_check_definition ( self , obj ): \"\"\"Check definition of critical object.\"\"\" if getattr ( self . model_wrapper , obj ) is None : msg = f \" { obj } undefined (required for Delft3D coupling)\" raise ValueError ( msg )","title":"input_check_definition()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.reset_counters","text":"Reset properties for next model update. Source code in src/core/hydrodynamics/delft3d.py def reset_counters ( self ): \"\"\"Reset properties for next model update.\"\"\" sums = self . get_variable ( \"is_sumvalsnd\" ) sums . fill ( 0.0 ) self . set_variable ( \"is_sumvalsnd\" , sums ) maxs = self . get_variable ( \"is_maxvalsnd\" ) maxs . fill ( 0.0 ) self . set_variable ( \"is_maxvalsnd\" , maxs )","title":"reset_counters()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.set_environment_variables","text":"Adds the required environment variables in to the systems path. Windows: PATH Linux: LD_LIBRARY_PATH Os (Darwin): DYLD_LIBRARY_PATH Source code in src/core/hydrodynamics/delft3d.py def set_environment_variables ( self ): \"\"\" Adds the required environment variables in to the systems path. Windows: PATH Linux: LD_LIBRARY_PATH Os (Darwin): DYLD_LIBRARY_PATH \"\"\" env_variables = self . get_environment_variables () env_key = self . _get_sys_environment_key () # Set variable path_var : str = os . environ [ env_key ] for env_var in env_variables : if str ( env_var ) not in path_var : path_var += f \"; { str ( env_var ) } \" os . environ [ env_key ] = path_var","title":"set_environment_variables()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.set_morphology","text":"Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral Source code in src/core/hydrodynamics/delft3d.py def set_morphology ( self , coral : Coral ): \"\"\"Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral \"\"\" self . set_variable ( \"rnveg\" , coral . as_vegetation_density ) self . set_variable ( \"diaveg\" , coral . dc_rep ) self . set_variable ( \"stemheight\" , coral . hc )","title":"set_morphology()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.set_variable","text":"Set variable to model wrapper. Parameters: Name Type Description Default variable str Variable to set. required value Union[float, list, tuple, numpy.ndarray] Value to set. required Source code in src/core/hydrodynamics/delft3d.py def set_variable ( self , variable : str , value : Optional [ WrapperVariable ]): \"\"\" Set variable to model wrapper. Args: variable (str): Variable to set. value (Optional[WrapperVariable]): Value to set. \"\"\" self . model_wrapper . set_var ( variable , value )","title":"set_variable()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.Delft3D.update","text":"Update the Delft3D-model. Source code in src/core/hydrodynamics/delft3d.py def update ( self , coral , stormcat = 0 ): \"\"\"Update the Delft3D-model.\"\"\" self . time_step = ( self . update_interval_storm if stormcat > 0 else self . update_interval ) self . reset_counters () self . model_wrapper . update ( self . time_step ) return ( self . get_max_hydrodynamics () if stormcat > 0 else self . get_mean_hydrodynamics () )","title":"update()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.DimrModel","text":"Class implementing the HydrodynamicProtocol which makes use of a BMIWrapper to run its calculations. Based on a DIMR model configuration.","title":"DimrModel"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.DimrModel.check_dll_path","text":"Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Parameters: Name Type Description Default values dict Validated (and formatted) dictionary of values for a Delft3D object. required Returns: Type Description dict dict: Validated dictionary with a dll_path . Source code in src/core/hydrodynamics/delft3d.py @root_validator @classmethod def check_dll_path ( cls , values : dict ) -> dict : \"\"\" Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Args: values (dict): Validated (and formatted) dictionary of values for a Delft3D object. Returns: dict: Validated dictionary with a `dll_path`. \"\"\" dll_path_value = values . get ( \"dll_path\" , None ) if dll_path_value is None and values . get ( \"d3d_home\" , None ) is not None : values [ \"dll_path\" ] = values [ \"d3d_home\" ] / \"dimr\" / \"bin\" / \"dimr_dll.dll\" return values","title":"check_dll_path()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.DimrModel.configure_model_wrapper","text":"Initilizes a BMIWrapper instance based on the given DIMR parameters. It is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. Source code in src/core/hydrodynamics/delft3d.py def configure_model_wrapper ( self ): \"\"\" Initilizes a BMIWrapper instance based on the given DIMR parameters. It is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. \"\"\" self . model_wrapper = BMIWrapper ( engine = self . dll_path . as_posix (), configfile = self . config_file . as_posix () )","title":"configure_model_wrapper()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.DimrModel.get_environment_variables","text":"Gets the Python environment variables required to run a Dimr model. Source code in src/core/hydrodynamics/delft3d.py def get_environment_variables ( self ) -> List [ str ]: \"\"\" Gets the Python environment variables required to run a Dimr model. \"\"\" return [ self . d3d_home / \"share\" / \"bin\" , self . d3d_home / \"dflowfm\" / \"bin\" , self . d3d_home / \"dimr\" / \"bin\" , self . d3d_home / \"dwaves\" / \"bin\" , self . d3d_home / \"esmf\" / \"scripts\" , self . d3d_home / \"swan\" / \"scripts\" , ]","title":"get_environment_variables()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.FlowFmModel","text":"Class implementing the HydrodynamicProtocol which makes use of a BMIWrapper to run its calculations. Based on a FlowFM model configuration.","title":"FlowFmModel"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.FlowFmModel.check_dll_path","text":"Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Parameters: Name Type Description Default values dict Validated (and formatted) dictionary of values for a Delft3D object. required Returns: Type Description dict dict: Validated dictionary with a dll_path . Source code in src/core/hydrodynamics/delft3d.py @root_validator @classmethod def check_dll_path ( cls , values : dict ) -> dict : \"\"\" Although not mandatory, we need to ensure at least a default value is given to the dll path. This default value is relative to the mandatory d3dhome attribute. Args: values (dict): Validated (and formatted) dictionary of values for a Delft3D object. Returns: dict: Validated dictionary with a `dll_path`. \"\"\" dll_path_value = values . get ( \"dll_path\" , None ) if dll_path_value is None and values . get ( \"d3d_home\" , None ) is not None : values [ \"dll_path\" ] = values [ \"d3d_home\" ] / \"dflowfm\" / \"bin\" / \"dflowfm.dll\" return values","title":"check_dll_path()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.FlowFmModel.configure_model_wrapper","text":"Initilizes a BMIWrapper instance based on the given FlowFM parameters. Configures the model wrapper, it is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. Source code in src/core/hydrodynamics/delft3d.py def configure_model_wrapper ( self ): \"\"\" Initilizes a BMIWrapper instance based on the given FlowFM parameters. Configures the model wrapper, it is recommended to set the environment variables beforehand. If the PATH variables does not work it is recommended copying all the contents from the share directory into the dimr bin dir. \"\"\" self . model_wrapper = BMIWrapper ( engine = self . dll_path . as_posix (), configfile = self . definition_file . as_posix () )","title":"configure_model_wrapper()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.FlowFmModel.get_environment_variables","text":"Gets the Python environment variables required to run a FlowFM model. Source code in src/core/hydrodynamics/delft3d.py def get_environment_variables ( self ) -> List [ str ]: \"\"\"Gets the Python environment variables required to run a FlowFM model.\"\"\" return [ self . d3d_home / \"share\" / \"bin\" , self . d3d_home / \"dflowfm\" / \"bin\" , ]","title":"get_environment_variables()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.FlowFmModel.space","text":"Number of non-boundary boxes; i.e. within-domain boxes.","title":"space"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.FlowFmModel.water_depth","text":"Water depth.","title":"water_depth"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.FlowFmModel.x_coordinates","text":"Center of gravity's x-coordinates as part of space .","title":"x_coordinates"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.FlowFmModel.xy_coordinates","text":"The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. :rtype: numpy.ndarray","title":"xy_coordinates"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.delft3d.FlowFmModel.y_coordinates","text":"Center of gravity's y-coodinates as part of space .","title":"y_coordinates"},{"location":"reference/hydrodynamics/hydromodels/#transect","text":"","title":"Transect"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect","text":"Implements the HydrodynamicProtocol . Simple 1D depth transect with imposed currents and waves","title":"Transect"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.__repr__","text":"Return repr(self). Source code in src/core/hydrodynamics/transect.py def __repr__ ( self ): return \"Transect()\"","title":"__repr__()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.finalise","text":"Finalize the working model. Source code in src/core/hydrodynamics/transect.py def finalise ( self ): \"\"\"Finalize the working model.\"\"\" pass","title":"finalise()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.initiate","text":"Initialize the working model. In this case, read the spatial configuration and the forcings from files. Set the computing environment. Source code in src/core/hydrodynamics/transect.py def initiate ( self ): \"\"\" Initialize the working model. In this case, read the spatial configuration and the forcings from files. Set the computing environment. \"\"\" csv : np . ndarray = np . genfromtxt ( self . config_file , delimiter = \",\" , skip_header = 1 ) self . x_coordinates = csv [:, 0 ] self . y_coordinates = csv [:, 1 ] self . water_depth = csv [:, 2 ] self . outpoint = csv [:, 3 ] == 1 forcings : np . ndarray = np . genfromtxt ( self . definition_file , delimiter = \",\" , skip_header = 1 ) self . stormcat = forcings [:, 0 ] self . return_period = forcings [:, 1 ] self . wave_height = forcings [:, 2 ] self . wave_period = forcings [:, 3 ] self . wave_angle = forcings [:, 4 ] self . max_curr_vel = forcings [:, 5 ]","title":"initiate()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.input_check","text":"Check if all requested content is provided Source code in src/core/hydrodynamics/transect.py def input_check ( self ): \"\"\"Check if all requested content is provided\"\"\" self . input_check_definition ( \"xy_coordinates\" ) self . input_check_definition ( \"water_depth\" ) files = ( \"mdu\" , \"config\" ) [ self . input_check_definition ( file ) for file in files ]","title":"input_check()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.input_check_definition","text":"Check definition of critical object. Source code in src/core/hydrodynamics/transect.py def input_check_definition ( self , obj ): \"\"\"Check definition of critical object.\"\"\" if getattr ( self , obj ) is None : msg = f \" { obj } undefined (required for Transect)\" raise ValueError ( msg )","title":"input_check_definition()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.reset_counters","text":"Reset properties for next model update. Source code in src/core/hydrodynamics/transect.py def reset_counters ( self ): \"\"\"Reset properties for next model update.\"\"\" pass","title":"reset_counters()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.set_morphology","text":"Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral Source code in src/core/hydrodynamics/transect.py def set_morphology ( self , coral ): \"\"\"Set morphological dimensions to Delft3D-model. :param coral: coral animal :type coral: Coral \"\"\" pass","title":"set_morphology()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.settings","text":"Print settings of simple transect imposed forcing.","title":"settings"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.space","text":"Number of non-boundary boxes; i.e. within-domain boxes.","title":"space"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.update","text":"Update the model, which is just knowing the waves Parameters: Name Type Description Default coral Coral Coral morphology to use. required stormcat int Storm category. Defaults to 0. 0 Exceptions: Type Description ValueError When stormcat not in [0,3] range. Returns: Type Description Tuple Tuple containing calculated current velocity, wave velocity and wave period. Source code in src/core/hydrodynamics/transect.py def update ( self , coral , stormcat = 0 ): \"\"\" Update the model, which is just knowing the waves Args: coral (Coral): Coral morphology to use. stormcat (int, optional): Storm category. Defaults to 0. Raises: ValueError: When stormcat not in [0,3] range. Returns: Tuple: Tuple containing calculated current velocity, wave velocity and wave period. \"\"\" mean_current_vel = 0 if stormcat in [ 0 , 1 , 2 , 3 ]: Hs = self . wave_height [ stormcat ] T = self . wave_period [ stormcat ] max_current_vel = self . max_curr_vel [ stormcat ] h = self . water_depth wave_vel = ( Hs / 4 * np . sqrt ( 9.81 / h ) * np . exp ( - np . power (( 3.65 / T * np . sqrt ( h / 9.81 )), 2.1 )) ) else : raise ValueError ( f \"stormcat = { stormcat } , must be either 0,1,2,3\" ) if stormcat == 0 : return mean_current_vel , wave_vel , T else : return max_current_vel , wave_vel , T","title":"update()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.transect.Transect.xy_coordinates","text":"The (x,y)-coordinates of the model domain, retrieved from hydrodynamic model; otherwise based on provided definition. Returns: Type Description ndarray np.ndarray: The (x,y) coordinates.","title":"xy_coordinates"},{"location":"reference/hydrodynamics/hydromodels/#reef-0d","text":"","title":"Reef 0D"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_0d.Reef0D","text":"Implements the HydrodynamicProtocol .","title":"Reef0D"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_0d.Reef0D.finalise","text":"Finalise hydrodynamic model. Source code in src/core/hydrodynamics/reef_0d.py def finalise ( self ): \"\"\"Finalise hydrodynamic model.\"\"\" raise NotImplementedError","title":"finalise()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_0d.Reef0D.initiate","text":"Initiate hydrodynamic model. Source code in src/core/hydrodynamics/reef_0d.py def initiate ( self ): \"\"\"Initiate hydrodynamic model.\"\"\" raise NotImplementedError","title":"initiate()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_0d.Reef0D.settings","text":"Print settings of Reef0D-model.","title":"settings"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_0d.Reef0D.update","text":"Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional Source code in src/core/hydrodynamics/reef_0d.py def update ( self , coral : Coral , storm = False ) -> tuple : \"\"\"Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional \"\"\" if storm : # max(current_vel, wave_vel) return None , None # mean(current_vel, wave_vel, wave_per) return None , None , None","title":"update()"},{"location":"reference/hydrodynamics/hydromodels/#reef-1d","text":"","title":"Reef 1D"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_1d.Reef1D","text":"Implements the HydrodynamicProtocol . Simplified one-dimensional hydrodynamic model over a (coral) reef. Internal 1D hydrodynamic model for order-of-magnitude calculations on the hydrodynamic conditions on a coral reef, where both flow and waves are included.","title":"Reef1D"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_1d.Reef1D.__repr__","text":"Return repr(self). Source code in src/core/hydrodynamics/reef_1d.py def __repr__ ( self ): msg = ( f \"Reef1D(bathymetry= { self . bath } , wave_height= { self . Hs } , \" f \"wave_period= { self . Tp } )\" ) return msg","title":"__repr__()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_1d.Reef1D.dispersion","text":"Dispersion relation to determine the wave length based on the wave period. Source code in src/core/hydrodynamics/reef_1d.py @staticmethod def dispersion ( wave_length , wave_period , depth , grav_acc ): \"\"\"Dispersion relation to determine the wave length based on the wave period. \"\"\" func = wave_length - (( grav_acc * wave_period ** 2 ) / ( 2 * np . pi )) * np . tanh ( 2 * np . pi * depth / wave_length ) return func","title":"dispersion()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_1d.Reef1D.finalise","text":"Finalise hydrodynamic model. Source code in src/core/hydrodynamics/reef_1d.py def finalise ( self ): \"\"\"Finalise hydrodynamic model.\"\"\" raise NotImplementedError","title":"finalise()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_1d.Reef1D.initiate","text":"Initiate hydrodynamic model. Source code in src/core/hydrodynamics/reef_1d.py def initiate ( self ): \"\"\"Initiate hydrodynamic model.\"\"\" raise NotImplementedError","title":"initiate()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_1d.Reef1D.settings","text":"Print settings of Reef1D-model.","title":"settings"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_1d.Reef1D.update","text":"Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional Source code in src/core/hydrodynamics/reef_1d.py def update ( self , coral : Coral , storm = False ) -> tuple : \"\"\"Update hydrodynamic model. :param coral: coral animal :param storm: storm conditions, defaults to False :type coral: Coral :type storm: bool, optional \"\"\" if storm : # max(current_vel, wave_vel) return None , None # mean(current_vel, wave_vel, wave_per) return None , None , None","title":"update()"},{"location":"reference/hydrodynamics/hydromodels/#src.core.hydrodynamics.reef_1d.Reef1D.wave_length","text":"Solve the dispersion relation to retrieve the wave length.","title":"wave_length"},{"location":"reference/output/output/","text":"Output classes for the NBSDynamics package. \u00b6 Protocol \u00b6 OutputProtocol \u00b6 Protocol defining how an Output model should look like. initialize ( self , coral : Coral ) \u00b6 Initializes an output model with the given coral input. Parameters: Name Type Description Default coral Coral Coral input model. required Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/output/output_protocol.py def initialize ( self , coral : Coral ): \"\"\" Initializes an output model with the given coral input. Args: coral (Coral): Coral input model. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError output_filename : str property readonly \u00b6 The basename with extension the output file will have. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description str str: Output filename. output_filepath : Path property readonly \u00b6 The full path to the output file. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description Path Path: Output filepath. output_params : ModelParameters property readonly \u00b6 The output parameters needed to interact with the netcdf dataset. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description ModelParameters ModelParameters: Object with netcdf parameters as attrs.. update ( self , coral : Coral , year : int ) \u00b6 Updates the output model with the given coral and year. Parameters: Name Type Description Default coral Coral Coral input model. required year int Current calculation year. required Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/output/output_protocol.py def update ( self , coral : Coral , year : int ): \"\"\" Updates the output model with the given coral and year. Args: coral (Coral): Coral input model. year (int): Current calculation year. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError Wrapper \u00b6 OutputWrapper pydantic-model \u00b6 Output files based on predefined output content. Generate output files of CoralModel simulation. Output files are formatted as NetCDF4-files. __repr__ ( self ) special \u00b6 Representation of Output. Source code in src/core/output/output_wrapper.py def __repr__ ( self ): \"\"\"Representation of Output.\"\"\" return f \"Output(xy_coordinates= { self . xy_coordinates } , first_date= { self . first_date } )\" __str__ ( self ) special \u00b6 String-representation of Output. Source code in src/core/output/output_wrapper.py def __str__ ( self ): \"\"\"String-representation of Output.\"\"\" return ( f \"Output exported: \\n\\t { self . map_output } \\n\\t { self . his_output } \" if self . defined else \"Output undefined.\" ) check_output_dir ( values : dict ) -> dict classmethod \u00b6 Checks an output_dir attribute is given for the output_model instances map_output and his_output . Parameters: Name Type Description Default values dict Dictionary of attribute values given by the user. required Returns: Type Description dict dict: Dictionary of attribute values with a valid output_dir value. Source code in src/core/output/output_wrapper.py @root_validator ( pre = True ) @classmethod def check_output_dir ( cls , values : dict ) -> dict : \"\"\" Checks an `output_dir` attribute is given for the `output_model` instances `map_output` and `his_output`. Args: values (dict): Dictionary of attribute values given by the user. Returns: dict: Dictionary of attribute values with a valid `output_dir` value. \"\"\" def check_output_model_dir ( out_model : dict ) -> Optional [ dict ]: if out_model is None : return None out_dir_val = out_model . get ( \"output_dir\" , None ) if out_dir_val is None : out_model [ \"output_dir\" ] = values [ \"output_dir\" ] return out_model values [ \"map_output\" ] = check_output_model_dir ( values . get ( \"map_output\" , None )) values [ \"his_output\" ] = check_output_model_dir ( values . get ( \"his_output\" , None )) return values defined : bool property readonly \u00b6 Output is defined. get_xy_stations ( xy_coordinates : ndarray , outpoint : ndarray ) -> Tuple [ numpy . ndarray , numpy . ndarray ] staticmethod \u00b6 Determine space indices based on the (x,y)-coordinates of the stations. Parameters: Name Type Description Default xy_coordinates ndarray Input xy-coordinates system. required outpoint ndarray Boolean per x-y indicating if his output is desired. required Returns: Type Description Tuple[numpy.ndarray, numpy.ndarray] Tuple[np.ndarray, np.ndarray]: Resulting tuple of xy_stations, idx_stations Source code in src/core/output/output_wrapper.py @staticmethod def get_xy_stations ( xy_coordinates : np . ndarray , outpoint : np . ndarray ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\" Determine space indices based on the (x,y)-coordinates of the stations. Args: xy_coordinates (np.ndarray): Input xy-coordinates system. outpoint (np.ndarray): Boolean per x-y indicating if his output is desired. Returns: Tuple[np.ndarray, np.ndarray]: Resulting tuple of xy_stations, idx_stations \"\"\" nout_his = len ( xy_coordinates [ outpoint , 0 ]) x_coord = xy_coordinates [:, 0 ] y_coord = xy_coordinates [:, 1 ] x_station = xy_coordinates [ outpoint , 0 ] y_station = xy_coordinates [ outpoint , 1 ] idx = np . zeros ( nout_his ) for s in range ( len ( idx )): idx [ s ] = np . argmin ( ( x_coord - x_station [ s ]) ** 2 + ( y_coord - y_station [ s ]) ** 2 ) idx_stations = idx . astype ( int ) return xy_coordinates [ idx_stations , :], idx_stations initialize ( self , coral : Coral ) \u00b6 Initializes all available output models (His and Map). Parameters: Name Type Description Default coral Coral Coral model to be used in the output. required Source code in src/core/output/output_wrapper.py def initialize ( self , coral : Coral ): \"\"\" Initializes all available output models (His and Map). Args: coral (Coral): Coral model to be used in the output. \"\"\" # Initialize Output dir path. self . output_dir . mkdir ( parents = True , exist_ok = True ) # Initialize output models. self . his_output . initialize ( coral ) self . map_output . initialize ( coral ) Output models \u00b6 BaseOutput pydantic-model \u00b6 Base class containing the generic definition of a 'Coral' output model. output_filepath : Path property readonly \u00b6 Gets the full path to the output netcdf file. Returns: Type Description Path Path: Output .nc file. valid_output ( self ) -> bool \u00b6 Verifies whether this model can generate valid output. Returns: Type Description bool bool: Output is valid. Source code in src/core/output/output_model.py def valid_output ( self ) -> bool : \"\"\" Verifies whether this model can generate valid output. Returns: bool: Output is valid. \"\"\" return self . output_params . valid_output () HisOutput pydantic-model \u00b6 Object representing a His output. Implements the 'OutputProtocol'. initialize ( self , _ : Coral ) \u00b6 Initiate history output file in which daily output at predefined locations within the model is stored. Source code in src/core/output/output_model.py def initialize ( self , _ : Coral ): \"\"\"Initiate history output file in which daily output at predefined locations within the model is stored.\"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , \"w\" , format = \"NETCDF4\" ) as _his_data : _his_data . description = \"Historic simulation data of the CoralModel\" # dimensions _his_data . createDimension ( \"time\" , None ) _his_data . createDimension ( \"stations\" , len ( self . xy_stations )) # variables t = _his_data . createVariable ( \"time\" , \"f8\" , ( \"time\" ,)) t . long_name = f \"days since { self . first_date } \" t . units = \"days\" x = _his_data . createVariable ( \"station_x_coordinate\" , \"f8\" , ( \"stations\" ,)) y = _his_data . createVariable ( \"station_y_coordinate\" , \"f8\" , ( \"stations\" ,)) # setup data set x [:] = self . xy_stations [:, 0 ] y [:] = self . xy_stations [:, 1 ] def init_lme (): light_set = _his_data . createVariable ( \"Iz\" , \"f8\" , ( \"time\" , \"stations\" )) light_set . long_name = \"representative light-intensity\" light_set . units = \"micro-mol photons m-2 s-1\" def init_fme (): flow_set = _his_data . createVariable ( \"ucm\" , \"f8\" , ( \"time\" , \"stations\" )) flow_set . long_name = \"in-canopy flow\" flow_set . units = \"m s-1\" def init_tme (): temp_set = _his_data . createVariable ( \"Tc\" , \"f8\" , ( \"time\" , \"stations\" )) temp_set . long_name = \"coral temperature\" temp_set . units = \"K\" low_temp_set = _his_data . createVariable ( \"Tlo\" , \"f8\" , ( \"time\" , \"stations\" ) ) low_temp_set . long_name = \"lower thermal limit\" low_temp_set . units = \"K\" high_temp_set = _his_data . createVariable ( \"Thi\" , \"f8\" , ( \"time\" , \"stations\" ) ) high_temp_set . long_name = \"upper thermal limit\" high_temp_set . units = \"K\" def init_pd (): pd_set = _his_data . createVariable ( \"PD\" , \"f8\" , ( \"time\" , \"stations\" )) pd_set . long_name = \"photosynthetic rate\" pd_set . units = \"-\" def init_ps (): pt_set = _his_data . createVariable ( \"PT\" , \"f8\" , ( \"time\" , \"stations\" )) pt_set . long_name = \"total coral population\" pt_set . units = \"-\" ph_set = _his_data . createVariable ( \"PH\" , \"f8\" , ( \"time\" , \"stations\" )) ph_set . long_name = \"healthy coral population\" ph_set . units = \"-\" pr_set = _his_data . createVariable ( \"PR\" , \"f8\" , ( \"time\" , \"stations\" )) pr_set . long_name = \"recovering coral population\" pr_set . units = \"-\" pp_set = _his_data . createVariable ( \"PP\" , \"f8\" , ( \"time\" , \"stations\" )) pp_set . long_name = \"pale coral population\" pp_set . units = \"-\" pb_set = _his_data . createVariable ( \"PB\" , \"f8\" , ( \"time\" , \"stations\" )) pb_set . long_name = \"bleached coral population\" pb_set . units = \"-\" def init_calc (): calc_set = _his_data . createVariable ( \"G\" , \"f8\" , ( \"time\" , \"stations\" )) calc_set . long_name = \"calcification\" calc_set . units = \"kg m-2 d-1\" def init_md (): dc_set = _his_data . createVariable ( \"dc\" , \"f8\" , ( \"time\" , \"stations\" )) dc_set . long_name = \"coral plate diameter\" dc_set . units = \"m\" hc_set = _his_data . createVariable ( \"hc\" , \"f8\" , ( \"time\" , \"stations\" )) hc_set . long_name = \"coral height\" hc_set . units = \"m\" bc_set = _his_data . createVariable ( \"bc\" , \"f8\" , ( \"time\" , \"stations\" )) bc_set . long_name = \"coral base diameter\" bc_set . units = \"m\" tc_set = _his_data . createVariable ( \"tc\" , \"f8\" , ( \"time\" , \"stations\" )) tc_set . long_name = \"coral plate thickness\" tc_set . units = \"m\" ac_set = _his_data . createVariable ( \"ac\" , \"f8\" , ( \"time\" , \"stations\" )) ac_set . long_name = \"coral axial distance\" ac_set . units = \"m\" vc_set = _his_data . createVariable ( \"Vc\" , \"f8\" , ( \"time\" , \"stations\" )) vc_set . long_name = \"coral volume\" vc_set . units = \"m3\" # initial conditions conditions_funct = dict ( lme = init_lme , fme = init_fme , tme = init_tme , pd = init_pd , ps = init_ps , calc = init_calc , md = init_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () update ( self , coral : Coral , dates : DataFrame ) \u00b6 Write data as daily output at predefined locations within the model domain. :param coral: coral animal :param dates: dates of simulation year :type coral: Coral :type dates: DataFrame Source code in src/core/output/output_model.py def update ( self , coral : Coral , dates : DataFrame ): \"\"\"Write data as daily output at predefined locations within the model domain. :param coral: coral animal :param dates: dates of simulation year :type coral: Coral :type dates: DataFrame \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _his_data : y_dates = dates . reset_index ( drop = True ) ti = ( y_dates - self . first_date ) . dt . days . values _his_data [ \"time\" ][ ti ] = y_dates . values def update_lme (): _his_data [ \"Iz\" ][ ti , :] = coral . light [ self . idx_stations , :] . transpose () def update_fme (): _his_data [ \"ucm\" ][ ti , :] = np . tile ( coral . ucm , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] def update_tme (): _his_data [ \"Tc\" ][ ti , :] = coral . temp [ self . idx_stations , :] . transpose () if ( len ( DataReshape . variable2array ( coral . Tlo )) > 1 and len ( DataReshape . variable2array ( coral . Thi )) > 1 ): _his_data [ \"Tlo\" ][ ti , :] = np . tile ( coral . Tlo , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"Thi\" ][ ti , :] = np . tile ( coral . Thi , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] else : _his_data [ \"Tlo\" ][ ti , :] = coral . Tlo * np . ones ( ( len ( y_dates ), len ( self . idx_stations )) ) _his_data [ \"Thi\" ][ ti , :] = coral . Thi * np . ones ( ( len ( y_dates ), len ( self . idx_stations )) ) def update_pd (): _his_data [ \"PD\" ][ ti , :] = coral . photo_rate [ self . idx_stations , : ] . transpose () def update_ps (): _his_data [ \"PT\" ][ ti , :] = ( coral . pop_states [ self . idx_stations , :, :] . sum ( axis = 2 ) . transpose () ) _his_data [ \"PH\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 0 ] . transpose () _his_data [ \"PR\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 1 ] . transpose () _his_data [ \"PP\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 2 ] . transpose () _his_data [ \"PB\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 3 ] . transpose () def update_calc (): _his_data [ \"G\" ][ ti , :] = coral . calc [ self . idx_stations , :] . transpose () def update_md (): _his_data [ \"dc\" ][ ti , :] = np . tile ( coral . dc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"hc\" ][ ti , :] = np . tile ( coral . hc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"bc\" ][ ti , :] = np . tile ( coral . bc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"tc\" ][ ti , :] = np . tile ( coral . tc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"ac\" ][ ti , :] = np . tile ( coral . ac , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"Vc\" ][ ti , :] = np . tile ( coral . volume , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] conditions_funct = dict ( lme = update_lme , fme = update_fme , tme = update_tme , pd = update_pd , ps = update_ps , calc = update_calc , md = update_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () MapOutput pydantic-model \u00b6 Object representing a Map output. Implements the 'OutputProtocol'. initialize ( self , coral : Coral ) \u00b6 Initiate mapping output file in which annual output covering the whole model domain is stored. :param coral: coral animal :type coral: Coral Source code in src/core/output/output_model.py def initialize ( self , coral : Coral ): \"\"\"Initiate mapping output file in which annual output covering the whole model domain is stored. :param coral: coral animal :type coral: Coral \"\"\" if not self . valid_output (): return # Open netcdf data and initialize needed variables. with Dataset ( self . output_filepath , \"w\" , format = \"NETCDF4\" ) as _map_data : _map_data . description = \"Mapped simulation data of the CoralModel.\" # dimensions _map_data . createDimension ( \"time\" , None ) _map_data . createDimension ( \"nmesh2d_face\" , self . space ) # variables t = _map_data . createVariable ( \"time\" , int , ( \"time\" ,)) t . long_name = \"year\" t . units = \"years since 0 B.C.\" x = _map_data . createVariable ( \"nmesh2d_x\" , \"f8\" , ( \"nmesh2d_face\" ,)) x . long_name = \"x-coordinate\" x . units = \"m\" y = _map_data . createVariable ( \"nmesh2d_y\" , \"f8\" , ( \"nmesh2d_face\" ,)) y . long_name = \"y-coordinate\" y . units = \"m\" t [:] = self . first_year x [:] = self . xy_coordinates [:, 0 ] y [:] = self . xy_coordinates [:, 1 ] # initial conditions # Definition of methods to initialize the netcdf variables. def init_lme (): light_set = _map_data . createVariable ( \"Iz\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) light_set . long_name = \"annual mean representative light-intensity\" light_set . units = \"micro-mol photons m-2 s-1\" light_set [:, :] = 0 def init_fme (): flow_set = _map_data . createVariable ( \"ucm\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) flow_set . long_name = \"annual mean in-canopy flow\" flow_set . units = \"m s-1\" flow_set [:, :] = 0 def init_tme (): temp_set = _map_data . createVariable ( \"Tc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) temp_set . long_name = \"annual mean coral temperature\" temp_set . units = \"K\" temp_set [:, :] = 0 low_temp_set = _map_data . createVariable ( \"Tlo\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) low_temp_set . long_name = \"annual mean lower thermal limit\" low_temp_set . units = \"K\" low_temp_set [:, :] = 0 high_temp_set = _map_data . createVariable ( \"Thi\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) high_temp_set . long_name = \"annual mean upper thermal limit\" high_temp_set . units = \"K\" high_temp_set [:, :] = 0 def init_pd (): pd_set = _map_data . createVariable ( \"PD\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pd_set . long_name = \"annual sum photosynthetic rate\" pd_set . units = \"-\" pd_set [:, :] = 0 def init_ps (): pt_set = _map_data . createVariable ( \"PT\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pt_set . long_name = ( \"total living coral population at the end of the year\" ) pt_set . units = \"-\" pt_set [:, :] = coral . living_cover ph_set = _map_data . createVariable ( \"PH\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) ph_set . long_name = \"healthy coral population at the end of the year\" ph_set . units = \"-\" ph_set [:, :] = coral . living_cover pr_set = _map_data . createVariable ( \"PR\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pr_set . long_name = \"recovering coral population at the end of the year\" pr_set . units = \"-\" pr_set [:, :] = 0 pp_set = _map_data . createVariable ( \"PP\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pp_set . long_name = \"pale coral population at the end of the year\" pp_set . units = \"-\" pp_set [:, :] = 0 pb_set = _map_data . createVariable ( \"PB\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pb_set . long_name = \"bleached coral population at the end of the year\" pb_set . units = \"-\" pb_set [:, :] = 0 def init_calc (): calc_set = _map_data . createVariable ( \"calc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) calc_set . long_name = \"annual sum calcification rate\" calc_set . units = \"kg m-2 yr-1\" calc_set [:, :] = 0 def init_md (): dc_set = _map_data . createVariable ( \"dc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) dc_set . long_name = \"coral plate diameter\" dc_set . units = \"m\" dc_set [ 0 , :] = coral . dc hc_set = _map_data . createVariable ( \"hc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) hc_set . long_name = \"coral height\" hc_set . units = \"m\" hc_set [ 0 , :] = coral . hc bc_set = _map_data . createVariable ( \"bc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) bc_set . long_name = \"coral base diameter\" bc_set . units = \"m\" bc_set [ 0 , :] = coral . bc tc_set = _map_data . createVariable ( \"tc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) tc_set . long_name = \"coral plate thickness\" tc_set . units = \"m\" tc_set [ 0 , :] = coral . tc ac_set = _map_data . createVariable ( \"ac\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) ac_set . long_name = \"coral axial distance\" ac_set . units = \"m\" ac_set [ 0 , :] = coral . ac vc_set = _map_data . createVariable ( \"Vc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) vc_set . long_name = \"coral volume\" vc_set . units = \"m3\" vc_set [ 0 , :] = coral . volume conditions_funct = dict ( lme = init_lme , fme = init_fme , tme = init_tme , pd = init_pd , ps = init_ps , calc = init_calc , md = init_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func () space : int property readonly \u00b6 Gets the total space for the model-defined xy-coordinates. Returns: Type Description int int: length of 'xy_coordinates'. update ( self , coral : Coral , year : int ) \u00b6 Write data as annual output covering the whole model domain. :param coral: coral animal :param year: simulation year :type coral: Coral :type year: int Source code in src/core/output/output_model.py def update ( self , coral : Coral , year : int ): \"\"\"Write data as annual output covering the whole model domain. :param coral: coral animal :param year: simulation year :type coral: Coral :type year: int \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _map_data : i = int ( year - self . first_year ) _map_data [ \"time\" ][ i ] = year def update_lme (): _map_data [ \"Iz\" ][ - 1 , :] = coral . light [:, - 1 ] def update_fme (): _map_data [ \"ucm\" ][ - 1 , :] = coral . ucm def update_tme (): _map_data [ \"Tc\" ][ - 1 , :] = coral . temp [:, - 1 ] _map_data [ \"Tlo\" ][ - 1 , :] = ( coral . Tlo if len ( DataReshape . variable2array ( coral . Tlo )) > 1 else coral . Tlo * np . ones ( self . space ) ) _map_data [ \"Thi\" ][ - 1 , :] = ( coral . Thi if len ( DataReshape . variable2array ( coral . Thi )) > 1 else coral . Thi * np . ones ( self . space ) ) def update_pd (): _map_data [ \"PD\" ][ - 1 , :] = coral . photo_rate . mean ( axis = 1 ) def update_ps (): _map_data [ \"PT\" ][ - 1 , :] = coral . pop_states [:, - 1 , :] . sum ( axis = 1 ) _map_data [ \"PH\" ][ - 1 , :] = coral . pop_states [:, - 1 , 0 ] _map_data [ \"PR\" ][ - 1 , :] = coral . pop_states [:, - 1 , 1 ] _map_data [ \"PP\" ][ - 1 , :] = coral . pop_states [:, - 1 , 2 ] _map_data [ \"PB\" ][ - 1 , :] = coral . pop_states [:, - 1 , 3 ] def update_calc (): _map_data [ \"calc\" ][ - 1 , :] = coral . calc . sum ( axis = 1 ) def update_md (): _map_data [ \"dc\" ][ - 1 , :] = coral . dc _map_data [ \"hc\" ][ - 1 , :] = coral . hc _map_data [ \"bc\" ][ - 1 , :] = coral . bc _map_data [ \"tc\" ][ - 1 , :] = coral . tc _map_data [ \"ac\" ][ - 1 , :] = coral . ac _map_data [ \"Vc\" ][ - 1 , :] = coral . volume conditions_funct = dict ( lme = update_lme , fme = update_fme , tme = update_tme , pd = update_pd , ps = update_ps , calc = update_calc , md = update_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func ()","title":"Output"},{"location":"reference/output/output/#output-classes-for-the-nbsdynamics-package","text":"","title":"Output classes for the NBSDynamics package."},{"location":"reference/output/output/#protocol","text":"","title":"Protocol"},{"location":"reference/output/output/#src.core.output.output_protocol.OutputProtocol","text":"Protocol defining how an Output model should look like.","title":"OutputProtocol"},{"location":"reference/output/output/#src.core.output.output_protocol.OutputProtocol.initialize","text":"Initializes an output model with the given coral input. Parameters: Name Type Description Default coral Coral Coral input model. required Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/output/output_protocol.py def initialize ( self , coral : Coral ): \"\"\" Initializes an output model with the given coral input. Args: coral (Coral): Coral input model. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"initialize()"},{"location":"reference/output/output/#src.core.output.output_protocol.OutputProtocol.output_filename","text":"The basename with extension the output file will have. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description str str: Output filename.","title":"output_filename"},{"location":"reference/output/output/#src.core.output.output_protocol.OutputProtocol.output_filepath","text":"The full path to the output file. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description Path Path: Output filepath.","title":"output_filepath"},{"location":"reference/output/output/#src.core.output.output_protocol.OutputProtocol.output_params","text":"The output parameters needed to interact with the netcdf dataset. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description ModelParameters ModelParameters: Object with netcdf parameters as attrs..","title":"output_params"},{"location":"reference/output/output/#src.core.output.output_protocol.OutputProtocol.update","text":"Updates the output model with the given coral and year. Parameters: Name Type Description Default coral Coral Coral input model. required year int Current calculation year. required Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/output/output_protocol.py def update ( self , coral : Coral , year : int ): \"\"\" Updates the output model with the given coral and year. Args: coral (Coral): Coral input model. year (int): Current calculation year. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"update()"},{"location":"reference/output/output/#wrapper","text":"","title":"Wrapper"},{"location":"reference/output/output/#src.core.output.output_wrapper.OutputWrapper","text":"Output files based on predefined output content. Generate output files of CoralModel simulation. Output files are formatted as NetCDF4-files.","title":"OutputWrapper"},{"location":"reference/output/output/#src.core.output.output_wrapper.OutputWrapper.__repr__","text":"Representation of Output. Source code in src/core/output/output_wrapper.py def __repr__ ( self ): \"\"\"Representation of Output.\"\"\" return f \"Output(xy_coordinates= { self . xy_coordinates } , first_date= { self . first_date } )\"","title":"__repr__()"},{"location":"reference/output/output/#src.core.output.output_wrapper.OutputWrapper.__str__","text":"String-representation of Output. Source code in src/core/output/output_wrapper.py def __str__ ( self ): \"\"\"String-representation of Output.\"\"\" return ( f \"Output exported: \\n\\t { self . map_output } \\n\\t { self . his_output } \" if self . defined else \"Output undefined.\" )","title":"__str__()"},{"location":"reference/output/output/#src.core.output.output_wrapper.OutputWrapper.check_output_dir","text":"Checks an output_dir attribute is given for the output_model instances map_output and his_output . Parameters: Name Type Description Default values dict Dictionary of attribute values given by the user. required Returns: Type Description dict dict: Dictionary of attribute values with a valid output_dir value. Source code in src/core/output/output_wrapper.py @root_validator ( pre = True ) @classmethod def check_output_dir ( cls , values : dict ) -> dict : \"\"\" Checks an `output_dir` attribute is given for the `output_model` instances `map_output` and `his_output`. Args: values (dict): Dictionary of attribute values given by the user. Returns: dict: Dictionary of attribute values with a valid `output_dir` value. \"\"\" def check_output_model_dir ( out_model : dict ) -> Optional [ dict ]: if out_model is None : return None out_dir_val = out_model . get ( \"output_dir\" , None ) if out_dir_val is None : out_model [ \"output_dir\" ] = values [ \"output_dir\" ] return out_model values [ \"map_output\" ] = check_output_model_dir ( values . get ( \"map_output\" , None )) values [ \"his_output\" ] = check_output_model_dir ( values . get ( \"his_output\" , None )) return values","title":"check_output_dir()"},{"location":"reference/output/output/#src.core.output.output_wrapper.OutputWrapper.defined","text":"Output is defined.","title":"defined"},{"location":"reference/output/output/#src.core.output.output_wrapper.OutputWrapper.get_xy_stations","text":"Determine space indices based on the (x,y)-coordinates of the stations. Parameters: Name Type Description Default xy_coordinates ndarray Input xy-coordinates system. required outpoint ndarray Boolean per x-y indicating if his output is desired. required Returns: Type Description Tuple[numpy.ndarray, numpy.ndarray] Tuple[np.ndarray, np.ndarray]: Resulting tuple of xy_stations, idx_stations Source code in src/core/output/output_wrapper.py @staticmethod def get_xy_stations ( xy_coordinates : np . ndarray , outpoint : np . ndarray ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\" Determine space indices based on the (x,y)-coordinates of the stations. Args: xy_coordinates (np.ndarray): Input xy-coordinates system. outpoint (np.ndarray): Boolean per x-y indicating if his output is desired. Returns: Tuple[np.ndarray, np.ndarray]: Resulting tuple of xy_stations, idx_stations \"\"\" nout_his = len ( xy_coordinates [ outpoint , 0 ]) x_coord = xy_coordinates [:, 0 ] y_coord = xy_coordinates [:, 1 ] x_station = xy_coordinates [ outpoint , 0 ] y_station = xy_coordinates [ outpoint , 1 ] idx = np . zeros ( nout_his ) for s in range ( len ( idx )): idx [ s ] = np . argmin ( ( x_coord - x_station [ s ]) ** 2 + ( y_coord - y_station [ s ]) ** 2 ) idx_stations = idx . astype ( int ) return xy_coordinates [ idx_stations , :], idx_stations","title":"get_xy_stations()"},{"location":"reference/output/output/#src.core.output.output_wrapper.OutputWrapper.initialize","text":"Initializes all available output models (His and Map). Parameters: Name Type Description Default coral Coral Coral model to be used in the output. required Source code in src/core/output/output_wrapper.py def initialize ( self , coral : Coral ): \"\"\" Initializes all available output models (His and Map). Args: coral (Coral): Coral model to be used in the output. \"\"\" # Initialize Output dir path. self . output_dir . mkdir ( parents = True , exist_ok = True ) # Initialize output models. self . his_output . initialize ( coral ) self . map_output . initialize ( coral )","title":"initialize()"},{"location":"reference/output/output/#output-models","text":"","title":"Output models"},{"location":"reference/output/output/#src.core.output.output_model.BaseOutput","text":"Base class containing the generic definition of a 'Coral' output model.","title":"BaseOutput"},{"location":"reference/output/output/#src.core.output.output_model.BaseOutput.output_filepath","text":"Gets the full path to the output netcdf file. Returns: Type Description Path Path: Output .nc file.","title":"output_filepath"},{"location":"reference/output/output/#src.core.output.output_model.BaseOutput.valid_output","text":"Verifies whether this model can generate valid output. Returns: Type Description bool bool: Output is valid. Source code in src/core/output/output_model.py def valid_output ( self ) -> bool : \"\"\" Verifies whether this model can generate valid output. Returns: bool: Output is valid. \"\"\" return self . output_params . valid_output ()","title":"valid_output()"},{"location":"reference/output/output/#src.core.output.output_model.HisOutput","text":"Object representing a His output. Implements the 'OutputProtocol'.","title":"HisOutput"},{"location":"reference/output/output/#src.core.output.output_model.HisOutput.initialize","text":"Initiate history output file in which daily output at predefined locations within the model is stored. Source code in src/core/output/output_model.py def initialize ( self , _ : Coral ): \"\"\"Initiate history output file in which daily output at predefined locations within the model is stored.\"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , \"w\" , format = \"NETCDF4\" ) as _his_data : _his_data . description = \"Historic simulation data of the CoralModel\" # dimensions _his_data . createDimension ( \"time\" , None ) _his_data . createDimension ( \"stations\" , len ( self . xy_stations )) # variables t = _his_data . createVariable ( \"time\" , \"f8\" , ( \"time\" ,)) t . long_name = f \"days since { self . first_date } \" t . units = \"days\" x = _his_data . createVariable ( \"station_x_coordinate\" , \"f8\" , ( \"stations\" ,)) y = _his_data . createVariable ( \"station_y_coordinate\" , \"f8\" , ( \"stations\" ,)) # setup data set x [:] = self . xy_stations [:, 0 ] y [:] = self . xy_stations [:, 1 ] def init_lme (): light_set = _his_data . createVariable ( \"Iz\" , \"f8\" , ( \"time\" , \"stations\" )) light_set . long_name = \"representative light-intensity\" light_set . units = \"micro-mol photons m-2 s-1\" def init_fme (): flow_set = _his_data . createVariable ( \"ucm\" , \"f8\" , ( \"time\" , \"stations\" )) flow_set . long_name = \"in-canopy flow\" flow_set . units = \"m s-1\" def init_tme (): temp_set = _his_data . createVariable ( \"Tc\" , \"f8\" , ( \"time\" , \"stations\" )) temp_set . long_name = \"coral temperature\" temp_set . units = \"K\" low_temp_set = _his_data . createVariable ( \"Tlo\" , \"f8\" , ( \"time\" , \"stations\" ) ) low_temp_set . long_name = \"lower thermal limit\" low_temp_set . units = \"K\" high_temp_set = _his_data . createVariable ( \"Thi\" , \"f8\" , ( \"time\" , \"stations\" ) ) high_temp_set . long_name = \"upper thermal limit\" high_temp_set . units = \"K\" def init_pd (): pd_set = _his_data . createVariable ( \"PD\" , \"f8\" , ( \"time\" , \"stations\" )) pd_set . long_name = \"photosynthetic rate\" pd_set . units = \"-\" def init_ps (): pt_set = _his_data . createVariable ( \"PT\" , \"f8\" , ( \"time\" , \"stations\" )) pt_set . long_name = \"total coral population\" pt_set . units = \"-\" ph_set = _his_data . createVariable ( \"PH\" , \"f8\" , ( \"time\" , \"stations\" )) ph_set . long_name = \"healthy coral population\" ph_set . units = \"-\" pr_set = _his_data . createVariable ( \"PR\" , \"f8\" , ( \"time\" , \"stations\" )) pr_set . long_name = \"recovering coral population\" pr_set . units = \"-\" pp_set = _his_data . createVariable ( \"PP\" , \"f8\" , ( \"time\" , \"stations\" )) pp_set . long_name = \"pale coral population\" pp_set . units = \"-\" pb_set = _his_data . createVariable ( \"PB\" , \"f8\" , ( \"time\" , \"stations\" )) pb_set . long_name = \"bleached coral population\" pb_set . units = \"-\" def init_calc (): calc_set = _his_data . createVariable ( \"G\" , \"f8\" , ( \"time\" , \"stations\" )) calc_set . long_name = \"calcification\" calc_set . units = \"kg m-2 d-1\" def init_md (): dc_set = _his_data . createVariable ( \"dc\" , \"f8\" , ( \"time\" , \"stations\" )) dc_set . long_name = \"coral plate diameter\" dc_set . units = \"m\" hc_set = _his_data . createVariable ( \"hc\" , \"f8\" , ( \"time\" , \"stations\" )) hc_set . long_name = \"coral height\" hc_set . units = \"m\" bc_set = _his_data . createVariable ( \"bc\" , \"f8\" , ( \"time\" , \"stations\" )) bc_set . long_name = \"coral base diameter\" bc_set . units = \"m\" tc_set = _his_data . createVariable ( \"tc\" , \"f8\" , ( \"time\" , \"stations\" )) tc_set . long_name = \"coral plate thickness\" tc_set . units = \"m\" ac_set = _his_data . createVariable ( \"ac\" , \"f8\" , ( \"time\" , \"stations\" )) ac_set . long_name = \"coral axial distance\" ac_set . units = \"m\" vc_set = _his_data . createVariable ( \"Vc\" , \"f8\" , ( \"time\" , \"stations\" )) vc_set . long_name = \"coral volume\" vc_set . units = \"m3\" # initial conditions conditions_funct = dict ( lme = init_lme , fme = init_fme , tme = init_tme , pd = init_pd , ps = init_ps , calc = init_calc , md = init_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func ()","title":"initialize()"},{"location":"reference/output/output/#src.core.output.output_model.HisOutput.update","text":"Write data as daily output at predefined locations within the model domain. :param coral: coral animal :param dates: dates of simulation year :type coral: Coral :type dates: DataFrame Source code in src/core/output/output_model.py def update ( self , coral : Coral , dates : DataFrame ): \"\"\"Write data as daily output at predefined locations within the model domain. :param coral: coral animal :param dates: dates of simulation year :type coral: Coral :type dates: DataFrame \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _his_data : y_dates = dates . reset_index ( drop = True ) ti = ( y_dates - self . first_date ) . dt . days . values _his_data [ \"time\" ][ ti ] = y_dates . values def update_lme (): _his_data [ \"Iz\" ][ ti , :] = coral . light [ self . idx_stations , :] . transpose () def update_fme (): _his_data [ \"ucm\" ][ ti , :] = np . tile ( coral . ucm , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] def update_tme (): _his_data [ \"Tc\" ][ ti , :] = coral . temp [ self . idx_stations , :] . transpose () if ( len ( DataReshape . variable2array ( coral . Tlo )) > 1 and len ( DataReshape . variable2array ( coral . Thi )) > 1 ): _his_data [ \"Tlo\" ][ ti , :] = np . tile ( coral . Tlo , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"Thi\" ][ ti , :] = np . tile ( coral . Thi , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] else : _his_data [ \"Tlo\" ][ ti , :] = coral . Tlo * np . ones ( ( len ( y_dates ), len ( self . idx_stations )) ) _his_data [ \"Thi\" ][ ti , :] = coral . Thi * np . ones ( ( len ( y_dates ), len ( self . idx_stations )) ) def update_pd (): _his_data [ \"PD\" ][ ti , :] = coral . photo_rate [ self . idx_stations , : ] . transpose () def update_ps (): _his_data [ \"PT\" ][ ti , :] = ( coral . pop_states [ self . idx_stations , :, :] . sum ( axis = 2 ) . transpose () ) _his_data [ \"PH\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 0 ] . transpose () _his_data [ \"PR\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 1 ] . transpose () _his_data [ \"PP\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 2 ] . transpose () _his_data [ \"PB\" ][ ti , :] = coral . pop_states [ self . idx_stations , :, 3 ] . transpose () def update_calc (): _his_data [ \"G\" ][ ti , :] = coral . calc [ self . idx_stations , :] . transpose () def update_md (): _his_data [ \"dc\" ][ ti , :] = np . tile ( coral . dc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"hc\" ][ ti , :] = np . tile ( coral . hc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"bc\" ][ ti , :] = np . tile ( coral . bc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"tc\" ][ ti , :] = np . tile ( coral . tc , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"ac\" ][ ti , :] = np . tile ( coral . ac , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] _his_data [ \"Vc\" ][ ti , :] = np . tile ( coral . volume , ( len ( y_dates ), 1 ))[ :, self . idx_stations ] conditions_funct = dict ( lme = update_lme , fme = update_fme , tme = update_tme , pd = update_pd , ps = update_ps , calc = update_calc , md = update_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func ()","title":"update()"},{"location":"reference/output/output/#src.core.output.output_model.MapOutput","text":"Object representing a Map output. Implements the 'OutputProtocol'.","title":"MapOutput"},{"location":"reference/output/output/#src.core.output.output_model.MapOutput.initialize","text":"Initiate mapping output file in which annual output covering the whole model domain is stored. :param coral: coral animal :type coral: Coral Source code in src/core/output/output_model.py def initialize ( self , coral : Coral ): \"\"\"Initiate mapping output file in which annual output covering the whole model domain is stored. :param coral: coral animal :type coral: Coral \"\"\" if not self . valid_output (): return # Open netcdf data and initialize needed variables. with Dataset ( self . output_filepath , \"w\" , format = \"NETCDF4\" ) as _map_data : _map_data . description = \"Mapped simulation data of the CoralModel.\" # dimensions _map_data . createDimension ( \"time\" , None ) _map_data . createDimension ( \"nmesh2d_face\" , self . space ) # variables t = _map_data . createVariable ( \"time\" , int , ( \"time\" ,)) t . long_name = \"year\" t . units = \"years since 0 B.C.\" x = _map_data . createVariable ( \"nmesh2d_x\" , \"f8\" , ( \"nmesh2d_face\" ,)) x . long_name = \"x-coordinate\" x . units = \"m\" y = _map_data . createVariable ( \"nmesh2d_y\" , \"f8\" , ( \"nmesh2d_face\" ,)) y . long_name = \"y-coordinate\" y . units = \"m\" t [:] = self . first_year x [:] = self . xy_coordinates [:, 0 ] y [:] = self . xy_coordinates [:, 1 ] # initial conditions # Definition of methods to initialize the netcdf variables. def init_lme (): light_set = _map_data . createVariable ( \"Iz\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) light_set . long_name = \"annual mean representative light-intensity\" light_set . units = \"micro-mol photons m-2 s-1\" light_set [:, :] = 0 def init_fme (): flow_set = _map_data . createVariable ( \"ucm\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) flow_set . long_name = \"annual mean in-canopy flow\" flow_set . units = \"m s-1\" flow_set [:, :] = 0 def init_tme (): temp_set = _map_data . createVariable ( \"Tc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) temp_set . long_name = \"annual mean coral temperature\" temp_set . units = \"K\" temp_set [:, :] = 0 low_temp_set = _map_data . createVariable ( \"Tlo\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) low_temp_set . long_name = \"annual mean lower thermal limit\" low_temp_set . units = \"K\" low_temp_set [:, :] = 0 high_temp_set = _map_data . createVariable ( \"Thi\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) high_temp_set . long_name = \"annual mean upper thermal limit\" high_temp_set . units = \"K\" high_temp_set [:, :] = 0 def init_pd (): pd_set = _map_data . createVariable ( \"PD\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pd_set . long_name = \"annual sum photosynthetic rate\" pd_set . units = \"-\" pd_set [:, :] = 0 def init_ps (): pt_set = _map_data . createVariable ( \"PT\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pt_set . long_name = ( \"total living coral population at the end of the year\" ) pt_set . units = \"-\" pt_set [:, :] = coral . living_cover ph_set = _map_data . createVariable ( \"PH\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) ph_set . long_name = \"healthy coral population at the end of the year\" ph_set . units = \"-\" ph_set [:, :] = coral . living_cover pr_set = _map_data . createVariable ( \"PR\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pr_set . long_name = \"recovering coral population at the end of the year\" pr_set . units = \"-\" pr_set [:, :] = 0 pp_set = _map_data . createVariable ( \"PP\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pp_set . long_name = \"pale coral population at the end of the year\" pp_set . units = \"-\" pp_set [:, :] = 0 pb_set = _map_data . createVariable ( \"PB\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) pb_set . long_name = \"bleached coral population at the end of the year\" pb_set . units = \"-\" pb_set [:, :] = 0 def init_calc (): calc_set = _map_data . createVariable ( \"calc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" ) ) calc_set . long_name = \"annual sum calcification rate\" calc_set . units = \"kg m-2 yr-1\" calc_set [:, :] = 0 def init_md (): dc_set = _map_data . createVariable ( \"dc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) dc_set . long_name = \"coral plate diameter\" dc_set . units = \"m\" dc_set [ 0 , :] = coral . dc hc_set = _map_data . createVariable ( \"hc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) hc_set . long_name = \"coral height\" hc_set . units = \"m\" hc_set [ 0 , :] = coral . hc bc_set = _map_data . createVariable ( \"bc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) bc_set . long_name = \"coral base diameter\" bc_set . units = \"m\" bc_set [ 0 , :] = coral . bc tc_set = _map_data . createVariable ( \"tc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) tc_set . long_name = \"coral plate thickness\" tc_set . units = \"m\" tc_set [ 0 , :] = coral . tc ac_set = _map_data . createVariable ( \"ac\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) ac_set . long_name = \"coral axial distance\" ac_set . units = \"m\" ac_set [ 0 , :] = coral . ac vc_set = _map_data . createVariable ( \"Vc\" , \"f8\" , ( \"time\" , \"nmesh2d_face\" )) vc_set . long_name = \"coral volume\" vc_set . units = \"m3\" vc_set [ 0 , :] = coral . volume conditions_funct = dict ( lme = init_lme , fme = init_fme , tme = init_tme , pd = init_pd , ps = init_ps , calc = init_calc , md = init_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func ()","title":"initialize()"},{"location":"reference/output/output/#src.core.output.output_model.MapOutput.space","text":"Gets the total space for the model-defined xy-coordinates. Returns: Type Description int int: length of 'xy_coordinates'.","title":"space"},{"location":"reference/output/output/#src.core.output.output_model.MapOutput.update","text":"Write data as annual output covering the whole model domain. :param coral: coral animal :param year: simulation year :type coral: Coral :type year: int Source code in src/core/output/output_model.py def update ( self , coral : Coral , year : int ): \"\"\"Write data as annual output covering the whole model domain. :param coral: coral animal :param year: simulation year :type coral: Coral :type year: int \"\"\" if not self . valid_output (): return with Dataset ( self . output_filepath , mode = \"a\" ) as _map_data : i = int ( year - self . first_year ) _map_data [ \"time\" ][ i ] = year def update_lme (): _map_data [ \"Iz\" ][ - 1 , :] = coral . light [:, - 1 ] def update_fme (): _map_data [ \"ucm\" ][ - 1 , :] = coral . ucm def update_tme (): _map_data [ \"Tc\" ][ - 1 , :] = coral . temp [:, - 1 ] _map_data [ \"Tlo\" ][ - 1 , :] = ( coral . Tlo if len ( DataReshape . variable2array ( coral . Tlo )) > 1 else coral . Tlo * np . ones ( self . space ) ) _map_data [ \"Thi\" ][ - 1 , :] = ( coral . Thi if len ( DataReshape . variable2array ( coral . Thi )) > 1 else coral . Thi * np . ones ( self . space ) ) def update_pd (): _map_data [ \"PD\" ][ - 1 , :] = coral . photo_rate . mean ( axis = 1 ) def update_ps (): _map_data [ \"PT\" ][ - 1 , :] = coral . pop_states [:, - 1 , :] . sum ( axis = 1 ) _map_data [ \"PH\" ][ - 1 , :] = coral . pop_states [:, - 1 , 0 ] _map_data [ \"PR\" ][ - 1 , :] = coral . pop_states [:, - 1 , 1 ] _map_data [ \"PP\" ][ - 1 , :] = coral . pop_states [:, - 1 , 2 ] _map_data [ \"PB\" ][ - 1 , :] = coral . pop_states [:, - 1 , 3 ] def update_calc (): _map_data [ \"calc\" ][ - 1 , :] = coral . calc . sum ( axis = 1 ) def update_md (): _map_data [ \"dc\" ][ - 1 , :] = coral . dc _map_data [ \"hc\" ][ - 1 , :] = coral . hc _map_data [ \"bc\" ][ - 1 , :] = coral . bc _map_data [ \"tc\" ][ - 1 , :] = coral . tc _map_data [ \"ac\" ][ - 1 , :] = coral . ac _map_data [ \"Vc\" ][ - 1 , :] = coral . volume conditions_funct = dict ( lme = update_lme , fme = update_fme , tme = update_tme , pd = update_pd , ps = update_ps , calc = update_calc , md = update_md , ) for key , v_func in conditions_funct . items (): if self . output_params . dict ()[ key ]: v_func ()","title":"update()"},{"location":"reference/simulation/simulation/","text":"Classes representing the available simulation modes. \u00b6 Simulation Protocol \u00b6 SimulationProtocol \u00b6 Protocol to define simulations for the NBSDynamics project. constants : Constants property readonly \u00b6 Constants being used for calculations during simulation. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description Constants Constants: Instance of Constants. coral : Coral property readonly \u00b6 Instance of a Coral model object. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description Coral Coral: Coral instance. environment : Environment property readonly \u00b6 Environment in which the simulation takes place. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description Environment Environment: Instantiated environment. finalise ( self ) \u00b6 Finalizes simulation Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/simulation/simulation_protocol.py def finalise ( self ): \"\"\" Finalizes simulation Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError hydrodynamics : HydrodynamicProtocol property readonly \u00b6 Instance of hydrodynamic model. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description HydrodynamicProtocol HydrodynamicProtocol: Instantiated object. initiate ( self , x_range : tuple , y_range : tuple , value : float ) -> Coral \u00b6 Initiates the simulation attributes with the given parameters. Parameters: Name Type Description Default x_range tuple Minimum and maximum x-coordinate. required y_range tuple Minimum and maximum y-coordinate. required value float Coral cover. required Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description Coral Coral: Initiated coral animal. Source code in src/core/simulation/simulation_protocol.py def initiate ( self , x_range : tuple , y_range : tuple , value : float ) -> Coral : \"\"\" Initiates the simulation attributes with the given parameters. Args: x_range (tuple): Minimum and maximum x-coordinate. y_range (tuple): Minimum and maximum y-coordinate. value (float): Coral cover. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Coral: Initiated coral animal. \"\"\" raise NotImplementedError mode : str property readonly \u00b6 Name of the mode the simulation should run. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description str str: Hydrodynamic mode name. output : OutputWrapper property readonly \u00b6 Wrapper containing different output models. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description OutputWrapper OutputWrapper: Instance of OutputWrapper. run ( self , duration : int ) \u00b6 Run the simulation with the initiated attributes. Parameters: Name Type Description Default duration int Simulation duration [yrs]. required Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/simulation/simulation_protocol.py def run ( self , duration : int ): \"\"\" Run the simulation with the initiated attributes. Args: duration (int): Simulation duration [yrs]. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError Base simulation. \u00b6 BaseSimulation pydantic-model \u00b6 Implements the SimulationProtocol . Facade class that can be implemented through an Adapter pattern. CoralModel simulation. configure_hydrodynamics ( self ) \u00b6 Configures the parameters for the HydrodynamicsProtocol . Exceptions: Type Description NotImplementedError When abstract method not defined in concrete class. Source code in src/core/simulation/base_simulation.py @abstractmethod def configure_hydrodynamics ( self ): \"\"\" Configures the parameters for the `HydrodynamicsProtocol`. Raises: NotImplementedError: When abstract method not defined in concrete class. \"\"\" raise NotImplementedError configure_output ( self ) \u00b6 Configures the parameters for the OutputWrapper . Source code in src/core/simulation/base_simulation.py @abstractmethod def configure_output ( self ): \"\"\" Configures the parameters for the `OutputWrapper`. \"\"\" raise NotImplementedError finalise ( self ) \u00b6 Finalise simulation. Source code in src/core/simulation/base_simulation.py def finalise ( self ): \"\"\"Finalise simulation.\"\"\" self . hydrodynamics . finalise () initiate ( self , x_range : Optional [ tuple ] = None , y_range : Optional [ tuple ] = None , value : Optional [ float ] = None ) -> Coral \u00b6 Initiate the coral distribution. The default coral distribution is a full coral cover over the whole domain. More complex initial conditions of the coral cover cannot be realised with this method. See the documentation on workarounds to achieve this anyway. :param x_range: minimum and maximum x-coordinate, defaults to None :param y_range: minimum and maximum y-coordinate, defaults to None :param value: coral cover, defaults to None :type coral: Coral :type x_range: tuple, optional :type y_range: tuple, optional :type value: float, optional :return: coral animal initiated :rtype: Coral Source code in src/core/simulation/base_simulation.py def initiate ( self , x_range : Optional [ tuple ] = None , y_range : Optional [ tuple ] = None , value : Optional [ float ] = None , ) -> Coral : \"\"\"Initiate the coral distribution. The default coral distribution is a full coral cover over the whole domain. More complex initial conditions of the coral cover cannot be realised with this method. See the documentation on workarounds to achieve this anyway. :param x_range: minimum and maximum x-coordinate, defaults to None :param y_range: minimum and maximum y-coordinate, defaults to None :param value: coral cover, defaults to None :type coral: Coral :type x_range: tuple, optional :type y_range: tuple, optional :type value: float, optional :return: coral animal initiated :rtype: Coral \"\"\" self . configure_hydrodynamics () self . configure_output () # Load constants and validate environment. self . validate_simulation_directories () self . validate_environment () RESHAPE () . space = self . hydrodynamics . space if self . output . defined : self . output . initialize ( self . coral ) else : print ( \"WARNING: No output defined, so none exported.\" ) xy = self . hydrodynamics . xy_coordinates if value is None : value = 1 cover = value * np . ones ( RESHAPE () . space ) if x_range is not None : x_min = x_range [ 0 ] if x_range [ 0 ] is not None else min ( xy [:][ 0 ]) x_max = x_range [ 1 ] if x_range [ 1 ] is not None else max ( xy [:][ 0 ]) cover [ np . logical_or ( xy [:][ 0 ] <= x_min , xy [:][ 0 ] >= x_max )] = 0 if y_range is not None : y_min = y_range [ 0 ] if y_range [ 0 ] is not None else min ( xy [:][ 1 ]) y_max = y_range [ 1 ] if y_range [ 1 ] is not None else max ( xy [:][ 1 ]) cover [ np . logical_or ( xy [:][ 1 ] <= y_min , xy [:][ 1 ] >= y_max )] = 0 self . coral . initiate_coral_morphology ( cover ) self . output . initialize ( self . coral ) run ( self , duration : Optional [ int ] = None ) \u00b6 Run simulation. :param coral: coral animal :param duration: simulation duration [yrs], defaults to None :type coral: Coral :type duration: int, optional Source code in src/core/simulation/base_simulation.py def run ( self , duration : Optional [ int ] = None ): \"\"\"Run simulation. :param coral: coral animal :param duration: simulation duration [yrs], defaults to None :type coral: Coral :type duration: int, optional \"\"\" # auto-set duration based on environmental time-series environment_dates : pd . core . series . Series = self . environment . get_dates () if duration is None : duration = int ( environment_dates . iloc [ - 1 ] . year - environment_dates . iloc [ 0 ] . year ) years = range ( int ( environment_dates . iloc [ 0 ] . year ), int ( environment_dates . iloc [ 0 ] . year + duration ), ) with tqdm ( range (( int ( duration )))) as progress : for i in progress : # set dimensions (i.e. update time-dimension) RESHAPE () . time = len ( environment_dates . dt . year [ environment_dates . dt . year == years [ i ]] ) # if-statement that encompasses all for which the hydrodynamic should be used progress . set_postfix ( inner_loop = f \"update { self . hydrodynamics } \" ) current_vel , wave_vel , wave_per = self . hydrodynamics . update ( self . coral , stormcat = 0 ) # # environment progress . set_postfix ( inner_loop = \"coral environment\" ) # light micro-environment lme = Light ( light_in = time_series_year ( self . environment . light , years [ i ]), lac = time_series_year ( self . environment . light_attenuation , years [ i ]), depth = self . hydrodynamics . water_depth , ) lme . rep_light ( self . coral ) # flow micro-environment fme = Flow ( u_current = current_vel , u_wave = wave_vel , h = self . hydrodynamics . water_depth , peak_period = wave_per , constants = self . constants , ) fme . velocities ( self . coral , in_canopy = self . constants . fme ) fme . thermal_boundary_layer ( self . coral ) # thermal micro-environment tme = Temperature ( constants = self . constants , temperature = time_series_year ( self . environment . temp_kelvin , years [ i ] ), ) tme . coral_temperature ( self . coral ) # # physiology progress . set_postfix ( inner_loop = \"coral physiology\" ) # photosynthetic dependencies phd = Photosynthesis ( constants = self . constants , light_in = time_series_year ( self . environment . light , years [ i ]), first_year = True if i == 0 else False , ) phd . photo_rate ( self . coral , self . environment , years [ i ]) # population states ps = PopulationStates ( constants = self . constants ) ps . pop_states_t ( self . coral ) # calcification cr = Calcification ( constants = self . constants ) cr . calcification_rate ( self . coral , time_series_year ( self . environment . aragonite , years [ i ]) ) # # morphology progress . set_postfix ( inner_loop = \"coral morphology\" ) # morphological development mor = Morphology ( constants = self . constants , calc_sum = self . coral . calc . sum ( axis = 1 ), light_in = time_series_year ( self . environment . light , years [ i ]), ) mor . update ( self . coral ) # # storm damage if self . environment . storm_category is not None : tt = self . environment . storm_category yr = years [ i ] stormcat = int ( tt [ \"stormcat\" ] . values [ tt . index == yr ]) if stormcat > 0 : progress . set_postfix ( inner_loop = \"storm damage\" ) # update hydrodynamic model current_vel , wave_vel , wave_per = self . hydrodynamics . update ( self . coral , stormcat ) # storm flow environment sfe = Flow ( constants = self . constants , u_current = current_vel , u_wave = wave_vel , h = self . hydrodynamics . water_depth , peak_period = wave_per , ) sfe . velocities ( self . coral , in_canopy = self . constants . fme ) # storm dislodgement criterion sdc = Dislodgement ( constants = self . constants ) sdc . update ( self . coral ) # # recruitment progress . set_postfix ( inner_loop = \"coral recruitment\" ) # recruitment rec = Recruitment ( constants = self . constants ) rec . update ( self . coral ) # # export results progress . set_postfix ( inner_loop = \"export results\" ) # map-file self . output . map_output . update ( self . coral , years [ i ]) # his-file self . output . his_output . update ( self . coral , environment_dates [ environment_dates . dt . year == years [ i ]], ) validate_constants ( field_value : Union [ str , pathlib . Path , src . core . common . constants . Constants ]) -> Constants classmethod \u00b6 Validates the user-input constants value and transforms in case it's a filepath (str, Path). Parameters: Name Type Description Default field_value Union[str, pathlib.Path, src.core.common.constants.Constants] Value given by the user representing Constants. required Exceptions: Type Description NotImplementedError When the input value does not have any converter. Returns: Type Description Constants Constants: Validated constants value. Source code in src/core/simulation/base_simulation.py @validator ( \"constants\" , pre = True ) @classmethod def validate_constants ( cls , field_value : Union [ str , Path , Constants ]) -> Constants : \"\"\" Validates the user-input constants value and transforms in case it's a filepath (str, Path). Args: field_value (Union[str, Path, Constants]): Value given by the user representing Constants. Raises: NotImplementedError: When the input value does not have any converter. Returns: Constants: Validated constants value. \"\"\" if isinstance ( field_value , Constants ): return field_value if isinstance ( field_value , str ): field_value = Path ( field_value ) if isinstance ( field_value , Path ): return Constants . from_input_file ( field_value ) raise NotImplementedError ( f \"Validator not available for { type ( field_value ) } \" ) validate_coral ( field_value : Union [ dict , src . core . coral . coral_model . Coral ], values : dict ) -> Coral classmethod \u00b6 Initializes coral in case a dictionary is provided. Ensuring the constants are also given to the object. Parameters: Name Type Description Default field_value Union[dict, src.core.coral.coral_model.Coral] Value given by the user for the Coral field. required values dict Dictionary of remaining user-given field values. required Returns: Type Description Coral Coral: Validated instance of 'Coral'. Source code in src/core/simulation/base_simulation.py @validator ( \"coral\" , pre = True ) @classmethod def validate_coral ( cls , field_value : Union [ dict , Coral ], values : dict ) -> Coral : \"\"\" Initializes coral in case a dictionary is provided. Ensuring the constants are also given to the object. Args: field_value (Union[dict, Coral]): Value given by the user for the Coral field. values (dict): Dictionary of remaining user-given field values. Returns: Coral: Validated instance of 'Coral'. \"\"\" if isinstance ( field_value , Coral ): return field_value if isinstance ( field_value , dict ): # Check if constants present in the dictionary: if \"constants\" in field_value . keys (): # It will be generated automatically. # in case parameters are missing an error will also be displayed. return Coral ( ** field_value ) if \"constants\" in values . keys (): field_value [ \"constants\" ] = values [ \"constants\" ] return Coral ( ** field_value ) raise ValueError ( \"Constants should be provided to initialize a Coral Model.\" ) raise NotImplementedError ( f \"Validator not available for { type ( field_value ) } \" ) validate_environment ( self ) \u00b6 Check input; if all required data is provided. Source code in src/core/simulation/base_simulation.py def validate_environment ( self ): \"\"\"Check input; if all required data is provided.\"\"\" if self . environment . light is None : msg = \"CoralModel simulation cannot run without data on light conditions.\" raise ValueError ( msg ) if self . environment . temperature is None : msg = \"CoralModel simulation cannot run without data on temperature conditions.\" raise ValueError ( msg ) if self . environment . light_attenuation is None : self . environment . set_parameter_values ( \"light_attenuation\" , self . constants . Kd0 ) print ( f \"Light attenuation coefficient set to default: Kd = { self . constants . Kd0 } [m-1]\" ) if self . environment . aragonite is None : self . environment . set_parameter_values ( \"aragonite\" , self . constants . omegaA0 ) print ( f \"Aragonite saturation state set to default: omega_a0 = { self . constants . omegaA0 } [-]\" ) # TODO: add other dependencies based on process switches in self.constants if required validate_hydrodynamics_present ( field_values : Union [ dict , src . core . hydrodynamics . hydrodynamic_protocol . HydrodynamicProtocol ], values : dict ) -> HydrodynamicProtocol classmethod \u00b6 Validator to transform the given dictionary into the corresponding hydrodynamic model. Parameters: Name Type Description Default field_values Union[dict, src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol] Value assigned to hydrodynamics . required values dict Dictionary of values given by the user. required Exceptions: Type Description ValueError When no hydrodynamics model can be built with the given values. Returns: Type Description HydrodynamicProtocol dict: Validated dictionary of values given by the user. Source code in src/core/simulation/base_simulation.py @validator ( \"hydrodynamics\" , pre = True , always = True ) @classmethod def validate_hydrodynamics_present ( cls , field_values : Union [ dict , HydrodynamicProtocol ], values : dict ) -> HydrodynamicProtocol : \"\"\" Validator to transform the given dictionary into the corresponding hydrodynamic model. Args: field_values (Union[dict, HydrodynamicProtocol]): Value assigned to `hydrodynamics`. values (dict): Dictionary of values given by the user. Raises: ValueError: When no hydrodynamics model can be built with the given values. Returns: dict: Validated dictionary of values given by the user. \"\"\" if field_values is None : field_values = dict () if isinstance ( field_values , dict ): return HydrodynamicsFactory . create ( field_values . get ( \"mode\" , values [ \"mode\" ]), ** field_values ) return field_values validate_simulation_directories ( self ) \u00b6 Generates the required directories if they do not exist already. Source code in src/core/simulation/base_simulation.py def validate_simulation_directories ( self ): \"\"\" Generates the required directories if they do not exist already. \"\"\" loop_dirs : List [ Path ] = [ \"working_dir\" , \"output_dir\" , \"input_dir\" , \"figures_dir\" , ] for loop_dir in loop_dirs : value_dir : Path = getattr ( self , loop_dir ) if not value_dir . is_dir (): value_dir . mkdir ( parents = True ) Simulation pydantic-model \u00b6 Vanilla definition of the BaseSimulation that allows any user to create their flat simulation without pre-defined values. In other words, everything should be built manually. configure_hydrodynamics ( self ) \u00b6 This flat Simulation type does not configure anything automatically. Source code in src/core/simulation/base_simulation.py def configure_hydrodynamics ( self ): \"\"\" This flat Simulation type does not configure anything automatically. \"\"\" pass configure_output ( self ) \u00b6 This flat Simulation type does not configure anything automatically. Source code in src/core/simulation/base_simulation.py def configure_output ( self ): \"\"\" This flat Simulation type does not configure anything automatically. \"\"\" pass Coral Delft3D (FlowFM / DIMR) \u00b6 CoralDimrSimulation pydantic-model \u00b6 Coral Dimr Simulation representation. Implements the specific logic needed to run a Coral Simulation with a DIMR kernel through BMIWrapper CoralFlowFmSimulation pydantic-model \u00b6 Coral FlowFM Simulation representation. Implements the specific logic needed to run a Coral Simulation with a FlowFM kernel through BMIWrapper Coral Transect \u00b6 CoralTransectSimulation pydantic-model \u00b6 Implements the SimulationProtocol Coral Transect Simulation. Contains the specific logic and parameters required for the case. configure_hydrodynamics ( self ) \u00b6 Initializes the HydrodynamicsProtocol model. Source code in src/core/simulation/coral_transect_simulation.py def configure_hydrodynamics ( self ): \"\"\" Initializes the `HydrodynamicsProtocol` model. \"\"\" self . hydrodynamics . initiate () configure_output ( self ) \u00b6 Sets the Coral Transect specific values to the OutputWrapper . Should be run after configure_hydrodynamics . Source code in src/core/simulation/coral_transect_simulation.py def configure_output ( self ): \"\"\" Sets the Coral `Transect` specific values to the `OutputWrapper`. Should be run after `configure_hydrodynamics`. \"\"\" # Initialize the OutputWrapper first_date = self . environment . get_dates ()[ 0 ] xy_coordinates = self . hydrodynamics . xy_coordinates outpoint = self . hydrodynamics . outpoint def get_output_wrapper_dict () -> dict : return dict ( first_date = first_date , xy_coordinates = xy_coordinates , outpoint = outpoint , output_dir = self . working_dir / \"output\" , ) def get_map_output_dict ( output_dict : dict ) -> dict : return dict ( output_dir = output_dict [ \"output_dir\" ], first_year = output_dict [ \"first_date\" ] . year , xy_coordinates = output_dict [ \"xy_coordinates\" ], ) def get_his_output_dict ( output_dict : dict ) -> dict : xy_stations , idx_stations = OutputWrapper . get_xy_stations ( output_dict [ \"xy_coordinates\" ], output_dict [ \"outpoint\" ] ) return dict ( output_dir = output_dict [ \"output_dir\" ], first_date = output_dict [ \"first_date\" ], xy_stations = xy_stations , idx_stations = idx_stations , ) extended_output = get_output_wrapper_dict () map_dict = get_map_output_dict ( extended_output ) his_dict = get_his_output_dict ( extended_output ) if self . output is None : extended_output [ \"map_output\" ] = map_dict extended_output [ \"his_output\" ] = his_dict self . output = OutputWrapper ( ** extended_output ) return def update_output ( out_model , new_values : dict ): if out_model is None : return None output_dict : dict = out_model . dict () for k , v in new_values . items (): if output_dict . get ( k , None ) is None : setattr ( out_model , k , v ) update_output ( self . output , extended_output ) update_output ( self . output . map_output , map_dict ) update_output ( self . output . his_output , his_dict )","title":"Simulation"},{"location":"reference/simulation/simulation/#classes-representing-the-available-simulation-modes","text":"","title":"Classes representing the available simulation modes."},{"location":"reference/simulation/simulation/#simulation-protocol","text":"","title":"Simulation Protocol"},{"location":"reference/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol","text":"Protocol to define simulations for the NBSDynamics project.","title":"SimulationProtocol"},{"location":"reference/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol.constants","text":"Constants being used for calculations during simulation. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description Constants Constants: Instance of Constants.","title":"constants"},{"location":"reference/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol.coral","text":"Instance of a Coral model object. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description Coral Coral: Coral instance.","title":"coral"},{"location":"reference/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol.environment","text":"Environment in which the simulation takes place. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description Environment Environment: Instantiated environment.","title":"environment"},{"location":"reference/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol.finalise","text":"Finalizes simulation Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/simulation/simulation_protocol.py def finalise ( self ): \"\"\" Finalizes simulation Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"finalise()"},{"location":"reference/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol.hydrodynamics","text":"Instance of hydrodynamic model. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description HydrodynamicProtocol HydrodynamicProtocol: Instantiated object.","title":"hydrodynamics"},{"location":"reference/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol.initiate","text":"Initiates the simulation attributes with the given parameters. Parameters: Name Type Description Default x_range tuple Minimum and maximum x-coordinate. required y_range tuple Minimum and maximum y-coordinate. required value float Coral cover. required Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description Coral Coral: Initiated coral animal. Source code in src/core/simulation/simulation_protocol.py def initiate ( self , x_range : tuple , y_range : tuple , value : float ) -> Coral : \"\"\" Initiates the simulation attributes with the given parameters. Args: x_range (tuple): Minimum and maximum x-coordinate. y_range (tuple): Minimum and maximum y-coordinate. value (float): Coral cover. Raises: NotImplementedError: When the model does not implement its own definition. Returns: Coral: Initiated coral animal. \"\"\" raise NotImplementedError","title":"initiate()"},{"location":"reference/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol.mode","text":"Name of the mode the simulation should run. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description str str: Hydrodynamic mode name.","title":"mode"},{"location":"reference/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol.output","text":"Wrapper containing different output models. Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Returns: Type Description OutputWrapper OutputWrapper: Instance of OutputWrapper.","title":"output"},{"location":"reference/simulation/simulation/#src.core.simulation.simulation_protocol.SimulationProtocol.run","text":"Run the simulation with the initiated attributes. Parameters: Name Type Description Default duration int Simulation duration [yrs]. required Exceptions: Type Description NotImplementedError When the model does not implement its own definition. Source code in src/core/simulation/simulation_protocol.py def run ( self , duration : int ): \"\"\" Run the simulation with the initiated attributes. Args: duration (int): Simulation duration [yrs]. Raises: NotImplementedError: When the model does not implement its own definition. \"\"\" raise NotImplementedError","title":"run()"},{"location":"reference/simulation/simulation/#base-simulation","text":"","title":"Base simulation."},{"location":"reference/simulation/simulation/#src.core.simulation.base_simulation.BaseSimulation","text":"Implements the SimulationProtocol . Facade class that can be implemented through an Adapter pattern. CoralModel simulation.","title":"BaseSimulation"},{"location":"reference/simulation/simulation/#src.core.simulation.base_simulation.BaseSimulation.configure_hydrodynamics","text":"Configures the parameters for the HydrodynamicsProtocol . Exceptions: Type Description NotImplementedError When abstract method not defined in concrete class. Source code in src/core/simulation/base_simulation.py @abstractmethod def configure_hydrodynamics ( self ): \"\"\" Configures the parameters for the `HydrodynamicsProtocol`. Raises: NotImplementedError: When abstract method not defined in concrete class. \"\"\" raise NotImplementedError","title":"configure_hydrodynamics()"},{"location":"reference/simulation/simulation/#src.core.simulation.base_simulation.BaseSimulation.configure_output","text":"Configures the parameters for the OutputWrapper . Source code in src/core/simulation/base_simulation.py @abstractmethod def configure_output ( self ): \"\"\" Configures the parameters for the `OutputWrapper`. \"\"\" raise NotImplementedError","title":"configure_output()"},{"location":"reference/simulation/simulation/#src.core.simulation.base_simulation.BaseSimulation.finalise","text":"Finalise simulation. Source code in src/core/simulation/base_simulation.py def finalise ( self ): \"\"\"Finalise simulation.\"\"\" self . hydrodynamics . finalise ()","title":"finalise()"},{"location":"reference/simulation/simulation/#src.core.simulation.base_simulation.BaseSimulation.initiate","text":"Initiate the coral distribution. The default coral distribution is a full coral cover over the whole domain. More complex initial conditions of the coral cover cannot be realised with this method. See the documentation on workarounds to achieve this anyway. :param x_range: minimum and maximum x-coordinate, defaults to None :param y_range: minimum and maximum y-coordinate, defaults to None :param value: coral cover, defaults to None :type coral: Coral :type x_range: tuple, optional :type y_range: tuple, optional :type value: float, optional :return: coral animal initiated :rtype: Coral Source code in src/core/simulation/base_simulation.py def initiate ( self , x_range : Optional [ tuple ] = None , y_range : Optional [ tuple ] = None , value : Optional [ float ] = None , ) -> Coral : \"\"\"Initiate the coral distribution. The default coral distribution is a full coral cover over the whole domain. More complex initial conditions of the coral cover cannot be realised with this method. See the documentation on workarounds to achieve this anyway. :param x_range: minimum and maximum x-coordinate, defaults to None :param y_range: minimum and maximum y-coordinate, defaults to None :param value: coral cover, defaults to None :type coral: Coral :type x_range: tuple, optional :type y_range: tuple, optional :type value: float, optional :return: coral animal initiated :rtype: Coral \"\"\" self . configure_hydrodynamics () self . configure_output () # Load constants and validate environment. self . validate_simulation_directories () self . validate_environment () RESHAPE () . space = self . hydrodynamics . space if self . output . defined : self . output . initialize ( self . coral ) else : print ( \"WARNING: No output defined, so none exported.\" ) xy = self . hydrodynamics . xy_coordinates if value is None : value = 1 cover = value * np . ones ( RESHAPE () . space ) if x_range is not None : x_min = x_range [ 0 ] if x_range [ 0 ] is not None else min ( xy [:][ 0 ]) x_max = x_range [ 1 ] if x_range [ 1 ] is not None else max ( xy [:][ 0 ]) cover [ np . logical_or ( xy [:][ 0 ] <= x_min , xy [:][ 0 ] >= x_max )] = 0 if y_range is not None : y_min = y_range [ 0 ] if y_range [ 0 ] is not None else min ( xy [:][ 1 ]) y_max = y_range [ 1 ] if y_range [ 1 ] is not None else max ( xy [:][ 1 ]) cover [ np . logical_or ( xy [:][ 1 ] <= y_min , xy [:][ 1 ] >= y_max )] = 0 self . coral . initiate_coral_morphology ( cover ) self . output . initialize ( self . coral )","title":"initiate()"},{"location":"reference/simulation/simulation/#src.core.simulation.base_simulation.BaseSimulation.run","text":"Run simulation. :param coral: coral animal :param duration: simulation duration [yrs], defaults to None :type coral: Coral :type duration: int, optional Source code in src/core/simulation/base_simulation.py def run ( self , duration : Optional [ int ] = None ): \"\"\"Run simulation. :param coral: coral animal :param duration: simulation duration [yrs], defaults to None :type coral: Coral :type duration: int, optional \"\"\" # auto-set duration based on environmental time-series environment_dates : pd . core . series . Series = self . environment . get_dates () if duration is None : duration = int ( environment_dates . iloc [ - 1 ] . year - environment_dates . iloc [ 0 ] . year ) years = range ( int ( environment_dates . iloc [ 0 ] . year ), int ( environment_dates . iloc [ 0 ] . year + duration ), ) with tqdm ( range (( int ( duration )))) as progress : for i in progress : # set dimensions (i.e. update time-dimension) RESHAPE () . time = len ( environment_dates . dt . year [ environment_dates . dt . year == years [ i ]] ) # if-statement that encompasses all for which the hydrodynamic should be used progress . set_postfix ( inner_loop = f \"update { self . hydrodynamics } \" ) current_vel , wave_vel , wave_per = self . hydrodynamics . update ( self . coral , stormcat = 0 ) # # environment progress . set_postfix ( inner_loop = \"coral environment\" ) # light micro-environment lme = Light ( light_in = time_series_year ( self . environment . light , years [ i ]), lac = time_series_year ( self . environment . light_attenuation , years [ i ]), depth = self . hydrodynamics . water_depth , ) lme . rep_light ( self . coral ) # flow micro-environment fme = Flow ( u_current = current_vel , u_wave = wave_vel , h = self . hydrodynamics . water_depth , peak_period = wave_per , constants = self . constants , ) fme . velocities ( self . coral , in_canopy = self . constants . fme ) fme . thermal_boundary_layer ( self . coral ) # thermal micro-environment tme = Temperature ( constants = self . constants , temperature = time_series_year ( self . environment . temp_kelvin , years [ i ] ), ) tme . coral_temperature ( self . coral ) # # physiology progress . set_postfix ( inner_loop = \"coral physiology\" ) # photosynthetic dependencies phd = Photosynthesis ( constants = self . constants , light_in = time_series_year ( self . environment . light , years [ i ]), first_year = True if i == 0 else False , ) phd . photo_rate ( self . coral , self . environment , years [ i ]) # population states ps = PopulationStates ( constants = self . constants ) ps . pop_states_t ( self . coral ) # calcification cr = Calcification ( constants = self . constants ) cr . calcification_rate ( self . coral , time_series_year ( self . environment . aragonite , years [ i ]) ) # # morphology progress . set_postfix ( inner_loop = \"coral morphology\" ) # morphological development mor = Morphology ( constants = self . constants , calc_sum = self . coral . calc . sum ( axis = 1 ), light_in = time_series_year ( self . environment . light , years [ i ]), ) mor . update ( self . coral ) # # storm damage if self . environment . storm_category is not None : tt = self . environment . storm_category yr = years [ i ] stormcat = int ( tt [ \"stormcat\" ] . values [ tt . index == yr ]) if stormcat > 0 : progress . set_postfix ( inner_loop = \"storm damage\" ) # update hydrodynamic model current_vel , wave_vel , wave_per = self . hydrodynamics . update ( self . coral , stormcat ) # storm flow environment sfe = Flow ( constants = self . constants , u_current = current_vel , u_wave = wave_vel , h = self . hydrodynamics . water_depth , peak_period = wave_per , ) sfe . velocities ( self . coral , in_canopy = self . constants . fme ) # storm dislodgement criterion sdc = Dislodgement ( constants = self . constants ) sdc . update ( self . coral ) # # recruitment progress . set_postfix ( inner_loop = \"coral recruitment\" ) # recruitment rec = Recruitment ( constants = self . constants ) rec . update ( self . coral ) # # export results progress . set_postfix ( inner_loop = \"export results\" ) # map-file self . output . map_output . update ( self . coral , years [ i ]) # his-file self . output . his_output . update ( self . coral , environment_dates [ environment_dates . dt . year == years [ i ]], )","title":"run()"},{"location":"reference/simulation/simulation/#src.core.simulation.base_simulation.BaseSimulation.validate_constants","text":"Validates the user-input constants value and transforms in case it's a filepath (str, Path). Parameters: Name Type Description Default field_value Union[str, pathlib.Path, src.core.common.constants.Constants] Value given by the user representing Constants. required Exceptions: Type Description NotImplementedError When the input value does not have any converter. Returns: Type Description Constants Constants: Validated constants value. Source code in src/core/simulation/base_simulation.py @validator ( \"constants\" , pre = True ) @classmethod def validate_constants ( cls , field_value : Union [ str , Path , Constants ]) -> Constants : \"\"\" Validates the user-input constants value and transforms in case it's a filepath (str, Path). Args: field_value (Union[str, Path, Constants]): Value given by the user representing Constants. Raises: NotImplementedError: When the input value does not have any converter. Returns: Constants: Validated constants value. \"\"\" if isinstance ( field_value , Constants ): return field_value if isinstance ( field_value , str ): field_value = Path ( field_value ) if isinstance ( field_value , Path ): return Constants . from_input_file ( field_value ) raise NotImplementedError ( f \"Validator not available for { type ( field_value ) } \" )","title":"validate_constants()"},{"location":"reference/simulation/simulation/#src.core.simulation.base_simulation.BaseSimulation.validate_coral","text":"Initializes coral in case a dictionary is provided. Ensuring the constants are also given to the object. Parameters: Name Type Description Default field_value Union[dict, src.core.coral.coral_model.Coral] Value given by the user for the Coral field. required values dict Dictionary of remaining user-given field values. required Returns: Type Description Coral Coral: Validated instance of 'Coral'. Source code in src/core/simulation/base_simulation.py @validator ( \"coral\" , pre = True ) @classmethod def validate_coral ( cls , field_value : Union [ dict , Coral ], values : dict ) -> Coral : \"\"\" Initializes coral in case a dictionary is provided. Ensuring the constants are also given to the object. Args: field_value (Union[dict, Coral]): Value given by the user for the Coral field. values (dict): Dictionary of remaining user-given field values. Returns: Coral: Validated instance of 'Coral'. \"\"\" if isinstance ( field_value , Coral ): return field_value if isinstance ( field_value , dict ): # Check if constants present in the dictionary: if \"constants\" in field_value . keys (): # It will be generated automatically. # in case parameters are missing an error will also be displayed. return Coral ( ** field_value ) if \"constants\" in values . keys (): field_value [ \"constants\" ] = values [ \"constants\" ] return Coral ( ** field_value ) raise ValueError ( \"Constants should be provided to initialize a Coral Model.\" ) raise NotImplementedError ( f \"Validator not available for { type ( field_value ) } \" )","title":"validate_coral()"},{"location":"reference/simulation/simulation/#src.core.simulation.base_simulation.BaseSimulation.validate_environment","text":"Check input; if all required data is provided. Source code in src/core/simulation/base_simulation.py def validate_environment ( self ): \"\"\"Check input; if all required data is provided.\"\"\" if self . environment . light is None : msg = \"CoralModel simulation cannot run without data on light conditions.\" raise ValueError ( msg ) if self . environment . temperature is None : msg = \"CoralModel simulation cannot run without data on temperature conditions.\" raise ValueError ( msg ) if self . environment . light_attenuation is None : self . environment . set_parameter_values ( \"light_attenuation\" , self . constants . Kd0 ) print ( f \"Light attenuation coefficient set to default: Kd = { self . constants . Kd0 } [m-1]\" ) if self . environment . aragonite is None : self . environment . set_parameter_values ( \"aragonite\" , self . constants . omegaA0 ) print ( f \"Aragonite saturation state set to default: omega_a0 = { self . constants . omegaA0 } [-]\" ) # TODO: add other dependencies based on process switches in self.constants if required","title":"validate_environment()"},{"location":"reference/simulation/simulation/#src.core.simulation.base_simulation.BaseSimulation.validate_hydrodynamics_present","text":"Validator to transform the given dictionary into the corresponding hydrodynamic model. Parameters: Name Type Description Default field_values Union[dict, src.core.hydrodynamics.hydrodynamic_protocol.HydrodynamicProtocol] Value assigned to hydrodynamics . required values dict Dictionary of values given by the user. required Exceptions: Type Description ValueError When no hydrodynamics model can be built with the given values. Returns: Type Description HydrodynamicProtocol dict: Validated dictionary of values given by the user. Source code in src/core/simulation/base_simulation.py @validator ( \"hydrodynamics\" , pre = True , always = True ) @classmethod def validate_hydrodynamics_present ( cls , field_values : Union [ dict , HydrodynamicProtocol ], values : dict ) -> HydrodynamicProtocol : \"\"\" Validator to transform the given dictionary into the corresponding hydrodynamic model. Args: field_values (Union[dict, HydrodynamicProtocol]): Value assigned to `hydrodynamics`. values (dict): Dictionary of values given by the user. Raises: ValueError: When no hydrodynamics model can be built with the given values. Returns: dict: Validated dictionary of values given by the user. \"\"\" if field_values is None : field_values = dict () if isinstance ( field_values , dict ): return HydrodynamicsFactory . create ( field_values . get ( \"mode\" , values [ \"mode\" ]), ** field_values ) return field_values","title":"validate_hydrodynamics_present()"},{"location":"reference/simulation/simulation/#src.core.simulation.base_simulation.BaseSimulation.validate_simulation_directories","text":"Generates the required directories if they do not exist already. Source code in src/core/simulation/base_simulation.py def validate_simulation_directories ( self ): \"\"\" Generates the required directories if they do not exist already. \"\"\" loop_dirs : List [ Path ] = [ \"working_dir\" , \"output_dir\" , \"input_dir\" , \"figures_dir\" , ] for loop_dir in loop_dirs : value_dir : Path = getattr ( self , loop_dir ) if not value_dir . is_dir (): value_dir . mkdir ( parents = True )","title":"validate_simulation_directories()"},{"location":"reference/simulation/simulation/#src.core.simulation.base_simulation.Simulation","text":"Vanilla definition of the BaseSimulation that allows any user to create their flat simulation without pre-defined values. In other words, everything should be built manually.","title":"Simulation"},{"location":"reference/simulation/simulation/#src.core.simulation.base_simulation.Simulation.configure_hydrodynamics","text":"This flat Simulation type does not configure anything automatically. Source code in src/core/simulation/base_simulation.py def configure_hydrodynamics ( self ): \"\"\" This flat Simulation type does not configure anything automatically. \"\"\" pass","title":"configure_hydrodynamics()"},{"location":"reference/simulation/simulation/#src.core.simulation.base_simulation.Simulation.configure_output","text":"This flat Simulation type does not configure anything automatically. Source code in src/core/simulation/base_simulation.py def configure_output ( self ): \"\"\" This flat Simulation type does not configure anything automatically. \"\"\" pass","title":"configure_output()"},{"location":"reference/simulation/simulation/#coral-delft3d-flowfm-dimr","text":"","title":"Coral Delft3D (FlowFM / DIMR)"},{"location":"reference/simulation/simulation/#src.core.simulation.coral_delft3d_simulation.CoralDimrSimulation","text":"Coral Dimr Simulation representation. Implements the specific logic needed to run a Coral Simulation with a DIMR kernel through BMIWrapper","title":"CoralDimrSimulation"},{"location":"reference/simulation/simulation/#src.core.simulation.coral_delft3d_simulation.CoralFlowFmSimulation","text":"Coral FlowFM Simulation representation. Implements the specific logic needed to run a Coral Simulation with a FlowFM kernel through BMIWrapper","title":"CoralFlowFmSimulation"},{"location":"reference/simulation/simulation/#coral-transect","text":"","title":"Coral Transect"},{"location":"reference/simulation/simulation/#src.core.simulation.coral_transect_simulation.CoralTransectSimulation","text":"Implements the SimulationProtocol Coral Transect Simulation. Contains the specific logic and parameters required for the case.","title":"CoralTransectSimulation"},{"location":"reference/simulation/simulation/#src.core.simulation.coral_transect_simulation.CoralTransectSimulation.configure_hydrodynamics","text":"Initializes the HydrodynamicsProtocol model. Source code in src/core/simulation/coral_transect_simulation.py def configure_hydrodynamics ( self ): \"\"\" Initializes the `HydrodynamicsProtocol` model. \"\"\" self . hydrodynamics . initiate ()","title":"configure_hydrodynamics()"},{"location":"reference/simulation/simulation/#src.core.simulation.coral_transect_simulation.CoralTransectSimulation.configure_output","text":"Sets the Coral Transect specific values to the OutputWrapper . Should be run after configure_hydrodynamics . Source code in src/core/simulation/coral_transect_simulation.py def configure_output ( self ): \"\"\" Sets the Coral `Transect` specific values to the `OutputWrapper`. Should be run after `configure_hydrodynamics`. \"\"\" # Initialize the OutputWrapper first_date = self . environment . get_dates ()[ 0 ] xy_coordinates = self . hydrodynamics . xy_coordinates outpoint = self . hydrodynamics . outpoint def get_output_wrapper_dict () -> dict : return dict ( first_date = first_date , xy_coordinates = xy_coordinates , outpoint = outpoint , output_dir = self . working_dir / \"output\" , ) def get_map_output_dict ( output_dict : dict ) -> dict : return dict ( output_dir = output_dict [ \"output_dir\" ], first_year = output_dict [ \"first_date\" ] . year , xy_coordinates = output_dict [ \"xy_coordinates\" ], ) def get_his_output_dict ( output_dict : dict ) -> dict : xy_stations , idx_stations = OutputWrapper . get_xy_stations ( output_dict [ \"xy_coordinates\" ], output_dict [ \"outpoint\" ] ) return dict ( output_dir = output_dict [ \"output_dir\" ], first_date = output_dict [ \"first_date\" ], xy_stations = xy_stations , idx_stations = idx_stations , ) extended_output = get_output_wrapper_dict () map_dict = get_map_output_dict ( extended_output ) his_dict = get_his_output_dict ( extended_output ) if self . output is None : extended_output [ \"map_output\" ] = map_dict extended_output [ \"his_output\" ] = his_dict self . output = OutputWrapper ( ** extended_output ) return def update_output ( out_model , new_values : dict ): if out_model is None : return None output_dict : dict = out_model . dict () for k , v in new_values . items (): if output_dict . get ( k , None ) is None : setattr ( out_model , k , v ) update_output ( self . output , extended_output ) update_output ( self . output . map_output , map_dict ) update_output ( self . output . his_output , his_dict )","title":"configure_output()"}]}